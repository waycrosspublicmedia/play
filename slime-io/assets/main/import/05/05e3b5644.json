[1,["63jDmJ6hdCyZiG+0EMPY67","2eCwMXMzJA+qgw2iLbRDEi@f9941","21SsCmN6hBvZJzQLZBqoo6@f9941","dapfFxWY1Fm7gJ8own8yfL","a6cEyM5nhDQpyXToBRmokA","95W386BwBHCYI2n3/2K+In@f9941","487h6/yxtL74JaENTDR6ZY@f9941","67BNmuvPVEx5ESWHK3CSLk@f9941","eb1lZAQPlJKJxKlzAeHJTW","67eCgC3gtGwbrOd9OSPUbD@f9941","84DJ71/DlC/Y36CdkWnULG","d1NGQ2rJZCcbhjH0/erZWw","20g1ukYUVPvKWKBRznAKo+@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","deJ2X6uedCIb+RuJHpVCf9@f9941","680jNh6xNNOrg7FwhJqOHt@6c48a","1bRG3NbR9GzZZNAM8LQnJ8@f9941","8dXVZu5YNJP7+6MV/okJ3n","42eXr+0apAPoazoGu434T2@f9941","1cmjdQsjVDcJklfp4oAgJz","96sZKaLhRNmZnnoTrpj+Ux","88dMsWcCZP5qFFL073D0ic@f9941","acOTXBX0pFirIZu9CUmK3S@f9941","9dzB6HocxFho1AZWtnedGG","51czlv7PlBQ6D6idS/tiK8","12Y9dMgWdJKJGmTiZyQR9H@a804a","2eA8erC+pKC7//Adnn5y8r@6c48a","38HJs5tTpBWaXo3SLAa5j2@6c48a","740kC5XehBVL51HVF6WDOv","914khlqXhEtrjBLWbTn9i1","b6leqSDHVIsaDw0ngZuhQM","eeH0AeYZlJ6bpeakvaZ4LH","50A6TglgtINaHjLUFzvyuL","86mSdCYpxP4qpvkx3GJl//","89lAZR34xLLbS4D/hlAxww@f9941","b55XJa649Omao9ItXZLMYM@f9941","ffTBZxIfNCl62rIQOVNFz2@6c48a","1dC7VgOOFMD521CG4mKqDM@f9941","99N542TUpBR5AzuXTp48Um@f9941","98QViWlGVEzKbrhwPeFNPP@f9941","4dKD8HC29DU4foStdOO9BF@f9941","f55f1lENBAbKReceXylAyk@f9941","09OGOQL8hKX7RIIGiov5T6@f9941","0ajKrMeh9CbpOQKH4iQgcH@f9941","71SOvXeb9Ld5vWoCSckm93","d1IVxFQ6BOSoIlFFhj4q+s","cfq1D1/0JDKZQdPPs7+T0f@f9941","c48bI9EVJDlJEi+U/2DgK7","0aEmT6OUBACZy26AAAySoh","1b/Azpnh1F5LWzGo5K1bjw","02lgk90r1A1K2xt2V4481w","1c0gTb2rtIErVITyRux3QS","88D1hQGF5BYaN8pddnJfjb","37ia3dFIFGp5QRaDx81ari","1ei6zzhy5MMrSnO5Vdq2+g","54yVzYuJBA86k+p0pmvTGJ","71y1leg35H0pPLcEl33wiP","daUj5AP51Ayb5dbKWeVXrv","3876ECGsdDwaKVJ4l7CvWS@6c48a","dbbadgzCxJHLw8GUS/BvS0","73tkmBeUJC+Imxe1VBOJaF","e5coUac6xGC4wZ55wo7OnB","a8JVLbAy5ALYAk2TvLl6mg@6c48a","baj9EyOh5IyYuMIMdC8wKb","335brjOv5DxLypkLKdf3xh","9cTKLqLTlJaKSC6lHZxRNq","fbmfUaSVFDLLoTJMP2yfun","d6pzXvTTNBiIiUlkCB6923","17s/bYJPBMU7CC6IEm03WN@f9941","d9NcrApRRIz6S2UWPC2HDg@f9941","e07jP+uIxANYn2+NYA2yvV@f9941","b6qhXiPY5FRYB4f22AEi/c@f9941","5b8ReHI05G8p3wJ69uOHMm@f9941","afPzkQ8whKM6nWaaMqxXi2@f9941","42bT+289dIb4FJdnoLRKRk@f9941","7b47VVyPBGmq4/uD8m1UsE@f9941","40r2fkWrlACL5D/ZZmdS/V@f9941","86y+zP3nNCqZ71TLDl60e+@f9941","48ZWGUboBM4LThpvfvfO+O@f9941","6dOGgCIChM5I8b0ml2DIq+@f9941","3eACZ8Yc5FKJC1DDGT1+LG@f9941","03R9qdCQZA9KYUnC3AFUV6@f9941","b6fqq1bupFQ6+ek+0g52H/@f9941","1ax+8WBUBIQ7BGYwuhCJSI@f9941","4cxYRGSYhKMI6Rs4ksj7Aj@f9941","2aesJfX/NLNo7xKGoMajyw@f9941","aa/j/nPB9NLpA6fqotGK5o@f9941","c9CuXH8pZA65s4jpGZXwiw@f9941","f1NZfPz0lJtoKBO5kRO61N@f9941","0b2uAY2IBIx4ZBezL/4kT/@f9941","a4GvC7SjdH5K+yUpY5J9KN@f9941","0bofjbDAhJFrTevcGZZECu@f9941","39ArxV2uxPF7NRIpdcGFit@f9941","cckyzlrWdPvJ4v177ymEPE@f9941","8e4WeUeRBAxZaKItA5iGmi@f9941","849n6Qif9MLKrlHGEhkzFA@f9941","021/fi35VF9b1jei0RfkXC@f9941","2ai/80CPVA85Iym2vtYz1G@f9941","2eL3XpYMtE/6qMYF3WkP9K@f9941","b9T3QjyNJMeoJlbh6xOwM+@f9941","76369jNkxMkZy8AiuQHzfo@f9941","86F2IPNvpE4YRlqkfcRV5U@f9941","a8N+j00xNKFZwqD7zEMIql@f9941","3elX0TJaxJrqBmuduaHInG","3asvlYK/VByKjZhHjzsJTE","afPg2V3oVDvqG+uC0pOJSL","1eXN5jKGJDKZdaFYeNScsl","53Ag/rJelHJ52jaz1oEaUB","9ekt+coBtHxYY6qKffElmM","38UjR91PZMA6MUi3eZ5Qzs","a3rKT7JDRFIas9zVgRpr/P","deQYHSlB1DwKa7+ycjpJh6","72i93eQWpFb5fp79HeY31G","acfttYviBJ1qGwz7tntFht","d4mSZDNUZIHqklhzPvKA9q","38ZRhqAXRBi7xo1ikAp395","df8I9aNXlMjZG8ckXXf1LP","59Nu5Tr21EQ6S91XG2i/Zt","2bwKWWRrFOqY3Y8TUt319k","1brw/JvvpFnIvdrxpFCgMZ","fbJPGhR7xAcoDNMcJUL1pX","7dL+q5EH1C44P8R1XfDiF6","cd75U/0u1Nw6e1qcsIASOo","00qepqBWVLr4nFR/EYQgdd","e4PMIKWrBCN5a8q5r5dW+H","c202MQTgFAzqH+4tmHykB2","84W5Zmi9ZFha+U1TnPQdch","aaYgwKJiZJOo40Yekvr2Kg","3db1XHUNdEfo7n2V/vgeJs","41fIL4TgNCUp1FJUwzzy43@f9941","25boMWpqBDEblmFTkIH/RB","19A1yi2pFEoLLTgpoq79hZ","25S2rGDYVNgKRP1b7txPkk","7aX+Yb0h5CsqiAMYTNaIz8@6c48a","41d+lT/f1Bm7trsbMFUEta@6c48a","d1R8Ik2DtI47dj18a6QSMQ@f9941","c3b2rmhv1PjaHo8nIGsOka@6c48a","07+voNB6hLUrZwYk6d/uVE@6c48a","c1DPOgkz1DGb8qUUPcndLp@f9941","3bO1o7AyVJ8ojiahmZTI5/","29gPGoU6tJZaCW7FPk/O4i@f9941","0eHS8/KEtHYLv1M+pILQ8x","24Yif8X3NEuLnc2J17ZqJT","41Wp6Ics1H7pmtLSFhaCDh","71cEC6Z0JCWIVp1P2Dwik4","88JIo1r+pGkomIqEDJMZIG","20g1ukYUVPvKWKBRznAKo+@6c48a","33awAhQnhLCayOUqZonbPu@6c48a","68u1qgPk9IX6uBqpurvY9+@6c48a","d9mjksidhJQZMNxB0CJvC6@f9941","15+GUcuJxCk4CnRbmHlnJN","2d4Qt1TWJGkpAdtIN0oniD@f9941","f3rSvk16BPQpv9GQ3fSwQ5@f9941","5f6Ifi1mtL45x06vuRdVf9","c55ysi5N1Fubv5Ye1/kSpS","dcF206UmhO2ZRazrhC01Kj","ccmJX071xACa/wcA38dTRa","aaeFoL+JFNWZERNgO/bHsy","b1n8iSl2xOPK3yjZMfKVcD","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@2e76e","1cTdFSKTNAk6FLk2v+Zbqi","8crjHueFNLgb5pv0rY2nga","12f6FCpwdEHYbEFyYfMkYJ","6epvLpWCFJ4YEIqe+9ymCW","360Cj1jaROVbRxavrFIBqo","2eX//QZA5J8ooPcAsAzIl5","b0bTJrRzFBZ5g1W49k3XmJ","acnQgIgMNBlLYwtPs5drLV","1aJ3ZsHAFObo4Q2tFL+Ni3","b3ARyZ6yRHio/Dcg/Q18pd","e3rnxh6k5FRKOgxWkDWhQL","64sE/uD19G9InKYs/cFu2C","42eMQJGYFAkqh6as68fo4K","3ahe/aES5Cmb0/QAG2tM9a","54TknWPwVPqJqeCR+Y/Czo@6c48a","dcwhJ5fYJKgY36uxAUmiuX","b12yvAVI1HvZvDSQxeZXcV","7baPnRm7dJ7rUBDF4tW5wt@f9941","1dreLRmrtLqbQfykic2/7G@f9941","28PiJ/BE9DjpnLn6or+m9e@f9941","44UZpyYsZMkYW2lwuRelQD@f9941","8eOOVgZs5IO5LoSqZaD3rq@f9941","70lbzuVdBEEbw3xvi+o1i3","86pTS717xCz7uKD/M5ROto","81ukV5bSxAvau6F9Vfnsny","59Gxskd4VLZ7c2iAI9qgPW","f8AqD3IOpDBpepTxKH3JLl","3cO8cKE59BgpHoAlq15FYr","95EkngnxZFbYuFpsqVTaFr@6c48a","2chDWTbz1N46IJ+5Xu4q5m","c6Ec6eleNCcbxp1YkL+Cos@6c48a","33awAhQnhLCayOUqZonbPu@f9941","d1R8Ik2DtI47dj18a6QSMQ@6c48a","84yEUwItJA7bo6gulgPFg5@f9941","bbAaQp5nxAcpf2WOIYbHad@f9941","4d+zHJpvNKgYJ9CThZHwtc","f6KZujHc9LYLIDycUYomps@6c48a"],["node","target","source","targetInfo","_spriteFrame","_parent","value","to","from","root","clip","_font","asset","_target","_normalSprite","_targetSprite","_effectAsset","mainTexture","_particleSystem","_mainTexture","graph","data","_anyState","_exitState","_entryState","commonLabel","prefabRootNode","_key","_anim","_defaultClip","_hoverSprite","_pressedSprite","_disabledSprite","_textureSource","_mesh","_material","_label","icon","mask","outline","outterTexture","_fill","cameraController","scene","_display","_xpDisplay","animHelper","_sprite","_tweenHide","_tweenShow","_joystickBG","_pivot","_contentOpacity","_spriteRenderer","_outline","_icon"],[["cc.Widget",["_alignFlags","_alignMode","_left","_top","_originalWidth","_bottom","_right","_originalHeight","_verticalCenter","_horizontalCenter","_isAbsRight","node","__prefab","_target"],-8,1,4,1],["cc.Node",["_name","_layer","_active","_id","_objFlags","__editorExtras__","_components","_prefab","_parent","_lpos","_children","_lscale","_lrot","_euler"],-3,9,4,1,5,2,5,5,5],["cc.Label",["_string","_actualFontSize","_isSystemFontUsed","_fontSize","_lineHeight","_enableWrapText","_overflow","_horizontalAlign","_verticalAlign","_cacheMode","node","__prefab","_color","_font"],-7,1,4,5,6],["cc.Sprite",["_sizeMode","_type","_isTrimmedMode","_fillRange","_fillType","_fillStart","_enabled","__prefab","node","_color","_spriteFrame","_fillCenter"],-4,4,1,5,6,5],["cc.Node",["_name","_layer","_active","_id","_components","_prefab","_parent","_lpos","_children","_lscale","_lrot","_euler"],-1,12,4,1,5,2,5,5,5],["cc.CurveRange",["mode","multiplier","constantMin","constantMax","constant","spline","splineMin","splineMax"],-2,4,4,4],["cc.ShapeModule",["_enable","_shapeType","sphericalDirectionAmount","emitFrom","radius","radiusThickness","_arc","randomDirectionAmount","randomPositionAmount","length","_angle","arcSpeed","_rotation","_scale"],-8,4,5,5],["cc.RealKeyframeValue",["interpolationMode","value","rightTangent","leftTangent","rightTangentWeight","leftTangentWeight"],-3],["cc.Button",["_zoomScale","_transition","_interactable","node","__prefab","_target","_normalSprite","_normalColor","clickEvents","_hoverSprite","_pressedSprite","_disabledSprite"],0,1,4,1,6,5,9,6,6,6],["cc.Layout",["_layoutType","_spacingY","_spacingX","_resizeMode","_enabled","_isAlign","node","__prefab"],-3,1,4],"cc.SpriteFrame",["cc.ParticleSystem",["duration","loop","_aabbHalfX","_aabbHalfY","_aabbHalfZ","_capacity","simulationSpeed","startRotation3D","playOnAwake","_cullingMode","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","bursts"],-7,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9],["cc.GradientRange",["_mode","colorMin","colorMax","color","gradient"],2,5,5,5,4],["cc.animation.AnimationTransition",["duration","exitConditionEnabled","_exitCondition","from","to","conditions"],0,1,1,9],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.Animation",["_enabled","playOnLoad","node","__prefab","_clips","_defaultClip"],1,1,4,3,6],["cc.Node",["_name","_layer","_active","_parent","_components","_prefab","_lscale","_lpos"],0,1,2,4,5,5],["cc.PrefabInfo",["fileId","root","instance","asset","targetOverrides","nestedPrefabInstanceRoots"],2,1,4,6,9,2],["cc.PrefabInstance",["fileId","propertyOverrides","prefabRootNode","mountedComponents"],2,9,1,9],["cc.TargetOverrideInfo",["propertyPath","target","targetInfo","source","sourceInfo"],2,1,4,1,4],["cc.ClickEvent",["_componentId","handler","customEventData","target"],0,1],["f6ce3V3GtZET7YfWjO8OsBV",["slimeEvent","node","_onEventRaised","__prefab"],2,1,9,4],["cc.Burst",["repeatInterval","_time","count"],1,4],["cc.LimitVelocityOvertimeModule",["dampen","_enable","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.Camera",["_orthoHeight","_clearFlags","_visibility","_priority","_far","_projection","_fov","node","_color","__prefab"],-4,1,5,4],["cc.Material",["_states","_defines","_techIdx","_props"],0,12],["cc.Node",["_objFlags","__editorExtras__","_name","_prefab","_parent","_children","_components"],0,4,4,9,9],["cc.PrefabInfo",["fileId","root","asset","targetOverrides","nestedPrefabInstanceRoots"],2,1,1,9,2],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents"],1,9,9],["c83f3h67FpJDoLcaBUEDjiF",["node","__prefab","_onEnable"],3,1,4,9],["7aa59VYt9NOyp9K157gXXfU",["_eventID","node","_onEventRaised","__prefab"],2,1,9,4],["37b85WpHzdBn41+pXJNQa6l",["_debug","node","__prefab","_anim"],2,1,4,1],["85848g+yY1PpKiragtG2vjV",["prefix","node","__prefab","commonLabel"],2,1,4,1],["0fdf23AXTtH7oNr98KwIs5U",["slimeEvent","_delay","node","__prefab","_onEventRaised"],1,1,4,9],["8fe5eZFmPZM4Z7Xz5zo2zyj",["slimeEvent","node","__prefab","_onEventRaised"],2,1,4,9],["eebcbgVMDVBQpDUMV9BhlVs",["eventID","node","__prefab"],2,1,4],["cc.animation.AnimationController",["node","__prefab","graph"],3,1,4,6],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.SizeOvertimeModule",["_enable","separateAxes","size","x","y","z"],1,4,4,4,4],["cc.VelocityOvertimeModule",["_enable","x","y","z","speedModifier"],2,4,4,4,4],["cc.TrailModule",["_minParticleDistance","lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],2,4,4,4,4,1],["cc.Gradient",["alphaKeys","colorKeys"],3,9,9],["cc.Mask",["_type","_alphaThreshold","node","__prefab","_spriteFrame"],1,1,4,6],["cc.animation.UnaryCondition",["operator","operand"],2,4],["cc.animation.Transition",["from","to","conditions"],3,1,1,9],["cc.animation.ClipMotion",["clip"],3,6],["cc.BoxCollider",["_isTrigger","node","_material","_size"],2,1,6,5],["Range",["max","min"],1],["AnimationHelperVariable",["animParamType","animParam","paramValue"],0],["1eddcq+dFJL6Kd35j8xBAOw",["duration","useCustomStartValue","valueStart","valueEnd","node","__prefab","target"],-1,1,4,1],["cc.Material",["_props","_defines"],1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Prefab",["_name"],2],["cc.PrefabInfo",["fileId","targetOverrides","root","instance","asset"],1,1,4,6],["cc.PrefabInfo",["fileId","targetOverrides","root","asset"],1,1,1],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,12],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,2],["cc.TargetInfo",["localID"],2],["cc.CompPrefabInfo",["fileId"],2],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["cc.Canvas",["node","__prefab"],3,1,4],["896c2R0RLpPWIAkTx4TPKFx",["node","__prefab"],3,1,4],["cc.EffectAsset",["_name","shaders","techniques"],0],["f2ed5XTz8pLGIjSL7eB/6zo",["_transition","_zoomScale","node","__prefab","clickEvents","_target","_onPressed","_onReleased"],1,1,4,9,1,9,9],["3025b6pDuJDCY6PclIuTKbW",["eventType","node","__prefab"],2,1,4],["cc.UIOpacity",["node","__prefab"],3,1,4],["bcfc10R9vBPuahWOcItGMB5",["node","__prefab","_disable"],3,1,4,9],["cc.LabelOutline",["_width","node","__prefab"],2,1,4],["ac879rTendCEbpZWFz/jexs",["node","__prefab","_key"],3,1,4,6],["cc.ParticleSystem",["startRotation3D","duration","loop","_aabbHalfX","_aabbHalfY","_aabbHalfZ","_capacity","_materials","node","__prefab","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],-5,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.ParticleSystem",["duration","loop","simulationSpeed","playOnAwake","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],-1,1,4,3,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.RotationOvertimeModule",["x","y","z"],3,4,4,4],["cc.TextureAnimationModule",["frameOverTime","startFrame"],3,4,4],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["cc.ColorKey",["time"],2],["cc.AlphaKey",["alpha","time"],1],["cc.PhysicsMaterial",["_friction","_restitution"],1],["f964aRkVl1H94vry3UKRWOf",["eventID","node","__prefab"],2,1,4],["33fbfvcKCVKi5q8DCetaVL+",["node","__prefab"],3,1,4],["c220ezwrChLSYwuQOQF0brq",["node","__prefab"],3,1,4],["cc.BlockInputEvents",["node","__prefab"],3,1,4],["ee672Nx9tRB+7fZZHkbEdII",["eventType","node","__prefab"],2,1,4],["6107bBCvtJHpbyrosM9DUC0",["node","__prefab","_label"],3,1,4,1],["fba3f+FZw9DFaNAZYiJHxY0",["node","__prefab","_label","_onCoinsAdded"],3,1,4,1,9],["04753kODZ1COq8ujU5QwPzS",["_modelID","node","__prefab","_skinStates"],2,1,4,9],["SkinModelStateEntry",["stateID","onSetState"],2,9],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["f33f2pN0eBOx5QZe9NdXyzc",["node","__prefab","_label","_fill"],3,1,4,1,1],["81ae3BBkvtAZ4T+cbJ1WRAa",["node","__prefab","_label"],3,1,4,1],["85d1aSv1CpM1q1iP4fDFUa4",["node","__prefab","_setStoreItemCost","_setSkinName","_setStoreState","_skinPurchased","_skinChanged"],3,1,4,9,9,9,9,9],["9ed1aO88vFKYaSxKYGFNCSE",["node","__prefab","_targetColor","_targetSprite"],3,1,4,8,1],["d9040g5wUZNv41Fw6BiBXaR",["node","__prefab"],3,1,4],["58152N3IOJILLu+bx3ThyjT",["_readyCount","node","__prefab","_onReady"],2,1,4,9],["c19c6UdX31OlI3xN6kAGLZx",["node","__prefab","_showTutorial","_hideTutorial"],3,1,4,9,9],["bc4c8bzRddCFJ5qn4hnBJEo",["node","__prefab","_onChangedWorld"],3,1,4,9],["b42e4itkiNL2Jk75XfG9uYR",["_missionEntries","node","__prefab"],2,1,4],["410e2HhWdBJvqVVRBYZrqQz",["node","__prefab","onStart"],3,1,4,9],["68319PdaTpA66+DyVsaDsQC",["_eventID","node","__prefab","_actions"],2,1,4,9],["1a8ceQmz21HmZ2niBT6Vuz5",["eventID","node","__prefab","_onEventRaised"],2,1,4,9],["cc.animation.AnimationGraph",["_layers","_variables"],3,9,11],["cc.animation.Layer",["_stateMachine"],3,4],["cc.animation.StateMachine",["_states","_transitions","_entryState","_exitState","_anyState"],3,2,9,1,1,1],["cc.animation.BindableBoolean",["variable"],2],["cc.animation.TriggerCondition",["trigger"],2],["cc.animation.Variable",["_type","_value"],1],["cc.animation.Motion",["name","motion","speed"],2,4,4],["cc.animation.BindableNumber",["value"],2],["cc.animation.State",["name"],2],["61531xMjfdJtLGPUfndQAv7",["node","__prefab"],3,1,4],["2c4e8xIPOZENLhcYAIWTYzQ",["node","__prefab"],3,1,4],["cc.SceneAsset",["_name"],2],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR"],2,5,5],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["cc.MeshRenderer",["_name","_enabled","node","_materials","lightmapSettings","_mesh"],1,1,3,4,6],["cc.ModelLightmapSettings",[],3],["cc.RigidBody",["_type","node"],2,1],["cc.PlaneCollider",["node","_material"],3,1,6],["ca69bTqdzBPx5RtY5ix/2uU",["zoomSpeed","node","cameraController","minOffset","maxOffset"],2,1,1,5,5],["dc5a4s/i7VEl7L/oMyoeK+/",["sceneName","node"],2,1],["3fe40hRLidOXpQ2NiARuPUM",["node"],3,1],["4dd9bj5xJNEaYc3HTlp4ysk",["_laziness","node","offset","startRotation","camera"],2,1,5,5,1],["23770vxPW5OaYNYthIrYRdX",["node"],3,1],["edb90tp43BI+7plsCPZ1UX4",["spawnInterval","node","_maxActiveFoodsRange","spawnArea"],2,1,4,1],["8242eQsTn1Gu72i9gG/84wj",["_slimes","node"],2,1],["b738dqUDJdPWLI7QYjSEYUQ",["node"],3,1],["33369SADQZAtZ5huWbGrtji",["node","_safeAreaMaterials"],3,1,3],["2a10cQdtFNL4LcqGldPgnch",[],3],["8cdbfq4449OuqPuEFk7/wfs",[],3],["cc.TTFFont",["_name","_native"],1],["7ce902c+8ZP7ZMly+mPaf7O",["_resetMissions","node","__prefab"],2,1,4],["d93caQZgFhHt5kPg5dJIWQ5",["_shrinkTime","node","__prefab","_radiusRange","_shrinkCurve"],2,1,4,4,4],["04734e5Zp1KiYseHUCwDl6y",["node","__prefab","_display"],3,1,4,1],["d2017D/nqBC24w++1MXcPXY",["_eventKey","node","__prefab"],2,1,4],["53d3fTbnFxPOLwJ9KE2Kruy",["node","__prefab","_animationEvents"],3,1,4,9],["Data",["_key","_actions"],2,9],["23f03FqfFxDSb54Zss+W8dO",["node","__prefab","commonLabel"],3,1,4,1],["8620aiyaVVH5aUIHiS4nbuh",["node","__prefab","_buttonNode"],3,1,4,1],["db96fWrL6JHS4amhC++y5aI",["node","__prefab","_setPlayerBestScore","_setFoodsEaten","_setSlimesEaten","_setBestPosition"],3,1,4,9,9,9,9],["f9fe013MwFNZb49dpCxXP29",["_updateCoinsTrigger","node","__prefab","_label","_animator"],2,1,4,1,1],["abbc67cNQxDuJ3vQ9bKAb0F",["node","__prefab","_levelLabel","_totalCoinsDisplay","_coinsDisplayToast","_animator"],3,1,4,1,1,1,1],["b2e8cJmV2lHfLO8Dt8AHway",["node","__prefab","_xpLabel","_xpFill"],3,1,4,1,1],["85c5d2mBTNAjKx4dLl8Y+bc",["_adAnimationParamater","node","__prefab","_animator","_setMissionName","_setProgress","_setRewardQuantity"],2,1,4,4,9,9,9],["DailyMissionEntryUIAnimation",["animHelper","data"],3,1,9],["DailyMissionAnimationHelperVariable",["missionState","variables"],2,9],["3b28eOkVQtF/507hbMwzYxn",["node","__prefab","_sprite","_currentValue","_targetValue"],3,1,4,1,9,9],["09e1dLFgZhCrL2KX2024O5A",["node","__prefab","_contentOpacity","_pivot","_joystickBG","_tweenShow","_tweenHide"],3,1,4,1,1,1,1,1],["3ca0eUR64hHCIpL0fRF8hQx",["node","__prefab"],3,1,4],["cbdbcNUMMpM2Zn1GdDAXSDN",["_textureID","node","__prefab","_skinStates","_spriteRenderer","_iconTextures"],2,1,4,9,1,3],["SkinTextureStateEntry",["stateID","onSetState"],2,9],["45507+V7B5O9qT4vi73sOer",["node","__prefab","_sprites","_icon","_mask","_outline"],3,1,4,9,1,1,1],["TextureSprites",["id","icon","mask","outline"],2,6,6,6]],[[58,0,2],[59,0,2],[19,0,3,4,1,2,2],[27,0,1,2,2],[5,1],[14,0,1,2,1],[20,0,1,3,3],[60,0,1,2,3],[14,0,1,1],[5,4,2],[80,0,1,2],[7,0,1,2,3,5],[61,0,1,2,2],[63,0,1,2,2],[62,0,1,2,3],[7,0,1,3],[1,0,1,8,6,7,3],[14,0,1,2,3,1],[116,0,1,2,2],[117,0,2],[1,0,1,8,10,6,7,3],[45,0,1],[1,0,1,8,10,6,7,9,3],[64,0,1,2,2],[13,0,1,3,4,5,3],[5,0,2,3,4],[118,0,2],[20,0,1,2,3,4],[115,0,1,3],[3,1,0,8,7,9,10,3],[17,0,1,2,3,2],[3,0,8,7,9,10,2],[1,0,1,8,6,7,9,3],[12,1],[5,0,5,2],[114,0,2],[7,0,2,3,4],[29,0,1,1],[18,0,2,1,2],[1,4,5,7,3],[0,0,2,6,3,5,4,7,11,12,8],[101,0,1,2,3,1],[7,0,2,4,3,5,6],[1,0,1,6,7,3],[4,0,1,6,4,5,7,3],[96,0,1,2],[113,0,2],[5,0,6,7,2],[1,0,1,10,6,7,9,3],[0,0,4,7,11,12,4],[81,0,1,2,1],[82,0,1,2,1],[83,0,1,1],[84,0,1],[52,0,2],[1,4,5,8,7,3],[15,0,2,3,4,2],[74,0,1,1],[110,0,1,1],[111,0,1],[112,0,1,2,3,4,1],[1,0,1,10,6,7,3],[1,0,2,1,8,10,6,7,9,4],[36,0,1,1],[37,1,1],[44,0,1,1],[0,0,11,12,2],[19,0,1,2,2],[22,2,1],[38,0,2,3,4,5,2],[40,1,2,3,4,5,1],[86,0,1,3],[43,1,1],[0,0,3,1,11,12,4],[3,0,8,7,10,2],[3,8,7,10,1],[31,1,2,3,1],[77,0,1,2,1],[12,0,1,2,2],[5,0,1,5,3],[13,0,3,4,2],[25,0,1,3,3],[4,0,1,8,4,5,7,3],[0,0,5,1,11,12,4],[3,0,2,8,7,9,10,3],[15,1,2,3,4,5,2],[32,1,2,3,1],[12,3,1],[22,1,2,2],[39,1,2,3,4,1],[1,0,1,8,6,7,9,11,3],[16,0,2,1,3,4,5,6,4],[0,0,4,1,11,12,4],[3,8,7,9,10,1],[2,0,1,3,4,2,10,11,12,13,6],[33,0,2,3,4,2],[7,0,2],[25,2,0,1,3,4],[4,0,1,6,4,5,3],[65,0,1,2,2],[3,1,0,8,7,9,3],[5,0,2,3,1,5],[5,1,2],[23,2,3,4,5,1],[43,0,1,2],[164,0,1,2],[1,0,8,6,2],[19,0,3,1,2,2],[8,1,0,3,4,8,5,6,3],[8,1,0,3,4,8,7,5,6,9,10,11,3],[2,0,1,3,4,6,5,2,10,11,12,8],[34,0,1,2,3,2],[12,0,4,2],[5,0,2],[39,0,1,2,3,4,2],[23,0,2,3,4,5,2],[129,0,1,2,3,4,5,3],[130,1],[1,0,1,6,7,9,3],[1,0,2],[1,0,8,6,9,11,2],[4,0,2,1,8,4,5,7,4],[4,0,1,6,4,5,7,9,3],[18,0,2,3,1,2],[18,0,1,2],[0,0,4,11,12,3],[0,0,3,11,12,3],[0,0,2,6,3,4,11,12,6],[0,0,2,6,3,5,4,7,1,11,12,9],[69,0,1,1],[70,0,1,1],[20,0,1,3],[21,0,1,3,2,2],[2,0,1,3,4,6,5,2,10,11,12,13,8],[11,0,1,6,8,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,36,26,27,28,29,30,31,32,33,34,35,5],[85,0,2],[95,0,1,2,3,2],[46,1,2,1],[48,0,1,2,4],[166,0,1,2,3,2],[1,0,1,8,10,6,7,9,11,3],[1,0,8,6,7,2],[1,0,2,1,6,7,9,11,4],[4,0,1,6,8,4,5,3],[4,0,1,4,5,7,3],[0,0,8,11,12,13,3],[0,0,2,6,4,11,12,5],[0,0,2,6,3,5,9,4,7,11,12,9],[0,0,3,5,8,1,11,12,6],[3,1,0,8,7,10,3],[8,1,0,3,4,8,7,5,6,3],[2,0,1,3,2,10,11,12,13,5],[71,0,1,2,4],[5,0,1,6,7,3],[38,0,1,2,3,4,5,3],[7,0,1,4,5,5],[7,0,4,5,4],[40,0,1,2,3,4,5,2],[41,0,1],[9,0,2,6,7,3],[159,0,1,2],[51,0,1,2,3],[1,0,2,1,10,6,7,9,4],[1,0,2,1,8,6,7,4],[1,0,2,1,8,10,6,7,4],[1,0,1,8,6,7,9,12,13,3],[1,0,2,1,8,6,7,9,4],[1,0,10,7,2],[1,0,3,8,10,3],[1,0,8,10,2],[1,0,8,7,2],[4,0,1,8,4,5,3],[4,0,6,4,5,2],[17,0,1,2,4,3,2],[27,0,1,2,3,4,2],[28,0,1,2,3],[55,0,1,1],[56,0,1,1],[57,0,1,1],[0,0,2,5,11,12,4],[0,0,4,7,1,11,12,5],[0,0,5,11,12,3],[0,0,3,5,7,1,11,12,6],[0,0,2,6,3,5,4,7,1,11,12,13,9],[0,0,2,4,7,11,12,5],[0,0,2,6,3,9,8,4,1,11,12,9],[0,0,2,11,12,3],[0,0,6,11,12,3],[29,0,1,2,1],[67,0,1,2,2],[14,0,1,3,1],[30,0,1,3,2,2],[3,1,4,0,5,3,8,7,9,11,10,6],[3,1,0,3,8,7,9,4],[3,0,2,8,7,3],[2,0,1,3,4,6,5,2,9,10,11,12,9],[2,0,1,3,6,5,2,10,11,7],[2,0,7,1,3,4,2,10,11,12,13,7],[2,0,7,1,3,4,6,5,2,10,11,12,9],[2,0,7,8,1,3,4,5,2,10,11,12,9],[15,2,3,4,1],[31,0,1,2,2],[75,0,1,2,1],[76,0,1,2,2],[32,0,1,2,3,2],[36,0,1,2,1],[78,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,9],[11,0,1,6,9,2,3,4,5,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,36,26,27,28,29,30,31,32,33,34,35,9],[11,7,0,1,2,3,4,5,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,36,26,27,28,29,30,31,32,33,34,35,8],[5,4,1,3],[22,0,2,2],[37,0,1,2],[6,0,1,3,2,4,5,11,7],[6,0,1,3,4,5,11,6],[6,0,1,3,7,2,8,5,6,11,12,9],[6,0,1,2,4,9,10,11,13,7],[23,1,0,2,3,4,5,3],[41,1,0,1],[91,0,1,1],[94,0,1,2,3,1],[9,4,3,0,2,6,7,5],[9,3,0,2,6,7,4],[97,0,1,1],[13,0,3,4,5,2],[45,1],[144,0,1,3],[162,0,1,1],[50,0,1,3],[1,0,4,1,8,6,7,9,4],[1,0,2,1,6,7,4],[1,0,1,8,6,7,11,3],[1,0,3,8,10,6,11,3],[1,0,6,2],[1,0,10,2],[1,0,1,3,8,6,9,4],[1,0,3,8,6,9,3],[1,0,3,8,6,3],[1,0,10,6,7,9,2],[1,0,2,1,6,7,9,4],[4,0,2,1,6,8,4,5,7,4],[4,0,1,6,8,4,5,7,9,3],[4,0,3,6,4,7,10,11,3],[4,0,2,1,6,8,4,5,4],[4,0,6,8,4,5,2],[4,0,2,1,4,5,7,4],[16,0,1,3,4,5,3],[16,0,1,3,4,7,3],[26,0,1,4,3,3],[26,2,5,6,3,2],[17,0,4,5,2],[53,0,1,2,3,4,3],[54,0,1,2,3,3],[28,0,1,3,2,3],[0,0,1,11,12,3],[0,0,2,5,1,11,12,5],[0,0,2,6,5,1,11,12,6],[0,0,2,6,5,11,12,5],[0,0,6,3,1,11,12,5],[0,0,2,6,3,4,1,11,12,7],[0,0,2,6,3,5,9,7,11,12,8],[0,0,2,6,3,10,4,1,11,12,8],[0,0,6,3,5,4,7,11,12,7],[0,0,3,1,11,12,13,4],[0,0,5,1,11,12,13,4],[0,0,2,1,11,12,4],[0,0,3,4,1,11,12,5],[0,0,2,8,11,12,4],[0,0,9,11,12,3],[0,0,8,11,12,3],[66,0,1,2,2],[68,0,1,2,2],[30,0,1,2,2],[21,0,1,2,2],[21,1,3,2,1],[3,6,0,8,7,9,10,3],[3,0,2,7,9,3],[3,0,2,8,7,9,3],[3,0,8,7,2],[3,8,7,9,1],[8,1,0,3,4,7,5,6,9,10,11,3],[8,2,1,0,3,4,8,7,5,6,4],[8,0,3,4,8,7,5,6,2],[2,0,1,3,4,6,2,10,11,12,13,7],[2,0,1,3,4,2,10,11,12,6],[2,0,1,3,6,5,2,10,11,13,7],[2,0,1,3,6,5,2,10,11,12,7],[2,0,1,3,4,5,2,10,11,13,7],[2,0,7,1,3,4,5,2,10,11,12,8],[2,0,7,1,6,5,2,10,11,12,7],[2,0,1,3,4,5,2,10,11,12,13,7],[2,0,8,1,3,4,6,5,2,10,11,12,9],[72,0,1,2,3,4,5,6,7,3],[15,0,1,2,3,4,3],[73,0,1,2,2],[33,1,0,2,3,4,3],[34,1,2,3,1],[35,1,2,1],[35,0,1,2,2],[11,7,0,2,3,4,5,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,7],[11,0,1,8,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,36,26,27,28,29,30,31,32,33,34,35,4],[79,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,5],[12,0,1,2],[6,0,1,3,7,2,8,4,5,6,11,12,10],[6,0,1,3,7,2,6,11,12,7],[6,0,1,3,2,8,6,11,7],[6,0,1,3,2,4,11,6],[6,0,1,2,4,9,10,11,7],[7,0,1,2,4,3,5,7],[87,0,1,3],[88,0,1,2,2],[89,0,1,1],[90,0,1,1],[92,0,1,2,2],[93,0,1,2,1],[9,4,0,1,6,7,4],[9,0,1,6,7,3],[9,3,0,1,5,6,7,5],[98,0,1,2,3,1],[42,0,1,2,3,4,3],[42,0,2,3,4,2],[99,0,1,2,1],[100,0,1,2,3,4,5,6,1],[102,0,1,1],[103,0,1,2,3,2],[104,0,1,2,3,1],[105,0,1,2,1],[106,0,1,2,2],[107,0,1,2,1],[108,0,1,2,3,2],[109,0,1,2,3,2],[24,3,0,4,1,2,7,9,8,6],[24,5,3,0,4,1,2,7,8,7],[24,6,0,1,2,7,5],[13,0,1,3,4,3],[13,0,1,2,3,4,5,4],[44,0,1,2,1],[119,0,1,1],[120,0,1,1],[121,0,2],[122,0,1,2,3,2],[123,0,1,2,3,4,1],[124,0,1,2,2],[125,0,1],[126,1],[127,1],[128,1],[131,0,1,2],[132,0,1,1],[133,0,1,2,3,4,2],[134,0,1,2],[135,0,1],[46,0,1,3,2],[136,0,1,2,3,4,2],[137,0,1],[138,0,1,2,3,2],[47,1,0,3],[47,0,2],[139,0,1,2],[140,0,1],[141,0,1,1],[142,1],[143,1],[145,0,1,2,2],[146,0,1,2,3,4,2],[147,0,1,2,1],[148,0,1,2,2],[149,0,1,2,1],[150,0,1,2],[151,0,1,2,1],[152,0,1,2,1],[153,0,1,2,3,4,5,1],[154,0,1,2,3,4,2],[155,0,1,2,3,4,5,1],[156,0,1,2,3,1],[157,0,1,2,3,4,5,6,2],[158,0,1,1],[48,0,1,3],[160,0,1,2,3,4,1],[161,0,1,2,3,4,5,6,1],[49,0,1,4,5,6,3],[49,0,1,2,3,4,5,6,5],[163,0,1,2,3,4,5,2],[165,0,1,2,3,4,5,1]],[[[[97,"0",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4286545791],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[137,11]],[[[161,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[161,".bin",3434579268,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[[54,"P-Joystick-Canvas"],[39,0,null,[30,"42eXoQaSpLhpUcJXK7t987",-13,[123,"a7asuXfZxLKYqyU4YzovgD",-12,[[176,[0,["42eXoQaSpLhpUcJXK7t987"]],[[83,20,50,0,-10,[1,"6fhbjTUmRLfZaACWWHv552"]],[37,-11,[1,"d8LjvDOGNCr4lEtCfdVmxE"]]]]],[[7,"VirtualJoystick",["_name"],-1],[12,["_lpos"],-2,[1,0,-334,0]],[12,["_lrot"],-3,[3,0,0,0,1]],[12,["_euler"],-4,[1,0,0,0]],[7,0,["style"],-5],[7,false,["_active"],-6],[7,0,["_timeToReposition"],-7],[7,10,["_minMovementDistance"],-8],[7,0.01,["_minMovementScreenHeightRatio"],-9]]],0]],[48,"P-Joystick-Canvas",33554432,[1,-19],[[5,-15,[1,"9eCsziOzxEn5Tlc/T46co9"],[5,414,896]],[129,-16,[1,"d16IlCaodNtK8FPXCBiz5n"]],[66,45,-17,[1,"01YwqFCKlLP5gaZCeQEJ+A"]],[130,-18,[1,"c3+JXpp4xGob7yh5P0jqbs"]]],[174,"66h8u49P5OCLios+1KOjSE",-14,0,[[2,["contentOpacity"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["47B7CdLgJKsoeGjd7pw7eC"]]],[2,["pivot"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["36eZrS80hBy4UjhY7Yjyzk"]]],[2,["tweenShow"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["31hEm0catFwZfOtf5zXnFq"]]],[2,["tweenHide"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["486diRHOBMNpDwYZcx/+uU"]]],[2,["joystickBG"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["50Ujxr/aNFMatRB+3sT/Nf"]]],[2,["_contentOpacity"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["47B7CdLgJKsoeGjd7pw7eC"]]],[2,["_pivot"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["36eZrS80hBy4UjhY7Yjyzk"]]],[2,["_joystickBG"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["50Ujxr/aNFMatRB+3sT/Nf"]]],[2,["_tweenShow"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["31hEm0catFwZfOtf5zXnFq"]]],[2,["_tweenHide"],1,[0,["ebgbn3fThK4JifW7C4wLtr"]],1,[0,["486diRHOBMNpDwYZcx/+uU"]]]],[1]],[1,207,448,0]],[0,["42eXoQaSpLhpUcJXK7t987"]],[0,["ebgbn3fThK4JifW7C4wLtr"]],[61,"Game",33554432,[-21,-22],[[8,-20,[1,"32lkjd0P1An52JPkUKkTXj"]]],[3,"9aL9Psf6lNyL0g4OY70JjW",2,0]],[20,"Event Listeners",33554432,2,[5],[[8,-23,[1,"8fRIRyG9pJl4MAtPS4Xlcf"]]],[3,"4dTIpIIlZN/qsuEZoBbfNJ",2,0]],[16,"Started",33554432,5,[[8,-24,[1,"9emgyLW0NNX7U8hbQ7p6Te"]],[191,"menu-start-clicked",-25,[1,"09tpuEcuhE6KY5dwJiCzaP"],[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",1]]]],[3,"97x0g2LhtDlr1662mcidsq",2,0]],[16,"Finished",33554432,5,[[8,-26,[1,"bfXFFmOvhKR6PEi9BsF/UR"]],[132,4,-27,[1,"59Dgm/NslFa4Ihb6gjeVaD"],[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",1]]]],[3,"2aqYwmBYFP1ZcFZcMyGjJ4",2,0]]],0,[0,3,3,0,3,3,0,3,3,0,3,3,0,3,4,0,3,3,0,3,4,0,3,4,0,3,4,0,0,1,0,0,1,0,26,2,0,9,1,0,9,2,0,0,2,0,0,2,0,0,2,0,0,2,0,-2,6,0,0,5,0,-1,7,0,-2,8,0,0,6,0,0,7,0,0,7,0,0,8,0,0,8,0,21,2,1,5,2,5,5,6,27],[0],[12],[46]],[[[54,"Button_Guide"],[48,"Button_Guide",33554432,[-6],[[5,-2,[1,"ceCrDMg7NIVoykeDj/ZoyF"],[5,28,28]],[29,1,0,-3,[1,"7fEUqCmn1HgrtbVECcgMG5"],[4,4292667899],1],[279,3,0.9,-5,[1,"07THi0b/RF+bnhyo6JcCi5"],[4,4292269782],-4,2,3,4,5]],[3,"8aX5hxXqBFKawcGo9z8a0S",-1,0],[1,0,-32.869,0]],[228,"Text_Label",512,33554432,1,[[5,-7,[1,"30q8PZnWhDfoTlu7rgYBm+"],[5,20,20]],[133,"?",24,24,24,1,false,false,-8,[1,"4f1H9GRsNPpaDhKHNDz3SJ"],[4,4278274710],0]],[3,"b47tw9yY9D5rLD9xTZUcUV",1,0],[1,1.18,1.18,0]]],0,[0,9,1,0,0,1,0,0,1,0,13,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,21,1,8],[0,0,0,0,0,0],[11,4,14,30,31,32],[0,7,7,12,13,14]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,2,2,0,0],"outterColor",8,[4,4290361855],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[138,10]],[[[152,"builtin-standard",[{"hash":2864919663,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor3","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":4,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_screenSize.x / float(16));\n    float clusterSizeY = ceil(cc_screenSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_screenSize.x / float(16));\n    float clusterSizeY = ceil(cc_screenSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_ENABLE_DIR_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_screenSize.x / float(16));\n    float clusterSizeY = ceil(cc_screenSize.y / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(s.position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(s.position, s.roughness);\n    gl_FragData[2] = vec4(s.normal, s.metallic);\n    gl_FragData[3] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":221,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":64}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_ENABLE_DIR_SHADOW","type":"boolean","defines":["CC_RECEIVE_SHADOW"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":1774012115,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":182,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":64}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[54,"P-Game-Canvas"],[48,"P-Game-Canvas",33554432,[-7,-8,-9],[[5,-2,[1,"29agudV6VAlonVQKGfoDTH"],[5,414,896]],[129,-3,[1,"e1MFG2Jx9ER6XwecCdfeDA"]],[253,45,1,-4,[1,"aamgu33UhJypdr3a61Th7n"]],[37,-5,[1,"92G0MsARhNt5wN/Ys4XLqL"]],[130,-6,[1,"12AQRlJXNJVbMT/Et3I5Xn"]]],[3,"75Fsxflk5LJIE6aYq2/I7H",-1,0],[1,207,448,0]],[121,"Button_Ability 01",false,33554432,[-24,-25,-26,-27,-28],[[[254,12,26,30,1,-10,[1,"f6772Au3hCfYhJWbUiSXli"]],[5,-11,[1,"dd/cy29rhMDYVM4CrMYp6l"],[5,104,92]],[291,3,0.95,-18,[1,"f8MfUHnuhExb09LCeIpZmt"],[[27,"37b85WpHzdBn41+pXJNQa6l","setBool","enabled,false",-17]],-16,[[6,"eebcbgVMDVBQpDUMV9BhlVs","raise",-14],[27,"37b85WpHzdBn41+pXJNQa6l","setBool","inUse,true",-15]],[[6,"eebcbgVMDVBQpDUMV9BhlVs","raise",-12],[27,"37b85WpHzdBn41+pXJNQa6l","setBool","inUse,false",-13]]],[56,false,-19,[1,"9bQLd0y/dEQbENRfsuYzoQ"],[30,31,32,33,34]],[37,-20,[1,"a8nwsnVtlFiJJTOp9GfHqk"]],-21,[76,-23,[1,"58BNSUQcZBZLgrizDNub9R"],-22]],4,4,4,4,4,1,4],[3,"b5Iysdo9ZAgbGLXKerpPug",1,0],[1,-129,76,0]],[121,"Button_Ability 02",false,33554432,[-40,-41,-42,-43],[[[255,36,30,26,30,1,-29,[1,"96pTOOd1dNQoJBKqOIwzok"]],[5,-30,[1,"69kOvpvVBA3beZ1fTA4jJI"],[5,104,92]],[108,3,0.95,-33,[1,"a5AS6SGSVE9b8QJPy/b73F"],[[6,"3025b6pDuJDCY6PclIuTKbW","raise",-32]],-31,44],[37,-34,[1,"2c4DkbuL9LiacGvV6SA2Sh"]],[56,false,-35,[1,"99yXVxb6ZLprDKfrfVtDye"],[45,46,47,48,49,50]],-36,[76,-38,[1,"a0dkcoCD9Cr74Zl17gcmtZ"],-37],[293,5,-39,[1,"e6oGTr449DmIseaaPsKwJ3"]]],4,4,4,4,4,1,4,4],[3,"b6nEpKtwBDK71WPOPBrKy7",1,0],[1,129,76,0]],[121,"Holder_Info Panel 01",false,33554432,[-51,-52,-53],[[[190,-44,[1,"f1ChsRrGtONYfjBaSqUIEq"],[0,0.5,0]],[179,12,28,125,-45,[1,"f6772Au3hCfYhJWbUiSXli"]],[56,false,-46,[1,"02/3p4u1JIU7gmUb+LFD6e"],[27,28,29]],-47,[37,-48,[1,"2bjsU3+0FAtbGnkDc8S2gY"]],[76,-50,[1,"2bBlIS08ZIvK2tJCVu+pTF"],-49]],4,4,4,1,4,4],[3,"a5A8iRjy1HmbpewxTFZFAe",1,0],[1,-129,125,0]],[162,"Holder_Dash Unlock Panel",false,33554432,[-62],[[5,-54,[1,"8158WCPdJEu6z8fNI8PI2r"],[5,100,50]],[73,1,160,1,-55,[1,"6eISNSl15Jk4xxrKoyvOFB"]],[85,true,-56,[1,"94TgcFfhhDjJCtJrLNsqnk"],[6],7],[57,-57,[1,"3de5SXWcBHsrFFx4Ft6tYV"]],[188,-59,[1,"23n7aNMJBN8Js50mAMMdrB"],[[27,"cc.Animation","play","Ability Annoucement_Intro&Exit",-58]]],[202,-61,[1,"0eio/WD7tH3pZOsWoEdasA"],[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-60]]]],[3,"13vHJ+CrBCt7WOiZvPX14o",1,0],[1,0,-185,0]],[162,"Holder_Divide Unlock Panel",false,33554432,[-71],[[5,-63,[1,"60uTWYgAFFk7ft36G3m2oq"],[5,100,50]],[73,1,160,1,-64,[1,"5c8OBvuo1Fq4qzsJ4I7LhR"]],[85,true,-65,[1,"35lF1c7fBPp5iEALyelo4J"],[11],12],[57,-66,[1,"b0+UVcV65FqaA8r24VOh4R"]],[188,-68,[1,"03AUvJxwdDiqPuECf0BSC+"],[[27,"cc.Animation","play","Ability Annoucement_Intro&Exit",-67]]],[202,-70,[1,"8aqXI/JeRAebAoxOXVYYtf"],[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-69]]]],[3,"ffuz/h215OOqgMOlhvtz3A",1,0],[1,0,-185,0]],[121,"Holder_Info Panel 02",false,33554432,[-79,-80],[[[190,-72,[1,"7a/ZPxLq9ONY2l3Ucap3sm"],[0,0.5,0]],[256,36,30,26,125,-73,[1,"96pTOOd1dNQoJBKqOIwzok"]],[56,false,-74,[1,"02/3p4u1JIU7gmUb+LFD6e"],[54,55,56]],-75,[37,-76,[1,"d0ZbyKCtNKp5zRtfnZDzqg"]],[76,-78,[1,"1b5klyU/dKn6b7yT1SX+V6"],-77]],4,4,4,1,4,4],[3,"e0Sr5xXa1LwagR8Ehh1izz",1,0],[1,131,125,0]],[143,"Content Holder",33554432,1,[-86,-87],[[[5,-81,[1,"35Zi4zjZpAzIbL8yBSW7ja"],[5,414,896]],[180,45,100,100,1,-82,[1,"adWONl/O1BqZu3ceRRx8yR"]],[292,false,true,-83,[1,"2d1LF78e5LyqVrqqnwRExW"],[57,58]],[37,-84,[1,"f2AdQrNaJPSJ+QxJpbSEni"]],-85],4,4,4,4,1],[3,"2fKNyZaqBKFJ8YD+zsVeyv",1,0]],[22,"Group_Bot Holder",33554432,8,[2,3,4,7],[[17,-88,[1,"39zm9cBqlMspCGvVgiTolp"],[5,414,100],[0,0.5,0]],[92,44,100,1,-89,[1,"29yJcljBxFEZRz3pDHuQbI"]]],[3,"e4WQQgUuhOwKioLzQcZ+qn",1,0],[1,0,-448,0]],[144,"Text_CooldownValue",33554432,[[[5,-90,[1,"88LIW1RBNKUKGpqxlaCATx"],[5,39.08,83.6]],-91,[203,4,-92,[1,"e411gP3DRP24eG/tb16bEF"]],[86,-94,[1,"c2vKqG59xIFa3UduwLNS/C"],-93]],4,1,4,4],[3,"ceFy9nYNZChr++jaTFCk4W",1,0],[1,1.34,4.7,0]],[43,"First Ready",33554432,[[8,-95,[1,"e9O7fvBy5EZIKQ9TNt8wTD"]],[95,8,-99,[1,"08QRhjHPFGsqzynmqNGepj"],[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",2],[6,"ac879rTendCEbpZWFz/jexs","playSFX",-96],[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","ready",2],[27,"c83f3h67FpJDoLcaBUEDjiF","activatewithDelay",".5",4],[27,"c83f3h67FpJDoLcaBUEDjiF","activatewithDelay",".5",5],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-97],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-98]]],[77,-100,[1,"99JfxSO99GMq9BVk21zIoo"],60],[37,-101,[1,"25iy6QIKhCf5AmwhBHiBxF"]]],[3,"7fmQMs5HdD17AmALFVImSx",1,0]],[229,"Ready",false,33554432,[[8,-102,[1,"5eGJHs6jRMb7+6iQ3HD/Xw"]],[95,8,-104,[1,"349xFkD6FMz72g/kRbGRWv"],[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",2],[6,"ac879rTendCEbpZWFz/jexs","playSFX",-103],[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","ready",2]]],[77,-105,[1,"e36OeqE+1OzLlJByJQH/eb"],59],[37,-106,[1,"7fjFnzYORKqZDQRwt7s+h7"]]],[3,"9b21DuIWZPg78B7JppYYQJ",1,0]],[61,"Divide",33554432,[-108,-109,-110,-111,-112],[[8,-107,[1,"af6DIZ2hpHxpUGBsYMMb/4"]]],[3,"aco/NiaD5HfZe9Se/YRevU",1,0]],[22,"Group_Top Panel",33554432,8,[-115,5,6],[[17,-113,[1,"4f9jWJcy5HAYKCc7iiyiES"],[5,414,100],[0,0.5,1]],[92,41,100,1,-114,[1,"b8daAJU7VPYZL0vKjPM7+N"]]],[3,"4bMaNd2RxCwYrKMuzgxYwZ",1,0],[1,0,448,0]],[20,"Sprite_Shadow",33554432,2,[-119,-120],[[5,-116,[1,"4fgT/2ZYJNjYggJAXazi+2"],[5,104,92]],[31,0,-117,[1,"afjDInnW5P3ImeRFkZFHoO"],[4,14477819],16],[49,45,112,112,-118,[1,"321YroE3BMBaQRhhjw7bzn"]]],[3,"321URf3g5HQo6JMFu7CItt",1,0]],[20,"Sprite_Shadow",33554432,3,[-124,-125],[[5,-121,[1,"13sjTxzQZFzaSWldPR9COF"],[5,104,92]],[31,0,-122,[1,"3ce4M+K2BEgLU4LjDJCt++"],[4,14477819],37],[49,45,112,112,-123,[1,"93qtUOiVdFJ5MtkGuO4Yz9"]]],[3,"edj7tU9xtKtYOHA7KXfZQR",1,0]],[20,"Event Listeners",33554432,1,[-127,13,-128,-129],[[8,-126,[1,"f2C0bZKaFOT4krPluMbka0"]]],[3,"a2km2E6dpPwr/4TB2gpx6F",1,0]],[22,"Group_SlimesLeft",33554432,14,[-133],[[17,-130,[1,"95bSrRQTxME4EdaSrLkhAX"],[5,140,44],[0,1,0.5]],[257,33,26,26,1,-131,[1,"74X0eimQtJz422Ozb7Y3hE"]],[57,-132,[1,"e8hi502M5GVK1ppV0tINoW"]]],[3,"cfXK9tt5dKq4tGAa/+wqjl",1,0],[1,181,-48,0]],[22,"Panel",33554432,18,[-136,-137],[[5,-134,[1,"72Pvsqb/5MUK6FtiwH93fv"],[5,126,44]],[29,1,0,-135,[1,"85ygqCwINJLoROU5pJ65IE"],[4,4292667899],2]],[3,"37/k5csTtIHqzwuMB9QoG2",1,0],[1,-70,0,0]],[140,"Sprite_Icon",33554432,19,[-141],[[17,-138,[1,"fbcvaKzRNKmZphhMCFM2vp"],[5,96,76],[0,0.5,0]],[31,0,-139,[1,"22MeH0Bf9LFZ9mW/tmpiwP"],[4,4292667899],1],[179,36,-19.21099999999999,0.5,-140,[1,"4dDqWOsNZMupipgHFFg4DH"]]],[3,"816iBxdJVLIZtcDuFQvFY2",1,0],[1,30.36,-21.5,0],[1,0.68,0.7,1]],[144,"Text_CurrentSlimes",33554432,[[[5,-142,[1,"beTqrTEwdKEYQuP3KaVYiO"],[5,50,40.32]],-143,[86,-145,[1,"ec8pTMS79FDb39ARaf50gr"],-144]],4,1,4],[3,"60a0/0ctFPzJhO3khIxzB5",1,0],[1,-0.719,1.676,0]],[20,"Panel_Outline",33554432,5,[-148,-149],[[5,-146,[1,"80XbWyP/tIu4eBSDvgp177"],[5,200,48]],[149,1,0,-147,[1,"58hHcrW3VNmomwE7O5Otyj"],5]],[3,"b8WhaVbSVG+Z8wc/3PJK0V",1,0]],[20,"Panel_Outline",33554432,6,[-152,-153],[[5,-150,[1,"7bt0AHq6ZGdpmAPy1MCnad"],[5,220,48]],[149,1,0,-151,[1,"e3EWXc8tRBTqv8UUWNGvXT"],10]],[3,"faCsTAkt9DCI12Q03Z/Yul",1,0]],[20,"Speed Boost (Dash)",33554432,17,[11,12,-155],[[8,-154,[1,"ab1OrmCutG4qWJOmDvlxx8"]]],[3,"0eqS0z2JdERaMY7o/4ZNj8",1,0]],[16,"1st Ready",33554432,13,[[8,-156,[1,"bb2n+lBJJP0KZ2O21Zpbl+"]],[111,1,-159,[1,"bcQwOpvbFOF4Wlb05AZWBy"],[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",3],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-157],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-158],[27,"c83f3h67FpJDoLcaBUEDjiF","activatewithDelay",".5",7],[27,"c83f3h67FpJDoLcaBUEDjiF","activatewithDelay",".5",6]]],[37,-160,[1,"73mS/Wv8FF/ZYf7ewDxWAM"]]],[3,"a6hkx7ZcRG8q5OC7ZyZfJl",1,0]],[163,"Ready",false,33554432,13,[[8,-161,[1,"33BhePICZIyZQiRj5lv26o"]],[111,1,-162,[1,"85B4xY45dOwLIpzekGIoFj"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","divideReady",3]]],[37,-163,[1,"f7pw7OlSpBJK3h1ruzyFjl"]]],[3,"8fgnrjkLBGPbfbdG5Hvv+k",1,0]],[20,"Unite",33554432,17,[-165,-166,-167],[[8,-164,[1,"63psynlylDYqXPMIRrzyiS"]]],[3,"57tjH/bR5LvrckyrLWHKmM",1,0]],[20,"Scripts",33554432,1,[-169,-170],[[8,-168,[1,"1cYW+TaVRIwoMVJ0l4M2nJ"]]],[3,"6dvbaEk+hGRpAAb9b9rCwt",1,0]],[32,"Sprite_IconColor",33554432,20,[[17,-171,[1,"274Sfo+X5K7qVjn0Kq4Kdb"],[5,88.00000000000007,68.00000000000001],[0,0.5,0]],[31,0,-172,[1,"fc6FB/Zb1H0KM9SJeZoxRP"],[4,4293693569],0],[40,45,3.9999999999999716,3.9999999999999716,4,4,96,80,-173,[1,"dddMFpRaVApbfvkw+mumeo"]]],[3,"44QT7VXpFKu6JPfyChjR1O",1,0],[1,0,4,0]],[16,"Panel_Color",33554432,22,[[5,-174,[1,"b5A33fkTdGFqSo88LokOzv"],[5,194,42]],[29,1,0,-175,[1,"54HbeZgmtNcKWHr5+nz5QN"],[4,4294955081],3],[40,45,3,3,3,3,200,48,-176,[1,"c1wQwkaklDa68fhJ9OpuY2"]]],[3,"depACLq4tFWZC3vqSiLdhN",1,0]],[16,"Panel_Color",33554432,23,[[5,-177,[1,"a4bVmHkalA16yrsbr1rZbl"],[5,214,42]],[29,1,0,-178,[1,"ea9OtuYFxJF48/1xQq+6am"],[4,4288702433],8],[40,45,3,3,3,3,200,48,-179,[1,"db+DX2G1JBIIwbloIjlGP5"]]],[3,"c2A7hPlU5Fq6lAq6ohNh4k",1,0]],[16,"Sprite_Button",33554432,15,[[5,-180,[1,"e5It92HTpNTJUSV3nIrwxb"],[5,104,92]],[74,0,-181,[1,"beacED0+1OXKtHEG+Mxwxt"],13]],[3,"55/VSI+PBH6qOtFuNtkMpN",1,0]],[164,"Sprite_CooldownShadow",false,33554432,15,[-184],[[5,-182,[1,"eebkbudqZJfKndxRSxZSiA"],[5,108,96]],[192,3,2,0,0.25,1,-183,[1,"3eywJWIJVM9qWMit7aSFTX"],[4,2516582400],[0,0.5,0.56],15]],[3,"5fb+EoQLdCVLhtt6E/OhNB",1,0]],[32,"Text_CooldownValue",33554432,33,[[5,-185,[1,"43uKIFmBtOE4rQx/Jgm6ha"],[5,39.08,83.6]],[94,"5",60,60,60,false,-186,[1,"86xJclfvFMrobpAQBnhKZ6"],[4,4294174947],14],[203,4,-187,[1,"1aKlIkMVtMJaf8NEocFakO"]]],[3,"dcs6tKqhNP/7/QWXwv62Ue",1,0],[1,1.34,4.7,0]],[22,"Panel_Color",33554432,4,[-190],[[5,-188,[1,"3es+fLeYhCXqNjjjU7PJio"],[5,106,70]],[29,1,0,-189,[1,"6fk5yuwWZAvrC9W4UQMlw2"],[4,4292667899],24]],[3,"f1rGX0oz1Ct63VxyyEuQug",1,0],[1,0,50,0]],[165,"Sprite_Arrow",33554432,35,[[5,-191,[1,"06K8k0BblMjrlVMBGC2gq7"],[5,20,20]],[31,0,-192,[1,"49uwLuhI5HnYGjVEFUfY70"],[4,4292667899],23],[181,4,-8.466999999999999,-193,[1,"25rpOUYOVBCp/JAfp8Z4sv"]]],[3,"f5Mcr41+NIj43SUmEejuEj",1,0],[1,-0.613,-33.467,1.88],[3,0,0,1,6.123233995736766e-17],[1,0,0,180]],[43,"Pressed",33554432,[[8,-194,[1,"30TmkaosFLYbZXK2VdOXPx"]],[296,-195,[1,"ecKu5VBH1FgoqUBp5JAjaH"]]],[3,"a1ONkWpi5EgrjpmBoQuYad",1,0]],[61,"First Skill Button",33554432,[37,-197],[[8,-196,[1,"den7nj4AVOdJtrWIatnrTp"]]],[3,"dceiCmpgFOBojLrNvyBW7S",1,0]],[20,"UI",33554432,28,[-199,38],[[8,-198,[1,"e81Exe6vVFBorL9AGs6+8D"]]],[3,"32r/8IuWxLm4R7xrdrdEYu",1,0]],[16,"Released",33554432,38,[[8,-200,[1,"1ezyau9qBDQ49wUiEQU5wD"]],[297,2,-201,[1,"488si4O0tGr7R7XTfC7COZ"]]],[3,"6cwP4L7QNAM4Lf8v/nWnz9",1,0]],[16,"Sprite_Button",33554432,16,[[5,-202,[1,"0d9wTTkjtLy5V/Uz2NIcH9"],[5,104,92]],[74,0,-203,[1,"fcCe+4nNRBDLkkvG6UQwop"],35]],[3,"e2qmmgkNpAgZgPgutabFIc",1,0]],[164,"Sprite_CooldownShadow",false,33554432,16,[10],[[5,-204,[1,"13qLzatYpFzaqgz5b9shl8"],[5,108,96]],[192,3,2,0,0.25,1,-205,[1,"b5PS49ENBGjoZzBPb826G7"],[4,2516582400],[0,0.5,0.56],36]],[3,"42lyE4zhdKYplxSnxHfTxJ",1,0]],[22,"Panel_Color",33554432,7,[-208],[[5,-206,[1,"3eaylRdvZPapu5FiLQzxqT"],[5,106,70]],[29,1,0,-207,[1,"e2dxuGneRLgo0+sC9bvnOo"],[4,4292667899],52]],[3,"c8o7nxNeVNJaC3Ijb5n6hk",1,0],[1,0,50,0]],[165,"Sprite_Arrow",33554432,43,[[5,-209,[1,"7f5CkITVBN6Y+XCJKr5uot"],[5,20,20]],[31,0,-210,[1,"afg27up7VHcqZobCEyzdLf"],[4,4292667899],51],[181,4,-8.466999999999999,-211,[1,"b3vwS8Vy1CBZmCJFuW/Hlf"]]],[3,"dbJciFOlxK7rg33a0+jj6F",1,0],[1,-0.613,-33.467,1.88],[3,0,0,1,6.123233995736766e-17],[1,0,0,180]],[20,"Game",33554432,17,[-213,-214],[[8,-212,[1,"d0pRhZWWlGwpvu7n41R2Dx"]]],[3,"c1UUqoALZBua6HJASZnQvi",1,0]],[20,"Animation",33554432,28,[-216],[[8,-215,[1,"78Qq90l0xNLIZJLW+omAjm"]]],[3,"23YHxa49BOR6RbG/sWKyia",1,0]],[16,"TS-Game-Animation-Helper",33554432,46,[[8,-217,[1,"fc2JqrwmhHPLDnMbTVc4hT"]],[76,-219,[1,"eaTGvkaZRPpLF62K8O0ymX"],-218]],[3,"0fAdn5TNNL94gOv1d6Rkt3",1,0]],[22,"Group_Values",33554432,19,[21],[[5,-220,[1,"00Bsvbx4VCybnY1fKEFXkL"],[5,56,40]]],[3,"fddGVDs3pMTJPgJDeplqgh",1,0],[1,-23.333,0.3,0]],[32,"Text_Ability Unlock",33554432,22,[[5,-221,[1,"86D59pJRdHAab2usayRAIs"],[5,146.25,50.4]],[151,"Dash unlocked!",26,26,false,-222,[1,"34YiFjF/9AYbdz68EwfWjF"],[4,4284040721],4]],[3,"94T1hGAGpMnr6/+sB63EJn",1,0],[1,0,3.326,0]],[32,"Text_Ability Unlock",33554432,23,[[5,-223,[1,"b1ddXhq3NMa6jxvIp5Y2Nl"],[5,159.67,50.4]],[151,"Divide unlocked!",26,26,false,-224,[1,"606Kav0spK9rQF2zdNd2+O"],[4,4281408365],9]],[3,"caX6eBKrpKXJ0FFCi0ASSX",1,0],[1,0,3.326,0]],[32,"Text_Ability Info",33554432,4,[[5,-225,[1,"5dUxTCYStFc6IPL1jWfpVE"],[5,92,35.28]],[282,"Tap'n Hold",18,18,28,2,false,-226,[1,"ba5iEM9bVBTawsv1QLCklG"],[4,4278475943],25]],[3,"3cA8kaLXNEvbasKvse0glX",1,0],[1,0,63.712999999999994,0]],[32,"Text_Ability Info 02",33554432,4,[[5,-227,[1,"132zvabKBEuJtLVhikSISs"],[5,86.59,35.28]],[94,"to Dash",24,24,28,false,-228,[1,"6dfB9moNxJmJnqaq2AtHPy"],[4,4278475943],26]],[3,"36lBNCfl5IGLeFdcZvUXZe",1,0],[1,0,42.162000000000006,0]],[16,"TS-Menu-StartClicked",33554432,39,[[8,-229,[1,"7058W6Gl1IPrrBcgllP5VF"]],[191,"menu-start-clicked",-230,[1,"ffsdEJDdxOcK+v3NkxwMF6"],[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",8]]]],[3,"312lb29SpITbBrvZvsi/vd",1,0]],[32,"Text_Ability Info",33554432,7,[[5,-231,[1,"ddolwphJ5OhZMQbn0N5zuF"],[5,70.58,58.76]],[94,"Tap to\nDivide",24,24,26,false,-232,[1,"70EX4fvOhA+Ixd/tTBZFYz"],[4,4278475943],53]],[3,"baxtGuySxMlKrUFF9L+ndM",1,0],[1,0,50.90299999999999,0]],[16,"Not Ready",33554432,24,[[8,-233,[1,"ff/fN+87RNhpD52/ec83Wt"]],[95,9,-234,[1,"1adf6/4shApqIQ6qxilf1R"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","notReady",2],[27,"37b85WpHzdBn41+pXJNQa6l","setBool","enabled,false",4],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",5]]]],[3,"603Zndz3pIUqXrj2O74GaA",1,0]],[16,"Not Ready",33554432,13,[[8,-235,[1,"e7rrLmPNVGA6GDmZzYRA0I"]],[295,-236,[1,"875Peyu3NItZWW5GElXfpX"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","divideNotReady",3],[27,"37b85WpHzdBn41+pXJNQa6l","setBool","enabled,false",7]]]],[3,"44PCcxAFNOZ6UKURspK10D",1,0]],[16,"Used",33554432,13,[[8,-237,[1,"7dwcp9zWhKwbAMd42nJKhM"]],[111,2,-238,[1,"4blBjtultN+bR3/DJuBLlP"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","divideCD",3],[27,"37b85WpHzdBn41+pXJNQa6l","setBool","enabled,false",7],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",6]]]],[3,"3fo6zUgu1GHIFt5Vl/xp38",1,0]],[16,"CD Time",33554432,13,[[8,-239,[1,"4769mlj3VIXZQb3jvV06+r"]],[95,16,-240,[1,"9dNAsp9DJKer3oQCZRSGPi"],[[6,"85848g+yY1PpKiragtG2vjV","setText",10]]]],[3,"90vaU68T9MKLokRu1GEQY4",1,0]],[16,"Ready",33554432,27,[[8,-241,[1,"3a/Lg1XZxE4JYqoqGGeBRv"]],[111,4,-242,[1,"fd4W7Bc8VBg5K9yssMpic4"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","uniteReady",3]]]],[3,"93D2vvBSJG8bvcVmlghjK7",1,0]],[16,"Used",33554432,27,[[8,-243,[1,"08M2guKExAN6N7NYyvCf1c"]],[111,5,-244,[1,"97fsTGy9lHgLbF6DJYb0PA"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","uniteCD",3]]]],[3,"d0HQFsL99Ga6DzF1ynef5j",1,0]],[16,"CD Time",33554432,27,[[8,-245,[1,"07VcedW+1AhJzp/VKFq8Zn"]],[95,17,-246,[1,"6cC8DsZaRPn6Hcm6kx0K9n"],[[6,"85848g+yY1PpKiragtG2vjV","setText",10]]]],[3,"3cVIR627pHuYfBxz4heyy8",1,0]],[16,"Finished",33554432,45,[[8,-247,[1,"14DzWjjyZBIIV7nrFgdaEh"]],[132,4,-248,[1,"9299cww2hD96qI+s/B64rH"],[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",8]]]],[3,"d7ad6HQZ1HHrnKhC7mFI2s",1,0]],[16,"Total Slimes",33554432,45,[[8,-249,[1,"12LHb32vpPiKG7TmXvEizo"]],[132,5,-250,[1,"9991OFWdZGIY9Bfh9JsVSo"],[[6,"85848g+yY1PpKiragtG2vjV","setText",21]]]],[3,"1fMF7XY8dAtYpMsyGCLAKP",1,0]],[63,8,[1,"2c3PzomjVLy7B5dUaprycN"]],[110,"20",29,29,32,2,false,false,21,[1,"83k2nXNrdBNbS/FKLuzUqb"],[4,4280640473]],[91,"Particle_Slime Implosion",false,33554432,2,[-251],[3,"d9pjX3lzlNep/BmlK2PJo6",1,0],[1,14,14,1]],[206,true,2,false,50.126972782650995,44.757084172339034,2.1967577837207903,30,[null,null],66,[1,"69xc8Bm71JSquV7jZGD9F3"],[78,2,[4,4293841938],[4,4294505908]],[25,3,0.1,1],[4],[4],[101,3,-16,-24,30],[4],[4],[25,3,-0.5235987755982988,0.5235987755982988],[4],[25,3,0.8,1.5],[102,2],[4],[4],[[68,[9,24]]],[64,[33]],[212,true,1,0,1,6,0,[9,1]],[69,true,[34,1,[10,[0,0.5974358974358974,0.7974358974358975,1],[[11,2,0.5962962962962963,0.034805890227577026,0.034805890227577026],[11,2,0.9407407407407408,0.6319444444444451,0.6319444444444451],[11,2,1,-0.24074074074073928,-0.24074074074073928],[36,2,-12.759259259259306,-12.759259259259306]]]],[4],[4],[4]],[114,true,[47,2,[10,[0,1],[[15,2,1],[11,2,-0.007407407407407408,-3.2792792792792795,-3.2792792792792795]]],[10,[0.01282051282051282,1],[[15,2,-1],[36,2,3.6666666666666674,3.6666666666666674]]]],[47,2,[10,[0,0.8],[[11,2,1,-2.626262626262626,-2.626262626262626],[15,2,0.007407407407407408]]],[10,[0,0.8],[[11,2,-1,2.236559139784947,2.236559139784947],[96,2]]]],[4],[34,1,[10,[0,0.6051282051282051],[[11,2,1,-4.814814814814815,-4.814814814814815],[15,2,0.0962962962962963]]]]],[50,[4],[4],[4]],[115,-3,[9,0.5],[9,0.1],[4],[9,4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-252],[53,17]],[91,"Particle_Circle Expand",false,33554432,2,[-253],[3,"fc+7pKzzJMdKYJpggPfMzL",1,0],[1,14,12.999999999999998,0.9999999999999999]],[207,0.8,false,1.1,2,175,175,4.166666666666667,3,68,[1,"821mPudEBHmbMfOR0nNgRM"],[[18,null],6,0],[87,[4,4294502443]],[9,4],[4],[4],[102,30],[4],[4],[113,3],[4],[9,1],[102,2],[4],[4],[[210,0,[9,1]],[88,0.15,[9,1]]],[211,true,[112,1,[217,[[135,0.008928571428571428],[135,1]],[[71,200,0.3794642857142856],[71,0,1]]]]],[213,true,1,0,0,0,[9,1]],[69,true,[79,1,5,[10,[0,0.43333333333333335,0.9974358974358974],[[36,2,3.9934640522875817,3.9934640522875817],[11,2,0.6444444444444445,-0.7407407407407416,-0.7407407407407416],[36,2,-0.34541062801932354,-0.34541062801932354]]]],[4],[4],[4]],[89,[47,2,[10,[0,1],[[15,2,1],[11,2,-0.007407407407407408,-3.2792792792792795,-3.2792792792792795]]],[10,[0.01282051282051282,1],[[15,2,-1],[36,2,3.6666666666666674,3.6666666666666674]]]],[47,2,[10,[0,0.8],[[11,2,1,-2.626262626262626,-2.626262626262626],[15,2,0.007407407407407408]]],[10,[0,0.8],[[11,2,-1,2.236559139784947,2.236559139784947],[96,2]]]],[4],[34,1,[10,[0,0.6051282051282051],[[11,2,1,-4.814814814814815,-4.814814814814815],[15,2,0.0962962962962963]]]]],[50,[4],[4],[4]],[115,-3,[9,0.5],[9,0.1],[4],[9,5]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-254],[53,19]],[91,"Particle_Slime Explosion",false,33554432,2,[-255],[3,"40NCLhKRJI1a5vfNrjH29x",1,0],[1,14,14,0.9999999999999999]],[206,true,2,false,50.126972782650995,44.757084172339034,2.1967577837207903,30,[null,null],70,[1,"e7cY/flNRLCIBiPyBO0Qia"],[78,2,[4,4289486848],[4,4294960682]],[25,3,0.1,1],[4],[4],[101,3,12,18,30],[4],[4],[25,3,-0.5235987755982988,0.5235987755982988],[4],[25,3,0.6,1],[209,2,2],[4],[4],[[68,[9,24]]],[64,[33]],[214,true,1,0,1,1,0.6,0,4.014257279586958,[9,1],[1,0,0,-45]],[69,true,[34,1,[10,[0,0.5974358974358974,0.7974358974358975,1],[[11,2,0.5962962962962963,0.034805890227577026,0.034805890227577026],[11,2,0.9407407407407408,0.6319444444444451,0.6319444444444451],[11,2,1,-0.24074074074073928,-0.24074074074073928],[36,2,-12.759259259259306,-12.759259259259306]]]],[4],[4],[4]],[114,true,[47,2,[10,[0,1],[[15,2,1],[11,2,-0.007407407407407408,-3.2792792792792795,-3.2792792792792795]]],[10,[0.01282051282051282,1],[[15,2,-1],[36,2,3.6666666666666674,3.6666666666666674]]]],[47,2,[10,[0,0.8],[[11,2,1,-2.626262626262626,-2.626262626262626],[15,2,0.007407407407407408]]],[10,[0,0.8],[[11,2,-1,2.236559139784947,2.236559139784947],[96,2]]]],[4],[34,1,[10,[0,0.6051282051282051],[[11,2,1,-4.814814814814815,-4.814814814814815],[15,2,0.0962962962962963]]]]],[50,[4],[4],[4]],[216,true,-3,[9,0.5],[9,0.1],[4],[9,4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-256],[53,20]],[91,"Particle_Button Active",false,33554432,2,[-257],[3,"94jQxkAZpAG6+7kt9tpWF6",1,0],[1,14,14,0.9999999999999999]],[298,true,2,50.126972782650995,44.757084172339034,2.1967577837207903,30,72,[1,"abpUfm2e1Ew7o4unO7GZbt"],[[21,null],6,0],[78,2,[4,4289486848],[4,4294960682]],[25,3,0.6,1],[4],[4],[101,3,6,10,30],[4],[4],[25,3,-0.5235987755982988,0.5235987755982988],[4],[25,3,0.6,1],[101,3,1,3,16],[9,20],[4],[64,[33]],[302,true,1,0,1,1,1,3,0,2.0943951023931953,[9,1],[1,0,0,20]],[69,true,[34,1,[10,[0,0.5230769230769231,0.7435897435897436,1],[[11,2,0.34074074074074073,0.034805890227577026,0.034805890227577026],[11,2,0.725925925925926,0.9346405228758163,0.9346405228758163],[11,2,0.9296296296296296,-0.5522875816993451,-0.5522875816993451],[36,2,-6.040404040404038,-6.040404040404038]]]],[4],[4],[4]],[89,[47,2,[10,[0,1],[[15,2,1],[11,2,-0.007407407407407408,-3.2792792792792795,-3.2792792792792795]]],[10,[0.01282051282051282,1],[[15,2,-1],[36,2,3.6666666666666674,3.6666666666666674]]]],[47,2,[10,[0,0.8],[[11,2,1,-2.626262626262626,-2.626262626262626],[15,2,0.007407407407407408]]],[10,[0,0.8],[[11,2,-1,2.236559139784947,2.236559139784947],[96,2]]]],[4],[34,1,[10,[0,0.6051282051282051],[[11,2,1,-4.814814814814815,-4.814814814814815],[15,2,0.0962962962962963]]]]],[50,[4],[4],[4]],[115,0,[9,0.5],[9,0.1],[4],[4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-258],[53,22]],[63,4,[1,"90pj5LMQpLzYSoYhVuOvZD"]],[63,2,[1,"fd/M4cpidCl4HVsDFUR5HE"]],[283,"5",60,60,60,false,10,[1,"41+xq+ICZFp5jqTmwbIZ7A"],[4,4294174947]],[91,"Particle_Slime Implosion",false,33554432,3,[-259],[3,"19fAKLNmJCxb7875hXkfv7",1,0],[1,14,14,1]],[208,true,2,false,50.126972782650995,44.757084172339034,2.1967577837207903,30,77,[1,"86PFqr0LRP8IOQoJ+i7XZR"],[[38,null],6,0],[78,2,[4,4291379955],[4,4292971516]],[25,3,0.1,1],[4],[4],[101,3,-16,-24,30],[4],[4],[25,3,-0.5235987755982988,0.5235987755982988],[4],[25,3,0.8,1.5],[102,2],[4],[4],[[68,[9,24]]],[64,[33]],[212,true,1,0,1,6,0,[9,1]],[69,true,[34,1,[10,[0,0.5974358974358974,0.7974358974358975,1],[[11,2,0.5962962962962963,0.034805890227577026,0.034805890227577026],[11,2,0.9407407407407408,0.6319444444444451,0.6319444444444451],[11,2,1,-0.24074074074073928,-0.24074074074073928],[36,2,-12.759259259259306,-12.759259259259306]]]],[4],[4],[4]],[114,true,[47,2,[10,[0,1],[[15,2,1],[11,2,-0.007407407407407408,-3.2792792792792795,-3.2792792792792795]]],[10,[0.01282051282051282,1],[[15,2,-1],[36,2,3.6666666666666674,3.6666666666666674]]]],[47,2,[10,[0,0.8],[[11,2,1,-2.626262626262626,-2.626262626262626],[15,2,0.007407407407407408]]],[10,[0,0.8],[[11,2,-1,2.236559139784947,2.236559139784947],[96,2]]]],[4],[34,1,[10,[0,0.6051282051282051],[[11,2,1,-4.814814814814815,-4.814814814814815],[15,2,0.0962962962962963]]]]],[50,[4],[4],[4]],[115,-3,[9,0.5],[9,0.1],[4],[9,4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-260],[53,39]],[91,"Particle_Circle Expand",false,33554432,3,[-261],[3,"4dXCrRK+ZA+7yEKBLnPbMU",1,0],[1,14,12.999999999999998,0.9999999999999999]],[207,0.8,false,1.1,2,175,175,4.166666666666667,3,79,[1,"72Q6Ql7B5Ego9FyGMgpgQQ"],[[40,null],6,0],[87,[4,4285020134]],[9,4],[4],[4],[102,30],[4],[4],[113,3],[4],[9,1],[102,2],[4],[4],[[210,0,[9,1]],[88,0.15,[9,1]]],[211,true,[112,1,[217,[[135,0.008928571428571428],[135,1]],[[71,200,0.3794642857142856],[71,0,1]]]]],[213,true,1,0,0,0,[9,1]],[69,true,[79,1,5,[10,[0,0.43333333333333335,0.9974358974358974],[[36,2,3.9934640522875817,3.9934640522875817],[11,2,0.6444444444444445,-0.7407407407407416,-0.7407407407407416],[36,2,-0.34541062801932354,-0.34541062801932354]]]],[4],[4],[4]],[89,[47,2,[10,[0,1],[[15,2,1],[11,2,-0.007407407407407408,-3.2792792792792795,-3.2792792792792795]]],[10,[0.01282051282051282,1],[[15,2,-1],[36,2,3.6666666666666674,3.6666666666666674]]]],[47,2,[10,[0,0.8],[[11,2,1,-2.626262626262626,-2.626262626262626],[15,2,0.007407407407407408]]],[10,[0,0.8],[[11,2,-1,2.236559139784947,2.236559139784947],[96,2]]]],[4],[34,1,[10,[0,0.6051282051282051],[[11,2,1,-4.814814814814815,-4.814814814814815],[15,2,0.0962962962962963]]]]],[50,[4],[4],[4]],[115,-3,[9,0.5],[9,0.1],[4],[9,5]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-262],[53,41]],[91,"Particle_Slime Explosion",false,33554432,3,[-263],[3,"5ddSOtkTBAop87oYD+UuNG",1,0],[1,14,14,0.9999999999999999]],[208,true,2,false,50.126972782650995,44.757084172339034,2.1967577837207903,30,81,[1,"e7fuX/rMlGxqee9zXzExkt"],[[42,null],6,0],[78,2,[4,4283629740],[4,4291570431]],[25,3,0.1,1],[4],[4],[101,3,12,18,30],[4],[4],[25,3,-0.5235987755982988,0.5235987755982988],[4],[25,3,0.6,1],[209,2,2],[4],[4],[[68,[9,24]]],[64,[33]],[214,true,1,0,1,1,0.6,0,4.014257279586958,[9,1],[1,0,0,-45]],[69,true,[34,1,[10,[0,0.5974358974358974,0.7974358974358975,1],[[11,2,0.5962962962962963,0.034805890227577026,0.034805890227577026],[11,2,0.9407407407407408,0.6319444444444451,0.6319444444444451],[11,2,1,-0.24074074074073928,-0.24074074074073928],[36,2,-12.759259259259306,-12.759259259259306]]]],[4],[4],[4]],[114,true,[47,2,[10,[0,1],[[15,2,1],[11,2,-0.007407407407407408,-3.2792792792792795,-3.2792792792792795]]],[10,[0.01282051282051282,1],[[15,2,-1],[36,2,3.6666666666666674,3.6666666666666674]]]],[47,2,[10,[0,0.8],[[11,2,1,-2.626262626262626,-2.626262626262626],[15,2,0.007407407407407408]]],[10,[0,0.8],[[11,2,-1,2.236559139784947,2.236559139784947],[96,2]]]],[4],[34,1,[10,[0,0.6051282051282051],[[11,2,1,-4.814814814814815,-4.814814814814815],[15,2,0.0962962962962963]]]]],[50,[4],[4],[4]],[216,true,-3,[9,0.5],[9,0.1],[4],[9,4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-264],[53,43]],[63,3,[1,"99yXVxb6ZLprDKfrfVtDye"]],[63,7,[1,"90pj5LMQpLzYSoYhVuOvZD"]]],0,[0,9,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,28,0,-2,8,0,-3,17,0,0,2,0,0,2,0,1,40,0,1,2,0,1,37,0,1,2,0,13,32,0,1,4,0,0,2,0,0,2,0,0,2,0,-6,75,0,28,75,0,0,2,0,-1,15,0,-2,66,0,-3,68,0,-4,70,0,-5,72,0,0,3,0,0,3,0,13,41,0,1,3,0,0,3,0,0,3,0,0,3,0,-6,83,0,28,83,0,0,3,0,0,3,0,-1,16,0,-2,77,0,-3,79,0,-4,81,0,0,4,0,0,4,0,0,4,0,-4,74,0,0,4,0,28,74,0,0,4,0,-1,35,0,-2,51,0,-3,52,0,0,5,0,0,5,0,0,5,0,0,5,0,1,5,0,0,5,0,1,5,0,0,5,0,-1,22,0,0,6,0,0,6,0,0,6,0,0,6,0,1,6,0,0,6,0,1,6,0,0,6,0,-1,23,0,0,7,0,0,7,0,0,7,0,-4,84,0,0,7,0,28,84,0,0,7,0,-1,43,0,-2,54,0,0,8,0,0,8,0,0,8,0,0,8,0,-5,64,0,-1,14,0,-2,9,0,0,9,0,0,9,0,0,10,0,-2,76,0,0,10,0,25,76,0,0,10,0,0,11,0,1,11,0,1,11,0,1,12,0,0,11,0,0,11,0,0,11,0,0,12,0,1,12,0,0,12,0,0,12,0,0,12,0,0,13,0,-1,25,0,-2,26,0,-3,56,0,-4,57,0,-5,58,0,0,14,0,0,14,0,-1,18,0,0,15,0,0,15,0,0,15,0,-1,32,0,-2,33,0,0,16,0,0,16,0,0,16,0,-1,41,0,-2,42,0,0,17,0,-1,24,0,-3,27,0,-4,45,0,0,18,0,0,18,0,0,18,0,-1,19,0,0,19,0,0,19,0,-1,20,0,-2,48,0,0,20,0,0,20,0,0,20,0,-1,29,0,0,21,0,-2,65,0,25,65,0,0,21,0,0,22,0,0,22,0,-1,30,0,-2,49,0,0,23,0,0,23,0,-1,31,0,-2,50,0,0,24,0,-3,55,0,0,25,0,1,26,0,1,25,0,0,25,0,0,25,0,0,26,0,0,26,0,0,26,0,0,27,0,-1,59,0,-2,60,0,-3,61,0,0,28,0,-1,46,0,-2,39,0,0,29,0,0,29,0,0,29,0,0,30,0,0,30,0,0,30,0,0,31,0,0,31,0,0,31,0,0,32,0,0,32,0,0,33,0,0,33,0,-1,34,0,0,34,0,0,34,0,0,34,0,0,35,0,0,35,0,-1,36,0,0,36,0,0,36,0,0,36,0,0,37,0,0,37,0,0,38,0,-2,40,0,0,39,0,-1,53,0,0,40,0,0,40,0,0,41,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,-1,44,0,0,44,0,0,44,0,0,44,0,0,45,0,-1,62,0,-2,63,0,0,46,0,-1,47,0,0,47,0,28,64,0,0,47,0,0,48,0,0,49,0,0,49,0,0,50,0,0,50,0,0,51,0,0,51,0,0,52,0,0,52,0,0,53,0,0,53,0,0,54,0,0,54,0,0,55,0,0,55,0,0,56,0,0,56,0,0,57,0,0,57,0,0,58,0,0,58,0,0,59,0,0,59,0,0,60,0,0,60,0,0,61,0,0,61,0,0,62,0,0,62,0,0,63,0,0,63,0,-1,67,0,18,67,0,-1,69,0,18,69,0,-1,71,0,18,71,0,-1,73,0,18,73,0,-1,78,0,18,78,0,-1,80,0,18,80,0,-1,82,0,18,82,0,21,1,2,5,9,3,5,9,4,5,9,5,5,14,6,5,14,7,5,9,10,5,42,11,5,24,12,5,24,13,5,17,21,5,48,37,5,38,38,5,39,264],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,74,75,76,83,84,64],[4,4,4,4,11,4,-1,29,4,11,4,-1,29,4,11,4,4,19,-1,19,19,-1,19,4,4,11,11,-1,-2,-3,-1,-2,-3,-4,-5,4,4,4,-1,19,-1,19,-1,19,14,-1,-2,-3,-4,-5,-6,4,4,11,-1,-2,-3,-1,-2,27,27,11,20,20,11,20,20,20],[5,5,15,15,0,15,21,21,15,0,15,21,21,139,0,19,19,16,140,28,16,29,16,5,47,4,4,30,31,32,33,48,49,50,51,141,19,19,29,16,142,28,29,16,19,34,143,52,53,54,34,5,47,4,30,31,32,55,56,57,57,0,58,144,0,145,58,146]],[[[308,0,0.1]],0,0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[10],0,[0],[33],[147]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,3,3,0,0],"outterColor",8,[4,4290361855],"mainTexture",6,0,"outterTexture",6,1]],11]]],0,0,[0,0,0],[17,40,16],[59,59,10]],[[{"name":"T_JoystickPivot_A","rect":{"x":0,"y":0,"width":64,"height":64},"offset":{"x":0,"y":0},"originalSize":{"width":64,"height":64},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[10],0,[0],[33],[148]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"outterColor",8,[4,4286940549],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[149,10]],[[[54,"Canvas_Start"],[48,"Canvas_Start",33554432,[-702,-703,-704,-705,-706],[[5,-698,[1,"abuJjMuTVAyZeH2grfuwBV"],[5,414,896]],[129,-699,[1,"ccoI3YvmJFlJ1yHN/Tox6v"]],[66,45,-700,[1,"e1iv7FkOFHIa7B6UCRsaD7"]],[130,-701,[1,"f8N2P3chZGpqj6rkmcb9x7"]]],[174,"c0Gf4wU+xGbIXyFvJqa514",-697,0,[[2,["_states","0","onSetState","0","target"],-15,[0,["81VU5noKBCgp588aEIgZBx"]],-14,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],-17,[0,["81VU5noKBCgp588aEIgZBx"]],-16,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],-19,[0,["81VU5noKBCgp588aEIgZBx"]],-18,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],-21,[0,["81VU5noKBCgp588aEIgZBx"]],-20,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],-23,[0,["81VU5noKBCgp588aEIgZBx"]],-22,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],-25,[0,["81VU5noKBCgp588aEIgZBx"]],-24,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],-27,[0,["81VU5noKBCgp588aEIgZBx"]],-26,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],-29,[0,["81VU5noKBCgp588aEIgZBx"]],-28,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],-31,[0,["81VU5noKBCgp588aEIgZBx"]],-30,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],-33,[0,["81VU5noKBCgp588aEIgZBx"]],-32,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],-35,[0,["81VU5noKBCgp588aEIgZBx"]],-34,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],-37,[0,["81VU5noKBCgp588aEIgZBx"]],-36,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],-39,[0,["81VU5noKBCgp588aEIgZBx"]],-38,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],-41,[0,["81VU5noKBCgp588aEIgZBx"]],-40,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],-43,[0,["81VU5noKBCgp588aEIgZBx"]],-42,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],-45,[0,["81VU5noKBCgp588aEIgZBx"]],-44,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],-47,[0,["81VU5noKBCgp588aEIgZBx"]],-46,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],-49,[0,["81VU5noKBCgp588aEIgZBx"]],-48,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],-51,[0,["81VU5noKBCgp588aEIgZBx"]],-50,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],-53,[0,["81VU5noKBCgp588aEIgZBx"]],-52,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],-55,[0,["81VU5noKBCgp588aEIgZBx"]],-54,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],-57,[0,["81VU5noKBCgp588aEIgZBx"]],-56,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],-59,[0,["81VU5noKBCgp588aEIgZBx"]],-58,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],-61,[0,["81VU5noKBCgp588aEIgZBx"]],-60,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],-63,[0,["81VU5noKBCgp588aEIgZBx"]],-62,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],-65,[0,["81VU5noKBCgp588aEIgZBx"]],-64,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],-67,[0,["81VU5noKBCgp588aEIgZBx"]],-66,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],-69,[0,["81VU5noKBCgp588aEIgZBx"]],-68,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],-71,[0,["81VU5noKBCgp588aEIgZBx"]],-70,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],-73,[0,["81VU5noKBCgp588aEIgZBx"]],-72,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],-75,[0,["81VU5noKBCgp588aEIgZBx"]],-74,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],-77,[0,["81VU5noKBCgp588aEIgZBx"]],-76,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],-79,[0,["81VU5noKBCgp588aEIgZBx"]],-78,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],-81,[0,["81VU5noKBCgp588aEIgZBx"]],-80,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],-83,[0,["81VU5noKBCgp588aEIgZBx"]],-82,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],-85,[0,["81VU5noKBCgp588aEIgZBx"]],-84,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],-87,[0,["81VU5noKBCgp588aEIgZBx"]],-86,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],-89,[0,["81VU5noKBCgp588aEIgZBx"]],-88,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],-91,[0,["81VU5noKBCgp588aEIgZBx"]],-90,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],-93,[0,["81VU5noKBCgp588aEIgZBx"]],-92,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],-95,[0,["81VU5noKBCgp588aEIgZBx"]],-94,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],-97,[0,["81VU5noKBCgp588aEIgZBx"]],-96,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],-99,[0,["81VU5noKBCgp588aEIgZBx"]],-98,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],-101,[0,["81VU5noKBCgp588aEIgZBx"]],-100,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],-103,[0,["81VU5noKBCgp588aEIgZBx"]],-102,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],-105,[0,["81VU5noKBCgp588aEIgZBx"]],-104,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],-107,[0,["81VU5noKBCgp588aEIgZBx"]],-106,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],-109,[0,["81VU5noKBCgp588aEIgZBx"]],-108,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],-111,[0,["81VU5noKBCgp588aEIgZBx"]],-110,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],-113,[0,["81VU5noKBCgp588aEIgZBx"]],-112,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],-115,[0,["81VU5noKBCgp588aEIgZBx"]],-114,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],-117,[0,["81VU5noKBCgp588aEIgZBx"]],-116,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],-119,[0,["81VU5noKBCgp588aEIgZBx"]],-118,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],-121,[0,["81VU5noKBCgp588aEIgZBx"]],-120,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],-123,[0,["81VU5noKBCgp588aEIgZBx"]],-122,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],-125,[0,["81VU5noKBCgp588aEIgZBx"]],-124,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","0","target"],-127,[0,["0bWPbJX8RH7awiNvx1sojn"]],-126,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],-129,[0,["0bWPbJX8RH7awiNvx1sojn"]],-128,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],-131,[0,["0bWPbJX8RH7awiNvx1sojn"]],-130,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],-133,[0,["0bWPbJX8RH7awiNvx1sojn"]],-132,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],-135,[0,["0bWPbJX8RH7awiNvx1sojn"]],-134,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],-137,[0,["0bWPbJX8RH7awiNvx1sojn"]],-136,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],-139,[0,["0bWPbJX8RH7awiNvx1sojn"]],-138,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],-141,[0,["0bWPbJX8RH7awiNvx1sojn"]],-140,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],-143,[0,["0bWPbJX8RH7awiNvx1sojn"]],-142,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],-145,[0,["0bWPbJX8RH7awiNvx1sojn"]],-144,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],-147,[0,["0bWPbJX8RH7awiNvx1sojn"]],-146,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],-149,[0,["0bWPbJX8RH7awiNvx1sojn"]],-148,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],-151,[0,["0bWPbJX8RH7awiNvx1sojn"]],-150,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],-153,[0,["0bWPbJX8RH7awiNvx1sojn"]],-152,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],-155,[0,["0bWPbJX8RH7awiNvx1sojn"]],-154,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],-157,[0,["0bWPbJX8RH7awiNvx1sojn"]],-156,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],-159,[0,["0bWPbJX8RH7awiNvx1sojn"]],-158,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],-161,[0,["0bWPbJX8RH7awiNvx1sojn"]],-160,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],-163,[0,["0bWPbJX8RH7awiNvx1sojn"]],-162,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],-165,[0,["0bWPbJX8RH7awiNvx1sojn"]],-164,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],-167,[0,["0bWPbJX8RH7awiNvx1sojn"]],-166,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],-169,[0,["0bWPbJX8RH7awiNvx1sojn"]],-168,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],-171,[0,["0bWPbJX8RH7awiNvx1sojn"]],-170,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],-173,[0,["0bWPbJX8RH7awiNvx1sojn"]],-172,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],-175,[0,["0bWPbJX8RH7awiNvx1sojn"]],-174,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],-177,[0,["0bWPbJX8RH7awiNvx1sojn"]],-176,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],-179,[0,["0bWPbJX8RH7awiNvx1sojn"]],-178,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],-181,[0,["0bWPbJX8RH7awiNvx1sojn"]],-180,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],-183,[0,["0bWPbJX8RH7awiNvx1sojn"]],-182,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],-185,[0,["0bWPbJX8RH7awiNvx1sojn"]],-184,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],-187,[0,["0bWPbJX8RH7awiNvx1sojn"]],-186,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],-189,[0,["0bWPbJX8RH7awiNvx1sojn"]],-188,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],-191,[0,["0bWPbJX8RH7awiNvx1sojn"]],-190,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],-193,[0,["0bWPbJX8RH7awiNvx1sojn"]],-192,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],-195,[0,["0bWPbJX8RH7awiNvx1sojn"]],-194,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],-197,[0,["0bWPbJX8RH7awiNvx1sojn"]],-196,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],-199,[0,["0bWPbJX8RH7awiNvx1sojn"]],-198,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],-201,[0,["0bWPbJX8RH7awiNvx1sojn"]],-200,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],-203,[0,["0bWPbJX8RH7awiNvx1sojn"]],-202,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],-205,[0,["0bWPbJX8RH7awiNvx1sojn"]],-204,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],-207,[0,["0bWPbJX8RH7awiNvx1sojn"]],-206,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],-209,[0,["0bWPbJX8RH7awiNvx1sojn"]],-208,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],-211,[0,["0bWPbJX8RH7awiNvx1sojn"]],-210,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","0","onSetState","1","target"],-213,[0,["0bWPbJX8RH7awiNvx1sojn"]],-212,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-215,[0,["0bWPbJX8RH7awiNvx1sojn"]],-214,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-217,[0,["0bWPbJX8RH7awiNvx1sojn"]],-216,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-219,[0,["0bWPbJX8RH7awiNvx1sojn"]],-218,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","0","target"],-221,[0,["0bWPbJX8RH7awiNvx1sojn"]],-220,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","1","onSetState","1","target"],-223,[0,["0bWPbJX8RH7awiNvx1sojn"]],-222,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-225,[0,["0bWPbJX8RH7awiNvx1sojn"]],-224,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-227,[0,["0bWPbJX8RH7awiNvx1sojn"]],-226,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-229,[0,["0bWPbJX8RH7awiNvx1sojn"]],-228,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","0","target"],-231,[0,["0bWPbJX8RH7awiNvx1sojn"]],-230,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","2","onSetState","1","target"],-233,[0,["0bWPbJX8RH7awiNvx1sojn"]],-232,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-235,[0,["0bWPbJX8RH7awiNvx1sojn"]],-234,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-237,[0,["0bWPbJX8RH7awiNvx1sojn"]],-236,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-239,[0,["0bWPbJX8RH7awiNvx1sojn"]],-238,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-241,[0,["0bWPbJX8RH7awiNvx1sojn"]],-240,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","0","target"],-243,[0,["0bWPbJX8RH7awiNvx1sojn"]],-242,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","3","onSetState","1","target"],-245,[0,["0bWPbJX8RH7awiNvx1sojn"]],-244,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-247,[0,["0bWPbJX8RH7awiNvx1sojn"]],-246,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-249,[0,["0bWPbJX8RH7awiNvx1sojn"]],-248,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-251,[0,["0bWPbJX8RH7awiNvx1sojn"]],-250,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-253,[0,["0bWPbJX8RH7awiNvx1sojn"]],-252,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","0","target"],-255,[0,["0bWPbJX8RH7awiNvx1sojn"]],-254,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","4","onSetState","1","target"],-257,[0,["0bWPbJX8RH7awiNvx1sojn"]],-256,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-259,[0,["0bWPbJX8RH7awiNvx1sojn"]],-258,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-261,[0,["0bWPbJX8RH7awiNvx1sojn"]],-260,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-263,[0,["0bWPbJX8RH7awiNvx1sojn"]],-262,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-265,[0,["0bWPbJX8RH7awiNvx1sojn"]],-264,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","0","target"],-267,[0,["0bWPbJX8RH7awiNvx1sojn"]],-266,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","5","onSetState","1","target"],-269,[0,["0bWPbJX8RH7awiNvx1sojn"]],-268,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-271,[0,["0bWPbJX8RH7awiNvx1sojn"]],-270,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-273,[0,["0bWPbJX8RH7awiNvx1sojn"]],-272,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-275,[0,["0bWPbJX8RH7awiNvx1sojn"]],-274,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-277,[0,["0bWPbJX8RH7awiNvx1sojn"]],-276,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-279,[0,["0bWPbJX8RH7awiNvx1sojn"]],-278,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],-281,[0,["0bWPbJX8RH7awiNvx1sojn"]],-280,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-283,[0,["0bWPbJX8RH7awiNvx1sojn"]],-282,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-285,[0,["0bWPbJX8RH7awiNvx1sojn"]],-284,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-287,[0,["0bWPbJX8RH7awiNvx1sojn"]],-286,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],-289,[0,["0bWPbJX8RH7awiNvx1sojn"]],-288,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-291,[0,["0bWPbJX8RH7awiNvx1sojn"]],-290,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-293,[0,["0bWPbJX8RH7awiNvx1sojn"]],-292,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-295,[0,["0bWPbJX8RH7awiNvx1sojn"]],-294,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],-297,[0,["0bWPbJX8RH7awiNvx1sojn"]],-296,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-299,[0,["0bWPbJX8RH7awiNvx1sojn"]],-298,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-301,[0,["0bWPbJX8RH7awiNvx1sojn"]],-300,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-303,[0,["0bWPbJX8RH7awiNvx1sojn"]],-302,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-305,[0,["0bWPbJX8RH7awiNvx1sojn"]],-304,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],-307,[0,["0bWPbJX8RH7awiNvx1sojn"]],-306,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-309,[0,["0bWPbJX8RH7awiNvx1sojn"]],-308,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-311,[0,["0bWPbJX8RH7awiNvx1sojn"]],-310,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-313,[0,["0bWPbJX8RH7awiNvx1sojn"]],-312,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-315,[0,["0bWPbJX8RH7awiNvx1sojn"]],-314,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],-317,[0,["0bWPbJX8RH7awiNvx1sojn"]],-316,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-319,[0,["0bWPbJX8RH7awiNvx1sojn"]],-318,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-321,[0,["0bWPbJX8RH7awiNvx1sojn"]],-320,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-323,[0,["0bWPbJX8RH7awiNvx1sojn"]],-322,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-325,[0,["0bWPbJX8RH7awiNvx1sojn"]],-324,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],-327,[0,["0bWPbJX8RH7awiNvx1sojn"]],-326,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-329,[0,["0bWPbJX8RH7awiNvx1sojn"]],-328,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-331,[0,["0bWPbJX8RH7awiNvx1sojn"]],-330,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-333,[0,["0bWPbJX8RH7awiNvx1sojn"]],-332,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-335,[0,["0bWPbJX8RH7awiNvx1sojn"]],-334,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-337,[0,["0bWPbJX8RH7awiNvx1sojn"]],-336,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],-339,[0,["0bWPbJX8RH7awiNvx1sojn"]],-338,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-341,[0,["0bWPbJX8RH7awiNvx1sojn"]],-340,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-343,[0,["0bWPbJX8RH7awiNvx1sojn"]],-342,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-345,[0,["0bWPbJX8RH7awiNvx1sojn"]],-344,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],-347,[0,["0bWPbJX8RH7awiNvx1sojn"]],-346,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-349,[0,["0bWPbJX8RH7awiNvx1sojn"]],-348,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-351,[0,["0bWPbJX8RH7awiNvx1sojn"]],-350,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-353,[0,["0bWPbJX8RH7awiNvx1sojn"]],-352,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],-355,[0,["0bWPbJX8RH7awiNvx1sojn"]],-354,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-357,[0,["0bWPbJX8RH7awiNvx1sojn"]],-356,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-359,[0,["0bWPbJX8RH7awiNvx1sojn"]],-358,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-361,[0,["0bWPbJX8RH7awiNvx1sojn"]],-360,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-363,[0,["0bWPbJX8RH7awiNvx1sojn"]],-362,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],-365,[0,["0bWPbJX8RH7awiNvx1sojn"]],-364,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-367,[0,["0bWPbJX8RH7awiNvx1sojn"]],-366,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-369,[0,["0bWPbJX8RH7awiNvx1sojn"]],-368,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-371,[0,["0bWPbJX8RH7awiNvx1sojn"]],-370,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-373,[0,["0bWPbJX8RH7awiNvx1sojn"]],-372,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],-375,[0,["0bWPbJX8RH7awiNvx1sojn"]],-374,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-377,[0,["0bWPbJX8RH7awiNvx1sojn"]],-376,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-379,[0,["0bWPbJX8RH7awiNvx1sojn"]],-378,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-381,[0,["0bWPbJX8RH7awiNvx1sojn"]],-380,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-383,[0,["0bWPbJX8RH7awiNvx1sojn"]],-382,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],-385,[0,["0bWPbJX8RH7awiNvx1sojn"]],-384,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-387,[0,["0bWPbJX8RH7awiNvx1sojn"]],-386,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-389,[0,["0bWPbJX8RH7awiNvx1sojn"]],-388,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-391,[0,["0bWPbJX8RH7awiNvx1sojn"]],-390,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-393,[0,["0bWPbJX8RH7awiNvx1sojn"]],-392,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-395,[0,["0bWPbJX8RH7awiNvx1sojn"]],-394,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],-397,[0,["0bWPbJX8RH7awiNvx1sojn"]],-396,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-399,[0,["0bWPbJX8RH7awiNvx1sojn"]],-398,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-401,[0,["0bWPbJX8RH7awiNvx1sojn"]],-400,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-403,[0,["0bWPbJX8RH7awiNvx1sojn"]],-402,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],-405,[0,["0bWPbJX8RH7awiNvx1sojn"]],-404,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-407,[0,["0bWPbJX8RH7awiNvx1sojn"]],-406,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-409,[0,["0bWPbJX8RH7awiNvx1sojn"]],-408,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-411,[0,["0bWPbJX8RH7awiNvx1sojn"]],-410,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],-413,[0,["0bWPbJX8RH7awiNvx1sojn"]],-412,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-415,[0,["0bWPbJX8RH7awiNvx1sojn"]],-414,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-417,[0,["0bWPbJX8RH7awiNvx1sojn"]],-416,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-419,[0,["0bWPbJX8RH7awiNvx1sojn"]],-418,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-421,[0,["0bWPbJX8RH7awiNvx1sojn"]],-420,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],-423,[0,["0bWPbJX8RH7awiNvx1sojn"]],-422,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-425,[0,["0bWPbJX8RH7awiNvx1sojn"]],-424,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-427,[0,["0bWPbJX8RH7awiNvx1sojn"]],-426,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-429,[0,["0bWPbJX8RH7awiNvx1sojn"]],-428,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-431,[0,["0bWPbJX8RH7awiNvx1sojn"]],-430,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],-433,[0,["0bWPbJX8RH7awiNvx1sojn"]],-432,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-435,[0,["0bWPbJX8RH7awiNvx1sojn"]],-434,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-437,[0,["0bWPbJX8RH7awiNvx1sojn"]],-436,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-439,[0,["0bWPbJX8RH7awiNvx1sojn"]],-438,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-441,[0,["0bWPbJX8RH7awiNvx1sojn"]],-440,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],-443,[0,["0bWPbJX8RH7awiNvx1sojn"]],-442,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-445,[0,["0bWPbJX8RH7awiNvx1sojn"]],-444,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-447,[0,["0bWPbJX8RH7awiNvx1sojn"]],-446,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-449,[0,["0bWPbJX8RH7awiNvx1sojn"]],-448,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-451,[0,["0bWPbJX8RH7awiNvx1sojn"]],-450,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-453,[0,["0bWPbJX8RH7awiNvx1sojn"]],-452,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],-455,[0,["0bWPbJX8RH7awiNvx1sojn"]],-454,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-457,[0,["0bWPbJX8RH7awiNvx1sojn"]],-456,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-459,[0,["0bWPbJX8RH7awiNvx1sojn"]],-458,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-461,[0,["0bWPbJX8RH7awiNvx1sojn"]],-460,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],-463,[0,["0bWPbJX8RH7awiNvx1sojn"]],-462,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-465,[0,["0bWPbJX8RH7awiNvx1sojn"]],-464,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-467,[0,["0bWPbJX8RH7awiNvx1sojn"]],-466,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-469,[0,["0bWPbJX8RH7awiNvx1sojn"]],-468,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],-471,[0,["0bWPbJX8RH7awiNvx1sojn"]],-470,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-473,[0,["0bWPbJX8RH7awiNvx1sojn"]],-472,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-475,[0,["0bWPbJX8RH7awiNvx1sojn"]],-474,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-477,[0,["0bWPbJX8RH7awiNvx1sojn"]],-476,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-479,[0,["0bWPbJX8RH7awiNvx1sojn"]],-478,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],-481,[0,["0bWPbJX8RH7awiNvx1sojn"]],-480,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-483,[0,["0bWPbJX8RH7awiNvx1sojn"]],-482,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-485,[0,["0bWPbJX8RH7awiNvx1sojn"]],-484,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-487,[0,["0bWPbJX8RH7awiNvx1sojn"]],-486,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-489,[0,["0bWPbJX8RH7awiNvx1sojn"]],-488,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],-491,[0,["0bWPbJX8RH7awiNvx1sojn"]],-490,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-493,[0,["0bWPbJX8RH7awiNvx1sojn"]],-492,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-495,[0,["0bWPbJX8RH7awiNvx1sojn"]],-494,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-497,[0,["0bWPbJX8RH7awiNvx1sojn"]],-496,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-499,[0,["0bWPbJX8RH7awiNvx1sojn"]],-498,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],-501,[0,["0bWPbJX8RH7awiNvx1sojn"]],-500,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-503,[0,["0bWPbJX8RH7awiNvx1sojn"]],-502,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-505,[0,["0bWPbJX8RH7awiNvx1sojn"]],-504,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-507,[0,["0bWPbJX8RH7awiNvx1sojn"]],-506,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-509,[0,["0bWPbJX8RH7awiNvx1sojn"]],-508,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-511,[0,["0bWPbJX8RH7awiNvx1sojn"]],-510,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],-513,[0,["0bWPbJX8RH7awiNvx1sojn"]],-512,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-515,[0,["0bWPbJX8RH7awiNvx1sojn"]],-514,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-517,[0,["0bWPbJX8RH7awiNvx1sojn"]],-516,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-519,[0,["0bWPbJX8RH7awiNvx1sojn"]],-518,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],-521,[0,["0bWPbJX8RH7awiNvx1sojn"]],-520,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-523,[0,["0bWPbJX8RH7awiNvx1sojn"]],-522,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-525,[0,["0bWPbJX8RH7awiNvx1sojn"]],-524,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-527,[0,["0bWPbJX8RH7awiNvx1sojn"]],-526,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],-529,[0,["0bWPbJX8RH7awiNvx1sojn"]],-528,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-531,[0,["0bWPbJX8RH7awiNvx1sojn"]],-530,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-533,[0,["0bWPbJX8RH7awiNvx1sojn"]],-532,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-535,[0,["0bWPbJX8RH7awiNvx1sojn"]],-534,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-537,[0,["0bWPbJX8RH7awiNvx1sojn"]],-536,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],-539,[0,["0bWPbJX8RH7awiNvx1sojn"]],-538,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-541,[0,["0bWPbJX8RH7awiNvx1sojn"]],-540,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-543,[0,["0bWPbJX8RH7awiNvx1sojn"]],-542,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-545,[0,["0bWPbJX8RH7awiNvx1sojn"]],-544,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-547,[0,["0bWPbJX8RH7awiNvx1sojn"]],-546,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],-549,[0,["0bWPbJX8RH7awiNvx1sojn"]],-548,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-551,[0,["0bWPbJX8RH7awiNvx1sojn"]],-550,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-553,[0,["0bWPbJX8RH7awiNvx1sojn"]],-552,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-555,[0,["0bWPbJX8RH7awiNvx1sojn"]],-554,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-557,[0,["0bWPbJX8RH7awiNvx1sojn"]],-556,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],-559,[0,["0bWPbJX8RH7awiNvx1sojn"]],-558,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-561,[0,["0bWPbJX8RH7awiNvx1sojn"]],-560,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-563,[0,["0bWPbJX8RH7awiNvx1sojn"]],-562,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-565,[0,["0bWPbJX8RH7awiNvx1sojn"]],-564,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-567,[0,["0bWPbJX8RH7awiNvx1sojn"]],-566,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-569,[0,["0bWPbJX8RH7awiNvx1sojn"]],-568,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],-571,[0,["0bWPbJX8RH7awiNvx1sojn"]],-570,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-573,[0,["0bWPbJX8RH7awiNvx1sojn"]],-572,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-575,[0,["0bWPbJX8RH7awiNvx1sojn"]],-574,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-577,[0,["0bWPbJX8RH7awiNvx1sojn"]],-576,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],-579,[0,["0bWPbJX8RH7awiNvx1sojn"]],-578,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-581,[0,["0bWPbJX8RH7awiNvx1sojn"]],-580,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-583,[0,["0bWPbJX8RH7awiNvx1sojn"]],-582,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-585,[0,["0bWPbJX8RH7awiNvx1sojn"]],-584,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],-587,[0,["0bWPbJX8RH7awiNvx1sojn"]],-586,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-589,[0,["0bWPbJX8RH7awiNvx1sojn"]],-588,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-591,[0,["0bWPbJX8RH7awiNvx1sojn"]],-590,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-593,[0,["0bWPbJX8RH7awiNvx1sojn"]],-592,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-595,[0,["0bWPbJX8RH7awiNvx1sojn"]],-594,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],-597,[0,["0bWPbJX8RH7awiNvx1sojn"]],-596,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-599,[0,["0bWPbJX8RH7awiNvx1sojn"]],-598,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-601,[0,["0bWPbJX8RH7awiNvx1sojn"]],-600,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-603,[0,["0bWPbJX8RH7awiNvx1sojn"]],-602,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-605,[0,["0bWPbJX8RH7awiNvx1sojn"]],-604,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],-607,[0,["0bWPbJX8RH7awiNvx1sojn"]],-606,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-609,[0,["0bWPbJX8RH7awiNvx1sojn"]],-608,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-611,[0,["0bWPbJX8RH7awiNvx1sojn"]],-610,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-613,[0,["0bWPbJX8RH7awiNvx1sojn"]],-612,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-615,[0,["0bWPbJX8RH7awiNvx1sojn"]],-614,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],-617,[0,["0bWPbJX8RH7awiNvx1sojn"]],-616,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-619,[0,["0bWPbJX8RH7awiNvx1sojn"]],-618,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-621,[0,["0bWPbJX8RH7awiNvx1sojn"]],-620,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-623,[0,["0bWPbJX8RH7awiNvx1sojn"]],-622,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-625,[0,["0bWPbJX8RH7awiNvx1sojn"]],-624,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-627,[0,["0bWPbJX8RH7awiNvx1sojn"]],-626,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],-629,[0,["0bWPbJX8RH7awiNvx1sojn"]],-628,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],-631,[0,["0bWPbJX8RH7awiNvx1sojn"]],-630,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],-633,[0,["0bWPbJX8RH7awiNvx1sojn"]],-632,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],-635,[0,["0bWPbJX8RH7awiNvx1sojn"]],-634,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],-637,[0,["0bWPbJX8RH7awiNvx1sojn"]],-636,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],-639,[0,["0bWPbJX8RH7awiNvx1sojn"]],-638,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],-641,[0,["0bWPbJX8RH7awiNvx1sojn"]],-640,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],-643,[0,["0bWPbJX8RH7awiNvx1sojn"]],-642,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],-645,[0,["0bWPbJX8RH7awiNvx1sojn"]],-644,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],-647,[0,["0bWPbJX8RH7awiNvx1sojn"]],-646,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],-649,[0,["0bWPbJX8RH7awiNvx1sojn"]],-648,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],-651,[0,["0bWPbJX8RH7awiNvx1sojn"]],-650,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],-653,[0,["0bWPbJX8RH7awiNvx1sojn"]],-652,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],-655,[0,["0bWPbJX8RH7awiNvx1sojn"]],-654,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],-657,[0,["0bWPbJX8RH7awiNvx1sojn"]],-656,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],-659,[0,["0bWPbJX8RH7awiNvx1sojn"]],-658,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],-661,[0,["0bWPbJX8RH7awiNvx1sojn"]],-660,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],-663,[0,["0bWPbJX8RH7awiNvx1sojn"]],-662,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],-665,[0,["0bWPbJX8RH7awiNvx1sojn"]],-664,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],-667,[0,["0bWPbJX8RH7awiNvx1sojn"]],-666,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],-669,[0,["0bWPbJX8RH7awiNvx1sojn"]],-668,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],-671,[0,["0bWPbJX8RH7awiNvx1sojn"]],-670,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],-673,[0,["0bWPbJX8RH7awiNvx1sojn"]],-672,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],-675,[0,["0bWPbJX8RH7awiNvx1sojn"]],-674,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],-677,[0,["0bWPbJX8RH7awiNvx1sojn"]],-676,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],-679,[0,["0bWPbJX8RH7awiNvx1sojn"]],-678,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],-681,[0,["0bWPbJX8RH7awiNvx1sojn"]],-680,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],-683,[0,["0bWPbJX8RH7awiNvx1sojn"]],-682,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],-685,[0,["0bWPbJX8RH7awiNvx1sojn"]],-684,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[67,["_missionEntries","0"],-686,[0,["9aYImQxz1C2qqP21T/n86m"]]],[67,["_missionEntries","1"],-687,[0,["9aYImQxz1C2qqP21T/n86m"]]],[67,["_missionEntries","2"],-688,[0,["9aYImQxz1C2qqP21T/n86m"]]],[107,["_missionEntries","0"],-690,-689,[0,["9aYImQxz1C2qqP21T/n86m"]]],[107,["_missionEntries","1"],-692,-691,[0,["9aYImQxz1C2qqP21T/n86m"]]],[107,["_missionEntries","2"],-694,-693,[0,["9aYImQxz1C2qqP21T/n86m"]]],[107,["_anim"],-696,-695,[0,["4b9lnAZ2xFqoPsW5jLpiuK"]]]],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13]],[1,207,448,0]],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-754,[38,"824amZy+RHKoqPW8uk6q6o",1,[[7,"Slime_02",["_name"],-707],[12,["_lpos"],-708,[1,-32,0,0]],[12,["_lrot"],-709,[3,0,0,0,1]],[12,["_euler"],-710,[1,0,0,0]],[14,"1",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,1,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,1,["_textureID"],-711],[7,4,["_iconTextures","length"],-712],[13,["_iconTextures","0"],-713,44],[13,["_iconTextures","1"],-714,45],[13,["_iconTextures","2"],-715,46],[13,["_iconTextures","3"],-716,47],[7,null,["_iconTextures","4"],-717],[7,null,["_iconTextures","5"],-718],[7,null,["_iconTextures","6"],-719],[7,null,["_iconTextures","7"],-720],[7,null,["_iconTextures","8"],-721],[7,null,["_iconTextures","9"],-722],[7,null,["_iconTextures","10"],-723],[7,null,["_iconTextures","11"],-724],[7,null,["_iconTextures","12"],-725],[7,null,["_iconTextures","13"],-726],[7,null,["_iconTextures","14"],-727],[7,null,["_iconTextures","15"],-728],[7,null,["_iconTextures","16"],-729],[7,null,["_iconTextures","17"],-730],[7,null,["_iconTextures","18"],-731],[7,null,["_iconTextures","19"],-732],[7,null,["_iconTextures","20"],-733],[7,null,["_iconTextures","21"],-734],[7,null,["_iconTextures","22"],-735],[7,null,["_iconTextures","23"],-736],[7,null,["_iconTextures","24"],-737],[7,null,["_iconTextures","25"],-738],[7,null,["_iconTextures","26"],-739],[7,null,["_iconTextures","27"],-740],[7,null,["_iconTextures","28"],-741],[7,null,["_iconTextures","29"],-742],[7,null,["_iconTextures","30"],-743],[7,null,["_iconTextures","31"],-744],[7,null,["_iconTextures","32"],-745],[7,null,["_iconTextures","33"],-746],[7,null,["_iconTextures","34"],-747],[7,null,["_iconTextures","35"],-748],[7,null,["_iconTextures","36"],-749],[7,null,["_iconTextures","37"],-750],[7,null,["_iconTextures","38"],-751],[7,null,["_iconTextures","39"],-752],[7,null,["_iconTextures","40"],-753]]],43]],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-764,[38,"a2ofGOsYtC6IX8DWpup88Q",1,[[7,"Slime_03",["_name"],-755],[12,["_lpos"],-756,[1,30,0,0]],[12,["_lrot"],-757,[3,0,0,0,1]],[12,["_euler"],-758,[1,0,0,0]],[13,["_iconTextures","0"],-759,49],[7,4,["_iconTextures","length"],-760],[13,["_iconTextures","1"],-761,50],[13,["_iconTextures","2"],-762,51],[13,["_iconTextures","3"],-763,52]]],48]],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-770,[38,"6eBZGCeihBnYFbMbgkpiRM",1,[[14,"Slime_04",["_name"],[0,["cdSEaiObZBOIHsO1usqOZf"]]],[23,["_lpos"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,92,0,0]],[23,["_lrot"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[3,0,0,0,1]],[23,["_euler"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,0,0,0]],[14,3,["_textureID"],[0,["0bWPbJX8RH7awiNvx1sojn"]]],[13,["_iconTextures","0"],-765,54],[13,["_iconTextures","1"],-766,55],[13,["_iconTextures","2"],-767,56],[13,["_iconTextures","3"],-768,57],[7,4,["_iconTextures","length"],-769]]],53]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-781,[38,"4excq5lYZIbqGOoKRp2GIj",1,[[7,"SlimeButton_01",["_name"],-771],[12,["_lpos"],-772,[1,-94,0,0]],[12,["_lrot"],-773,[3,0,0,0,1]],[12,["_euler"],-774,[1,0,0,0]],[14,"4",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,4,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,4,["_textureID"],-775],[7,4,["_iconTextures","length"],-776],[13,["_iconTextures","0"],-777,59],[13,["_iconTextures","1"],-778,60],[13,["_iconTextures","2"],-779,61],[13,["_iconTextures","3"],-780,62]]],58]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-792,[38,"d2bcEn49FApYkpzepqGTL7",1,[[7,"SlimeButton_02",["_name"],-782],[12,["_lpos"],-783,[1,-32,0,0]],[12,["_lrot"],-784,[3,0,0,0,1]],[12,["_euler"],-785,[1,0,0,0]],[14,"5",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,5,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,5,["_textureID"],-786],[7,4,["_iconTextures","length"],-787],[13,["_iconTextures","0"],-788,64],[13,["_iconTextures","1"],-789,65],[13,["_iconTextures","2"],-790,66],[13,["_iconTextures","3"],-791,67]]],63]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-803,[38,"44Ig17Fz1AxYDgu8rZAHM/",1,[[7,"SlimeButton_03",["_name"],-793],[12,["_lpos"],-794,[1,30,0,0]],[12,["_lrot"],-795,[3,0,0,0,1]],[12,["_euler"],-796,[1,0,0,0]],[14,"6",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,6,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,6,["_textureID"],-797],[7,4,["_iconTextures","length"],-798],[13,["_iconTextures","0"],-799,69],[13,["_iconTextures","1"],-800,70],[13,["_iconTextures","2"],-801,71],[13,["_iconTextures","3"],-802,72]]],68]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-814,[38,"a4t33cSwlFuph8i/gOjz1P",1,[[7,"SlimeButton_04",["_name"],-804],[12,["_lpos"],-805,[1,92,0,0]],[12,["_lrot"],-806,[3,0,0,0,1]],[12,["_euler"],-807,[1,0,0,0]],[14,"7",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,7,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,7,["_textureID"],-808],[7,4,["_iconTextures","length"],-809],[13,["_iconTextures","0"],-810,74],[13,["_iconTextures","1"],-811,75],[13,["_iconTextures","2"],-812,76],[13,["_iconTextures","3"],-813,77]]],73]],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-817,[38,"c4XQqIruFKhavqAzSlEINe",1,[[14,"Slime_01",["_name"],[0,["cdSEaiObZBOIHsO1usqOZf"]]],[23,["_lpos"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,-94,0,0]],[23,["_lrot"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[3,0,0,0,1]],[23,["_euler"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,0,0,0]],[14,"0",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,true,["_active"],[0,["a9ZGpF4KJAiL0ztiE2eQ3i"]]],[14,0.7,["_alphaThreshold"],[0,["80o2WsLwFMvpogdgoXBNPI"]]],[14,4,["_iconTextures","length"],[0,["0bWPbJX8RH7awiNvx1sojn"]]],[99,["_iconTextures","0"],[0,["0bWPbJX8RH7awiNvx1sojn"]],39],[99,["_iconTextures","1"],[0,["0bWPbJX8RH7awiNvx1sojn"]],40],[99,["_iconTextures","2"],[0,["0bWPbJX8RH7awiNvx1sojn"]],41],[13,["_iconTextures","3"],-815,42],[14,false,["_enabled"],[0,["eb9r9ISWBJ2YZXxulicMaQ"]]],[7,0,["_textureID"],-816]]],38]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[48,"Button_Play",33554432,[-834],[[5,-818,[1,"d2qjmPL09Ez7DNN+zgktZm"],[5,120,120]],[145,18,-250,-820,[1,"a9AnY1vMxKwZUUFbEBu+WF"],-819],[31,0,-821,[1,"0eZNYzag9Ber93JjvxCRRK"],[4,4292667899],17],[280,false,3,0.9,-829,[1,"ff2s5UfNtKZ5Sv7Wied3G8"],[[6,"f964aRkVl1H94vry3UKRWOf","raise",-823],[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","playButtonClick",-824],[6,"33fbfvcKCVKi5q8DCetaVL+","raise",-825],[6,"c220ezwrChLSYwuQOQF0brq","deactivate",-826],[6,"ac879rTendCEbpZWFz/jexs","playSFX",-827],[27,"37b85WpHzdBn41+pXJNQa6l","setBool","active,false",-828]],[4,4292269782],-822,18],[309,"menu-start-clicked",-830,[1,"b9CpwytRtIuKhxJfDG4JFL"]],[310,-831,[1,"e2z//1stdMfJCQsm4J3zs+"]],[77,-832,[1,"73DN6ve+JLXqjJahy3Me3P"],19],[311,-833,[1,"0cFeXdy/dChJZQTmhO4QXu"]]],[3,"1bqL4+ZwpJzJ7DgN8BuUv1",1,0],[1,0,-250,0]],[61,"Panel_Color",33554432,[-839,-840,-841,-842,-843,-844,-845,-846,-847],[[17,-835,[1,"ae3tR4bo9B+L2Ux0j/+uHe"],[5,414,5000],[0,0.5,0]],[31,0,-836,[1,"60LE1uwg9JF621QB5FmSev"],[4,4292667899],126],[92,44,40,1,-837,[1,"59jX18AXZDq7lF1hh1hn5G"]],[218,-838,[1,"fd3sI5hG1EFqeG73d/AOEq"]]],[3,"88MHEDuY9CX7Qe1PIGc/DE",1,0]],[239,"Button_Unlock",false,33554432,12,[-858,-859,-860],[[[5,-848,[1,"d11WtzkeNDRYnE5CI0gLi9"],[5,180,44]],[29,1,0,-849,[1,"bd1OOIRcJPVZ+V6VtEOTi4"],[4,4278951533],31],[281,0.99,-853,[1,"c6Aro1yehLJbpzAsUWRaQM"],[[6,"ac879rTendCEbpZWFz/jexs","playSFX",-851],[6,"85d1aSv1CpM1q1iP4fDFUa4","clicked",-852]],[4,4292269782],-850,32],[182,1,130,152.546,44,1,-854,[1,"61SxgIsw5Ojp75kTUbabl9"]],[56,false,-855,[1,"9fNwsXt6NCLaJXQuD9TiLc"],[33,34,35,36,37]],-856,[57,-857,[1,"afbU33K7ZCH5Ooq5MsWMyr"]]],4,4,4,4,4,1,4],[3,"0cXPS2ouRBb5Iy3oEh+FXr",1,0],[1,0,-72,0]],[62,"Button_Back",false,33554432,12,[-872,-873],[[5,-861,[1,"a8xklZe+JAfbSm+1ZbSwGd"],[5,140,44]],[29,1,0,-862,[1,"d9/S3YzahM6og2RHPYQFYn"],[4,4279794659],118],[150,3,0.8,-868,[1,"db0Ebu/9tBloPShBEJ1wJ0"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","backButtonClick",-864],[6,"ac879rTendCEbpZWFz/jexs","playSFX",-865],[6,"d9040g5wUZNv41Fw6BiBXaR","closeSkinSelectionPanel",-866],[6,"ee672Nx9tRB+7fZZHkbEdII","raise",-867]],[4,4292269782],-863,119],[83,4,38,1,-869,[1,"25u22j1ndJH4t5t676mjTW"]],[77,-870,[1,"ab2ea11gtOYIqLwtlDHDco"],120],[312,3,-871,[1,"b745fXE29CoJArf6wBA50A"]]],[3,"5fQPO/ZeVK36eF3p+R+LRL",1,0],[1,0,60,0]],[48,"Group_Top Panel",33554432,[-876,-877,-878,-879,-880,-881],[[17,-874,[1,"80vMPv/VxANqMgVLxMKi/q"],[5,414,100],[0,0.5,1]],[125,41,100,-875,[1,"77rhsokGdIXqGxJyM1vv/v"]]],[3,"a5kFuoBWNN2J/RN1gowwk4",1,0],[1,0,448,0]],[43,"Menu Animation Helper",33554432,[[8,-882,[1,"58bo35sJpMXZLnDysBGIV+"]],[76,-884,[1,"49D38crGtMnINWDLeT7Kih"],-883]],[3,"52qbE7OrxJl4ftWh2MUE+N",1,0]],[22,"UI_Currency Panel",33554432,15,[-894,-895],[[183,33,28,22,20,840,300,36,1,-885,[1,"27zwXxgKxJ3rQIBbrrEJyJ"],15],[17,-886,[1,"e7Ak36Vs5Jk6sw1/R4SLWx"],[5,140,26],[0,1,1]],[29,1,0,-887,[1,"56bzG3nYhL+LQSpL+xfqVw"],[4,4292667899],4],[313,-889,[1,"49gXgZlxBMgqfFDa3dRw23"],-888],[219,-892,[1,"d9zv9EfTZCzJYSnWM2XA3J"],-891,[[6,"cc.Animation","play",-890]]],[200,-893,[1,"08nhRI14JPKKUHPJDNcQ9S"],[5]]],[3,"06QPeEmVBJLbyrhiUzqMvj",1,0],[1,185,-20,0]],[143,"Content Holder",33554432,1,[15,-900,-901],[[[5,-896,[1,"0bYb56YCNCYrQyiXFw50S5"],[5,414,896]],[49,45,100,100,-897,[1,"527WQLMIFKkZlDnwlC94Bs"]],[56,false,-898,[1,"2ckx/8E2lK76AzNcymCCjB"],[137,138,139,140,141,142,143,144,145]],-899],4,4,4,1],[3,"32xaE9h3JJFI5PUO300dOa",1,0]],[55,0,{},15,[30,"777+abRRVCaJ/XO2ZnoFXZ",-909,[123,"5a22KD2p9N5oaaYhT79ULB",1,[[177,[0,["777+abRRVCaJ/XO2ZnoFXZ"]],[[[37,-907,[1,"e5xj+Q+3hI0rReL8NhAb3n"]],-908],4,1]]],[[7,"Holder_Handy Guide",["_name"],-902],[12,["_lpos"],-903,[1,0,-80,0]],[12,["_lrot"],-904,[3,0,0,0,1]],[12,["_euler"],-905,[1,0,0,0]],[7,true,["_active"],-906]]],12]],[82,"Drop_02",33554432,[-924,-925],[[[5,-910,[1,"aaAepgcUFHZqKQ1QE5nMTW"],[5,60,60]],-911,[109,3,0.9,-914,[1,"0aFWhIvABNIY+yhCYKsOTU"],[[6,"04753kODZ1COq8ujU5QwPzS","clicked",-913]],[4,4292269782],-912,84,85,86,87],[136,"drop",-923,[1,"55usBdYZtFTbhms0VfqejU"],[[45,4,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-915],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-916]]],[45,3,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-917],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-918]]],[45,1,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-919],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-920]]],[45,2,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-921],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-922]]]]]],4,1,4,4],[3,"a2xbvY3BNFZb8Bd2PaA73D",1,0],[1,-94,0,0]],[82,"Frog_03",33554432,[-940,-941],[[[5,-926,[1,"eaI5LK9/ZNQ54NJxgMDjE8"],[5,60,60]],-927,[109,3,0.9,-930,[1,"b5XLfZQ31Kua5j7bn6xh0D"],[[6,"04753kODZ1COq8ujU5QwPzS","clicked",-929]],[4,4292269782],-928,93,94,95,96],[136,"frog",-939,[1,"8aFWv1WKBGEq88zprUWKqU"],[[45,4,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-931],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-932]]],[45,3,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-933],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-934]]],[45,1,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-935],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-936]]],[45,2,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-937],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-938]]]]]],4,1,4,4],[3,"2a0zSEDGJJ270win6wAwNG",1,0],[1,-32,0,0]],[82,"Whip_04",33554432,[-956,-957],[[[5,-942,[1,"bdzB8WVbNMfKfSDIqagz2r"],[5,60,60]],-943,[109,3,0.9,-946,[1,"0bYjq++k5JlZAjAOFjPnB0"],[[6,"04753kODZ1COq8ujU5QwPzS","clicked",-945]],[4,4292269782],-944,102,103,104,105],[136,"whip",-955,[1,"87AhqnRfVNKYdVbz9FV+8z"],[[45,4,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-947],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-948]]],[45,3,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-949],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-950]]],[45,1,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-951],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-952]]],[45,2,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-953],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-954]]]]]],4,1,4,4],[3,"c6jZfqwlJCnajS2esGDjTd",1,0],[1,30,0,0]],[82,"Bunny_01",33554432,[-972,-973],[[[5,-958,[1,"36CLctMlpCGr31VaK79lH0"],[5,60,60]],-959,[109,3,0.9,-962,[1,"b3EtByntBMa795hvv8x7Zl"],[[6,"04753kODZ1COq8ujU5QwPzS","clicked",-961]],[4,4292269782],-960,111,112,113,114],[136,"bunny",-971,[1,"5cz05YvCdG9q4QKa5uUD/T"],[[45,4,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-963],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-964]]],[45,3,[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-965],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-966]]],[45,1,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-967],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-968]]],[45,2,[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-969],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-970]]]]]],4,1,4,4],[3,"5fZxgXcHxPkptk9GKiNQ4W",1,0],[1,92,0,0]],[20,"Scripts",33554432,1,[-975,-976,-977,-978,-979,-980],[[8,-974,[1,"49VPsfuulGZLgh8zFn/43m"]]],[3,"30LnJ2n2FHzoRaI1/rEuUl",1,0]],[62,"Group_Daily Missions",false,33554432,15,[-985,-986,-987],[[17,-981,[1,"7dd2v/cLJAlZkwbEOrcwJ6"],[5,414,100],[0,0.5,1]],[258,17,157,157,80,100,1,-982,[1,"c1c2LeD0lIlbR382Zo1jMP"]],[314,false,1,6,-983,[1,"844PpCkN1LPbAY1dPL2gH1"]],[57,-984,[1,"e56FeN3ntFpYNzDbDyJXhW"]]],[3,"b8MGpEO+1A1581aZLcr7pB",1,0],[1,0,-80,0]],[48,"Line_01",33554432,[9,2,3,4],[[5,-988,[1,"d1Uj8aLnxByItswqPejNAX"],[5,248,60]],[125,16,100,-989,[1,"4fh0HPR+NFOYpe00fxCecp"]],[159,1,2,-990,[1,"ffzTjqlJhDl4ccZer1H50q"]]],[3,"f08DZVuqJB6avNL9Gnq85i",1,0],[1,0,31,0]],[48,"Line_02",33554432,[5,6,7,8],[[5,-991,[1,"63GXu4joFDYJx77xtGrWsa"],[5,248,60]],[125,16,100,-992,[1,"aaKRza1K5I1oASLL8Ss+YU"]],[159,1,2,-993,[1,"dfXM38fQ5HTq1aWx0mOiaO"]]],[3,"f7ifwJ/UtEEaRJNt1pMUWB",1,0],[1,0,-31,0]],[48,"Slimes_Line",33554432,[20,21,22,23],[[5,-994,[1,"a5Nyg+G9tEgojONpSurgkS"],[5,248,60]],[146,40,66,66,100,-995,[1,"c5trJA/mZJ5KvvasuE2JRS"]],[159,1,2,-996,[1,"35NUSZuA9OVKFG1j09OMn2"]]],[3,"13mTsyMmRO/pXyU1X4crU8",1,0],[1,0,-154.962,0]],[118,"Icon_InUse",33554432,[[5,-997,[1,"55zBrpKQZDYarAhAnp5L5z"],[5,8,8]],[31,0,-998,[1,"e2ROwvI1xAm5Md/mTj4awH"],[4,4294967040],82],[37,-999,[1,"24XdwPfx1CLou+G31VKBHV"]]],[3,"6bMN/KsglKUqwGYKMsMbEi",1,0],[1,-14.259,14.157,0]],[118,"Icon_InUse",33554432,[[5,-1000,[1,"a2OQjfkP5H0ZBTPdROOtWo"],[5,8,8]],[31,0,-1001,[1,"3dYRjev1xKgJhQOEDX9z+b"],[4,4294967040],91],[37,-1002,[1,"83XpdzuXNO5JvoN7zjtzSo"]]],[3,"ad5FLjM7JHMLnxRH2BMIvd",1,0],[1,-14.259,14.157,0]],[118,"Icon_InUse",33554432,[[5,-1003,[1,"f8i15kmqpHgpfPGK5jc0FX"],[5,8,8]],[31,0,-1004,[1,"24gNdhki1BapJhPoCwZHEC"],[4,4294967040],100],[37,-1005,[1,"b1Sd8L6L5FZoHyuLvPaoOf"]]],[3,"dazbFSzZdB27i+XTT3Uogr",1,0],[1,-14.259,14.157,0]],[118,"Icon_InUse",33554432,[[5,-1006,[1,"884kQysSpALaKyCvSFXHLq"],[5,8,8]],[31,0,-1007,[1,"13ldO6iXRMK5fEUAZV+xRw"],[4,4294967040],109],[37,-1008,[1,"86gaIMKgRC/q35uFJmoNYT"]]],[3,"78NjvZic5IS7LtfJcog+6k",1,0],[1,-14.259,14.157,0]],[48,"Button_Skin",33554432,[-1017],[[147,20,24,24,-8,20,-100,140,36,-1009,[1,"d4SkitHT1NpZznARaKnvNr"]],[5,-1010,[1,"e2Dc8Kio5DlZV/uhDobOyZ"],[5,140,44]],[29,1,0,-1011,[1,"40PDfYi3FNMZGxWR6Aesm+"],[4,10254365],129],[108,3,0.9,-1015,[1,"ebr4oHCwlLBKH2Qphr2lmu"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","changeSlimeClick",16],[6,"ac879rTendCEbpZWFz/jexs","playSFX",-1013],[6,"d9040g5wUZNv41Fw6BiBXaR","openSkinSelectionPanel",-1014]],-1012,130],[77,-1016,[1,"61/99iZSZAuKVRwvLPZkaz"],131]],[3,"5dtnhN+XtIZ4tJzbSgRE28",1,0],[1,-100,42,0]],[48,"Button_Stage",33554432,[-1026],[[259,20,24,137,-8,20,100,36,-1018,[1,"85JLoOI6pFhrdA/tauM+mj"]],[5,-1019,[1,"21vidMTUNGabb09JN/F+bY"],[5,140,44]],[29,1,0,-1020,[1,"16asiNgllADpkqzrjN7lhv"],[4,6825915],134],[108,3,0.9,-1024,[1,"e1yludQFJHgJ1EPBKr/GJv"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","bumpStage",16],[6,"ac879rTendCEbpZWFz/jexs","playSFX",-1022],[6,"bc4c8bzRddCFJ5qn4hnBJEo","changeWorld",-1023]],-1021,135],[77,-1025,[1,"02OUoH6uZI/6egAWd6aNR1"],136]],[3,"607ShHjVNKkrvYDe/ZdyJn",1,0],[1,100,42,0]],[22,"UI_Level Panel",33554432,15,[-1030,-1031,-1032],[[183,9,40,94,20,840,300,36,1,-1027,[1,"aaprWw5Y5HtpjOvrBtdx9s"],15],[17,-1028,[1,"17mDOgND9In6A6qASxkRyp"],[5,128,26],[0,0,1]],[29,1,0,-1029,[1,"56bzG3nYhL+LQSpL+xfqVw"],[4,4292667899],2]],[3,"97cFlVHmRFeJCMOAyHDt93",1,0],[1,-167,-20,0]],[20,"Group_Mid Panel",33554432,18,[-1035,11],[[5,-1033,[1,"1aIROqrhxMdr0lX9/Zg8vT"],[5,414,896]],[49,45,100,100,-1034,[1,"0dSAnLG4tK8Js2TesDWmGG"]]],[3,"33p5neaddMa6lGfX/cvIdD",1,0]],[240,"VFX_Unlock",33554432,12,[-1040],[[-1036,[8,-1037,[1,"1bK5+2cKxAV5bYf7v1G3JA"]],[73,1,-5046.155,1,-1038,[1,"4dj1pYHElLwI6VFxoBoAF5"]],[222,-1039,[1,"bf282p0WxBuJd5obVPbJ7h"]]],1,4,4,4],[3,"a0SRr71ntANJKFIHfxn+5I",1,0],[1,0,5046.154999999999,0],[1,100,100,1]],[62,"Group_Slimes",false,33554432,12,[-1044,-1045,28],[[17,-1041,[1,"55q9QYuPtJr7wR7B62xB8g"],[5,380,186],[0,0.5,1]],[260,17,157,0.37922705314009664,220,false,100,1,-1042,[1,"414HbJ0ClJtJacJQxzAge/"]],[57,-1043,[1,"afefXERBdNOqshYhGpCpa8"]]],[3,"34KkOtR8ZB5ag88cRstKaS",1,0],[1,0,-140,0]],[61,"Group_Loading",33554432,[-1049,-1050,-1051],[[5,-1046,[1,"d3PfmzQqxEGKC/YKSHIxlN"],[5,200,100]],[57,-1047,[1,"28Zu1gkxFOaa13t1F/PBQ0"]],[85,true,-1048,[1,"114UUDSH5Da7fddXBrh2kT"],[124],125]],[3,"a7aqoB2wlLIJHwo8ZefODD",1,0]],[22,"Group_XP Value",33554432,35,[-1058],[[5,-1052,[1,"47SIoF/t1HlICKEc2d2V5Y"],[5,86,18]],[220,false,1,1,1,-1053,[1,"12MYX0PiZGLJEEtbLNpVma"]],[147,45,24.397999999999996,17.602000000000004,3.7360000000000007,4.263999999999999,2,88.75999999999999,20,-1054,[1,"b0eJeOz65JHKqgELz4LuSK"]],[317,-1057,[1,"c1xTXqRe5JtI+WPJ7Pk/+8"],-1056,-1055]],[3,"255o6NwFxKwY/ohL4A6rOC",1,0],[1,67.398,-12.736,0]],[144,"Text_Name",33554432,[[[5,-1059,[1,"f1cIvH2kZJ4qysZV8F+a/s"],[5,178,50.4]],-1060,[146,40,30,30,78.16,-1061,[1,"f1BbqHhRtAar429RgpKuCa"]],[86,-1063,[1,"4c8THJHU5Bhpq/+m+LnN5E"],-1062]],4,1,4,4],[3,"0egDwqRdVChrw9rkkeV1fI",1,0],[1,0,1.269,0]],[22,"Group_Bot Panel",33554432,18,[12,33,34],[[17,-1064,[1,"375hwsPS1NlrEPaoG6h4wr"],[5,414,100],[0,0.5,0]],[125,44,100,-1065,[1,"0erFtG0WpDc50OGHaTKtay"]]],[3,"cbjVzH+pRHmZIT3cw5DcWv",1,0],[1,0,-448,0]],[62,"Panel_Cost",false,33554432,12,[-1069,-1070],[[5,-1066,[1,"4b9AhViaBB+Jrgpu9BWoht"],[5,220,44]],[29,1,0,-1067,[1,"c1YFHLp8RIk6E4hWBPLM0L"],[4,4289449983],23],[73,17,66.15199999999999,1,-1068,[1,"f82RE4HpBKUJGb//ulfclG"]]],[3,"60Vdw1qwJKtb5sqo3jyeiR",1,0],[1,0,-8.151999999999987,0]],[44,"Text_SkinCost",33554432,43,[[[5,-1071,[1,"2aP88BsoVMQodlbe8SY0gy"],[5,130,50.4]],-1072,[146,40,60,30,44.64,-1073,[1,"85q2DE5VxMt5EoRwG5wjFg"]],[86,-1075,[1,"29JmhbFUZCUIoc+66HoBzQ"],-1074]],4,1,4,4],[3,"b7vk/aIZJGSb3Of9mHdAU2",1,0],[1,15,2.804,0]],[122,"VFX_Equip",33554432,12,[[-1076,[8,-1077,[1,"3cvt8xubZNm4bI/L+XnJqq"]],[73,1,-76,1,-1078,[1,"c1ryq86iNByKBXviF1UL8i"]],[222,-1079,[1,"6eJllJ/rtJ2YwJauqmqyBp"]]],1,4,4,4],[3,"dbKA7W4XVAJrJLXdbjDxhw",1,0],[1,0,5006,0],[1,1.4,1.4,1]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[20,"Panel_Color",33554432,20,[-1083,-1084],[[5,-1080,[1,"63l+QTQDpOIo0u6EQXLjqv"],[5,52,52]],[31,0,-1081,[1,"45X2fGuSVGrryzuHghXaEx"],[4,4289449983],83],[40,45,4,4,4,4,128,128,-1082,[1,"10wLYUE4xItrkS+E5xwLjs"]]],[3,"1aRVwy+6RIDpyaaZHmUsD4",1,0]],[20,"Panel_Color",33554432,21,[-1088,-1089],[[5,-1085,[1,"e9xKM38sxFrpmvZqke77vU"],[5,52,52]],[31,0,-1086,[1,"74nYr1Yu9CVYtLA6aOm1C+"],[4,4289449983],92],[40,45,4,4,4,4,128,128,-1087,[1,"549wDBV0JCHJK3r8HqZoP4"]]],[3,"43xx08xPZAj423UulzrHO3",1,0]],[20,"Panel_Color",33554432,22,[-1093,-1094],[[5,-1090,[1,"7e8V1w63xMyYf6O/EB7Fcg"],[5,52,52]],[31,0,-1091,[1,"d1gBYBZfBB2K83Ft3sEq7o"],[4,4289449983],101],[40,45,4,4,4,4,128,128,-1092,[1,"91H3uss65G6p0eu3ES1yom"]]],[3,"455EWrcgBLgqbVjdGqBDuz",1,0]],[20,"Panel_Color",33554432,23,[-1098,-1099],[[5,-1095,[1,"66BVNY7C1I2oGzZfM2rmwt"],[5,52,52]],[31,0,-1096,[1,"93YCTMCzVI0YuGzTtWJM4U"],[4,4289449983],110],[40,45,4,4,4,4,128,128,-1097,[1,"49B/T3B0BBYrSpr/u9hUE/"]]],[3,"24g4NLsF5Ca4Li/p1AW0Wn",1,0]],[22,"Sprite_Button Color",33554432,33,[-1103],[[5,-1100,[1,"11S3N/YjpCYKmJZVcNGeDg"],[5,136,40]],[29,1,0,-1101,[1,"92IEhDn2tPAZUXEOHAx+em"],[4,4292259141],128],[40,45,2,2,1,3,183,94,-1102,[1,"dcMPY/nb9BzKLfMwabO9aD"]]],[3,"02hBDg0z1KVpMydpZcdYhZ",1,0],[1,0,1,0]],[22,"Sprite_Button Color",33554432,34,[-1107],[[5,-1104,[1,"0bzmzOYrFLioiWgSv82F2W"],[5,136,40]],[29,1,0,-1105,[1,"7dR9e32hROOqvq1BoatZ/3"],[4,4286930909],133],[40,45,2,2,1,3,183,94,-1106,[1,"04w59JJ89EwY3AAjnBjD6G"]]],[3,"054KJj3ttOGLrFZBm6qXtN",1,0],[1,0,1,0]],[22,"Mask_Fill",33554432,35,[-1111],[[5,-1108,[1,"36Zmqk4a9G/YhDb9H7lsOG"],[5,125,22]],[318,3,1,-1109,[1,"14DXPqtNRPe5wbzb/jhlCm"],0],[261,45,3,2,2,100,100,-1110,[1,"27d+GJQZ1NnI7WmyJ4fwah"]]],[3,"berI17C3pJ4Zkykl9xxZuR",1,0],[1,62.5,-13,0]],[22,"UI_Level Holder",33554432,35,[-1116],[[5,-1112,[1,"56gmAMXsxFQ5wKBc7c0hJ9"],[5,38,34]],[74,0,-1113,[1,"8ejwQqhXNJaYZm8XG4idMQ"],1],[320,-1115,[1,"30XQd8yVlGy4aP19AUOjmI"],-1114]],[3,"99vK2XiXROGaxF3F39djkt",1,0],[1,2,-12,0]],[55,0,null,25,[30,"b9tpjlp9VBian0Vwn0pf6D",-1117,[38,"b3tOVP8rxHD5nP5Hxhl5j4",1,[[14,"Panel_Daily Mission 01",["_name"],[0,["b9tpjlp9VBian0Vwn0pf6D"]]],[23,["_lpos"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,-132,0,0]],[23,["_lrot"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[3,0,0,0,1]],[23,["_euler"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]]]],6]],[55,0,null,25,[30,"b9tpjlp9VBian0Vwn0pf6D",-1118,[38,"bahBrJjSlGAYxsBY/QwS5b",1,[[14,"Panel_Daily Mission 02",["_name"],[0,["b9tpjlp9VBian0Vwn0pf6D"]]],[23,["_lpos"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]],[23,["_lrot"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[3,0,0,0,1]],[23,["_euler"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]]]],7]],[55,0,null,25,[30,"b9tpjlp9VBian0Vwn0pf6D",-1119,[38,"13annH44tKPbqE+WfKZ4gl",1,[[14,"Panel_Daily Mission 03",["_name"],[0,["b9tpjlp9VBian0Vwn0pf6D"]]],[23,["_lpos"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,132,0,0]],[23,["_lrot"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[3,0,0,0,1]],[23,["_euler"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]]]],8]],[62,"Panel_Slime Name",false,33554432,15,[-1123],[[5,-1120,[1,"8asRONxRRHV4oZORbjSq0b"],[5,246,44]],[29,1,0,-1121,[1,"85tln+NAVB9qsrBt+Q1XYR"],[4,4292667899],10],[126,1,140,-1122,[1,"ddrHy6KrhCD5cCaOgd+OFh"]]],[3,"b2XYh9Wu9NO6CpOe14YkGu",1,0],[1,0,-162,0]],[20,"Panel_Color",33554432,61,[41],[[5,-1124,[1,"2dK20lTRJCB5BcduToCrFA"],[5,238,36]],[29,1,0,-1125,[1,"1djVJRTqNIwZ+8qXV9+o8b"],[4,4293561531],9],[40,45,4,4,4,4,246,44,-1126,[1,"499JWHKqZEZ6K+LvMz/TQr"]]],[3,"63VJcKOMBJnZjGCc1SUbTI",1,0]],[0,["777+abRRVCaJ/XO2ZnoFXZ"]],[32,"UI_Logo",33554432,36,[[145,18,42,-1127,[1,"4desxajK1Bt4z+v3mw5zS7"],36],[5,-1128,[1,"069Fr8zhBIB4+wnHgY7WtJ"],[5,396,148]],[75,-1129,[1,"47FUgHVStBGK0kSwgkSDBC"],13],[85,true,-1130,[1,"453vMuiylNJbzwEyk0p1bg"],[14],15]],[3,"c4SP6rgLpOTox2uPDggM1R",1,0],[1,0,42,0]],[62,"Slime_Platform",false,33554432,12,[-1134],[[17,-1131,[1,"d5RNGINLJC5KkpCikkQdgX"],[5,208,148],[0,0.5,0]],[93,-1132,[1,"2d1B1kiBZKyZh08JMabWoK"],[4,4292667899],21],[262,1,-90,1,-1133,[1,"f80dZJqI1KdKgzal75gO62"],12]],[3,"6aNzTjpZVENpr2DGFFQLHg",1,0],[1,4.543,22,0]],[22,"Selected Store Item Controller",33554432,13,[-1139],[[8,-1135,[1,"52jzS3UfpCDZ1QqnZCxRkv"]],[321,-1138,[1,"c1/uMPkaFHE40R21Qpv/Wq"],[[6,"85848g+yY1PpKiragtG2vjV","setText",44]],[[6,"85848g+yY1PpKiragtG2vjV","setText",41]],[[6,"37b85WpHzdBn41+pXJNQa6l","setTrigger",-1137]],[[6,"cc.ParticleSystem","play",37],[6,"cc.ParticleSystem","play",-1136]],[[6,"cc.ParticleSystem","play",45]]]],[3,"e2Ov3/enNF8L94mfg6/DUB",1,0],[1,0,50,0]],[22,"Group_Slime Textures",33554432,38,[26,27],[[5,-1140,[1,"6eVUikULhMO6TBcmKf94Rb"],[5,248,122]],[315,2,2,-1141,[1,"29tnCprBVLorsE1Xp0bHsS"]]],[3,"f60BYDI7pMPLqIMbAA38dJ",1,0],[1,0,-43.04,0]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[20,"Icon_Slime",33554432,50,[-1144,-1145],[[5,-1142,[1,"7d32N0RoFF66M8b/JiqOtT"],[5,48,48]],[84,0,false,-1143,[1,"4elTNjFO1PTI+3/8sQO8T5"],[4,4292667899],81]],[3,"84WfWQ6wFCKYzKThqVTSFr",1,0]],[43,"Selected",33554432,[[8,-1146,[1,"44ZM2N1qBHepKdwyJvmOcZ"]],[41,-1148,[1,"27eDn53r5Fab83y8z5orHw"],[4,4294958592],-1147]],[3,"252gmuabNIKJM244C1OFzM",1,0]],[43,"Not Selected",33554432,[[8,-1149,[1,"8enpTbigNOWbuPB4STGaPr"]],[41,-1151,[1,"9ep9S/4FxAwavZi0qrsePM"],[4,4285837550],-1150]],[3,"77Pm8ibQ1B56RvcLa4FbIn",1,0]],[20,"Icon_Slime",33554432,51,[-1154,-1155],[[5,-1152,[1,"3dCSbmtqNIoLVZKXG9ddX+"],[5,48,48]],[84,0,false,-1153,[1,"eeGxP7CJxFl7RUr82Z5PhK"],[4,4292667899],90]],[3,"afCA91s8lL3YYt0Wk+OBju",1,0]],[43,"Selected",33554432,[[8,-1156,[1,"33OU0uI5ZJtbaD+uwJPXNh"]],[41,-1158,[1,"b067Jfiq5PXJE8okQbcppD"],[4,4294958592],-1157]],[3,"ectkUPiOZJjKFcvap8I0Nd",1,0]],[43,"Not Selected",33554432,[[8,-1159,[1,"42NCa7nuVD7JqyPyaGzIAo"]],[41,-1161,[1,"feKg9Crr1M8LYBiF8SLvf0"],[4,4285837550],-1160]],[3,"78CfI4PURFho/nQ/sn8P6A",1,0]],[20,"Icon_Slime",33554432,52,[-1164,-1165],[[5,-1162,[1,"efEP/tPq9K0aafcEdEAjdf"],[5,48,48]],[84,0,false,-1163,[1,"62sIMM1mtGb6nu48aV1iC+"],[4,4292667899],99]],[3,"be/T3Mp4tIm52rG8e8iwC1",1,0]],[43,"Selected",33554432,[[8,-1166,[1,"b7up6RJJZBVYakfKmvLz6x"]],[41,-1168,[1,"56D4iYwC1BxqhtpEmYECNx"],[4,4294958592],-1167]],[3,"04NOdALHVEFJHLgYxxY5Sz",1,0]],[43,"Not Selected",33554432,[[8,-1169,[1,"47zPAUzNFPzYBIQ4xEQzUC"]],[41,-1171,[1,"b145Mr9WlGxZB0ovZrpHMz"],[4,4285837550],-1170]],[3,"2cp5kvaMxGV4w1u4rSbqUD",1,0]],[20,"Icon_Slime",33554432,53,[-1174,-1175],[[5,-1172,[1,"e8IJm+R31CeLJbuJYPtpQa"],[5,48,48]],[84,0,false,-1173,[1,"e8ab9/JbFKi7S+U2Up66e5"],[4,4292667899],108]],[3,"22+DwsocJA2I9+5vTYzXqf",1,0]],[43,"Selected",33554432,[[8,-1176,[1,"7fFuPBuzlNQqh1nFYqtxR1"]],[41,-1178,[1,"25t74prJVAXJHoaMVYDbEp"],[4,4294958592],-1177]],[3,"90v6fYvWBNULOPsJ69p+O7",1,0]],[43,"Not Selected",33554432,[[8,-1179,[1,"dbmsAA6vtHSbbuv8TUohyv"]],[41,-1181,[1,"0aD9MV3AhM/qVPFFOKM8tW"],[4,4285837550],-1180]],[3,"4048uKV8RHS5GiKJ9UO+sc",1,0]],[16,"Slime Selection",8388608,1,[[8,-1182,[1,"64Ljngjc5B6J2OyseVlKOS"]],[322,-1183,[1,"9a620Bs9xBn7ISDYG9tUfm"]]],[3,"789M3SIyxDAoBzZqCbWgqk",1,0]],[62,"Group_GroupLoading",false,33554432,12,[39],[[5,-1184,[1,"9aJu/NxGNKPqjrzlPdZW3K"],[5,200,100]],[263,18,460,1,-1185,[1,"f0nZxb3ftHe7XYl6CzsJWl"],18],[57,-1186,[1,"328ye9LadOXK+ajUIlj1tP"]]],[3,"7dmAX5O8BGHaLlFHhk75fR",1,0],[1,0,448,0]],[16,"Loading Flow Controller",33554432,24,[[8,-1187,[1,"f5GUEy2I1COrGbSzzE9Lxr"]],[323,2,-1188,[1,"6cRhapBE5PhJUxEYDrUPeM"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","finishedFirstLoad",16],[6,"c220ezwrChLSYwuQOQF0brq","activate",11]]]],[3,"05pquUfspEcIbDhI+9cgse",1,0]],[44,"Bar Fill",33554432,56,[[[184,45,7,32,32,-1189,[1,"debW1HfYRD1pse8DDNf2kS"]],[5,-1190,[1,"e28AopJ+FH3YBA6b/kyI9V"],[5,118,22]],-1191],4,4,1],[3,"a9QCRrqqxEVZwfpwH+g1D9",1,0],[1,3.5,0,0]],[44,"Text_Current Currency",33554432,17,[[[17,-1192,[1,"06z68w+blNbauZo0O5poFl"],[5,94,28.68],[0,0.5,0.41]],[185,42,28,18,-16.921200000000002,6.259,0.399200000000004,133.24,1,-1193,[1,"65XOhjQQRMOZay/mgKbg5p"]],-1194],4,4,1],[3,"99r6AQJHJNMbm4Joh8Fire",1,0],[1,-65,-15.181999999999997,0]],[32,"UI_Coin Icon",33554432,17,[[5,-1195,[1,"f1zxc3CGdGjaLt16bTe5ak"],[5,36,36]],[74,0,-1196,[1,"787/8T5QZK1JgBUh1qDpje"],3],[264,8,-10,1,-1197,[1,"61austAOxOMLMmhDntdVCr"]]],[3,"afBElChAVJeqi/xSB+5m1+",1,0],[1,-132,-13.642000000000053,0]],[55,0,{},15,[30,"8aX5hxXqBFKawcGo9z8a0S",-1207,[38,"6dWyfmGdJK3oiH2DsiLpo9",1,[[7,"Button_Guide",["_name"],-1198],[12,["_lpos"],-1199,[1,0,-32.869,0]],[12,["_lrot"],-1200,[3,0,0,0,1]],[12,["_euler"],-1201,[1,0,0,0]],[7,1,["clickEvents","length"],-1202],[269,["clickEvents","0"],-1204,[6,"c19c6UdX31OlI3xN6kAGLZx","toggleTutorial",-1203]],[189,["_target"],-1206,-1205]]],11]],[0,["8aX5hxXqBFKawcGo9z8a0S"]],[16,"Tutorial Controller",33554432,24,[[8,-1208,[1,"f5wOKaz3RLI6K9B/n/0kWR"]],[324,-1209,[1,"fctHKoHyFOr6+oQjNASJFm"],[[27,"37b85WpHzdBn41+pXJNQa6l","setBool","active,true",19]],[[27,"37b85WpHzdBn41+pXJNQa6l","setBool","active,false",19]]]],[3,"96YNwxNClG+Zf5EmwigCDC",1,0]],[16,"Sprite_Play",33554432,11,[[5,-1210,[1,"f6b+X7fKlLh4sh7+DN9pmD"],[5,112,112]],[75,-1211,[1,"e1XGFGm1VCUqu9dMIve/Jm"],16]],[3,"06McJdflBIqpn9VgQDqKR+",1,0]],[32,"Slime_Platform Color",33554432,65,[[5,-1212,[1,"59AZwR3XlFmq1uRXTYQa0K"],[5,184,134]],[31,0,-1213,[1,"7cBKXBjrBJnIyO3ALJvbMy"],[4,4289449983],20],[40,45,12,12,8,6,208,148,-1214,[1,"71Gzsss69NE4wglP2venC9"]]],[3,"9b/ugOXINJz5YYp9RFzVPp",1,0],[1,0,73,0]],[32,"Icon_SlimeCoin",33554432,43,[[5,-1215,[1,"9b7D+msBhBnqyNbMNtKXoK"],[5,64,64]],[75,-1216,[1,"49GYRpFjtAFpC6tJwX2EZr"],22],[186,8,-10,-1217,[1,"98Ml15L5lFRYBJlMy/ACrZ"]]],[3,"19NpfvqGVK0LQHXx/O0bye",1,0],[1,-88,0,0]],[32,"Panel_Color",33554432,13,[[5,-1218,[1,"1aeR6SwYVOuK2XicEZkHtm"],[5,176,40]],[29,1,0,-1219,[1,"d5U++qdHZDKLVE3IWuVwFo"],[4,4279227025],24],[40,45,2,2,1,3,40,36,-1220,[1,"9cVggDcJlF+IIXQddnU+Oo"]]],[3,"8dFdGzBM9B24GVFWJMlXyp",1,0],[1,0,1,0]],[44,"Text",33554432,13,[[[5,-1221,[1,"070yMwSvNNWLrv0IN5GQq6"],[5,160,40]],-1222,[86,-1224,[1,"ddOjBaZxBPjaolgXqULyHd"],-1223]],4,1,4],[3,"b408QtsxpGDq5qRlLAEY5K",1,0],[1,0,4.29,0]],[16,"Store Button Animator Helper",33554432,66,[[8,-1225,[1,"7fINg/RKhK2oewt4iUDG0g"]],[76,-1227,[1,"e30O/sCjRIMo+OXAJcBClT"],-1226]],[3,"58YQxV4XlPJ4CCXIE0JiVX",1,0]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[16,"Icon_Mask",33554432,70,[[5,-1228,[1,"edzVTld0hAS5tT1QYl7Ctm"],[5,48,48]],[84,0,false,-1229,[1,"0f46Uh8E1Gar+FT0Ux8xev"],[4,4289449983],79],[49,45,208,148,-1230,[1,"27pYQKsdRNkLgq/qLrGx/g"]]],[3,"4094/Gq2xOQJB+tfvJ7Wjy",1,0]],[22,"Group_Icon",33554432,50,[29],[[5,-1231,[1,"falku60rJG4JASFGEl74ie"],[5,40,40]],[66,9,-1232,[1,"20qXSgLF9JNqgLlGxY1CLa"]]],[3,"e0uPK+b3lBxr9ZiS1y879b",1,0],[1,-6,6,0]],[61,"Outline",33554432,[71,72],[[8,-1233,[1,"c1JmfwJw9JrYpoUiwI9EYJ"]]],[3,"0aczOIsIFF8K8uHDVVgyIi",1,0]],[16,"Icon_Mask",33554432,73,[[5,-1234,[1,"6f2QrwOtFP+IifwDy7t19H"],[5,48,48]],[84,0,false,-1235,[1,"d41+PQzhpOCa1+I9sP1ywR"],[4,4289449983],88],[49,45,208,148,-1236,[1,"31LDNHa5dPlIFUoxLJ//65"]]],[3,"90PV9KaaNGEYdBjSeWryyS",1,0]],[22,"Group_Icon",33554432,51,[30],[[5,-1237,[1,"0a0rlIclpDA5oquH5MgDa7"],[5,40,40]],[66,9,-1238,[1,"f6zGDUNbhIyZbS3INH32HN"]]],[3,"9duNjcJnlNk4JbzETwS9z4",1,0],[1,-6,6,0]],[61,"Outline",33554432,[74,75],[[8,-1239,[1,"c0TWgej9NOOLi4tC2cbIK8"]]],[3,"c0FVkQuXlM67guJjzd8pFT",1,0]],[16,"Icon_Mask",33554432,76,[[5,-1240,[1,"26z38XNCdDGrdeHYYK+ZOT"],[5,48,48]],[84,0,false,-1241,[1,"9c8lSoQZBCuYjWAvtXb10J"],[4,4289449983],97],[49,45,208,148,-1242,[1,"63hB/jrd5CMKLFODj3Nbz9"]]],[3,"31dxciJJNCCKgLtD6acubv",1,0]],[22,"Group_Icon",33554432,52,[31],[[5,-1243,[1,"87FyyD+DNLWLyXDUlt6fsV"],[5,40,40]],[66,9,-1244,[1,"6eIqqlC5RLbLA2CJFec8WQ"]]],[3,"ecAw6hj0RGr7kfb/tsCNkQ",1,0],[1,-6,6,0]],[61,"Outline",33554432,[77,78],[[8,-1245,[1,"aeH+HvPOtKGJhJWoH8Nk8d"]]],[3,"42xjKO89BDjp7JSW9T5Pa2",1,0]],[16,"Icon_Mask",33554432,79,[[5,-1246,[1,"c004XMMNVLWZ4XW6eSmx4X"],[5,48,48]],[84,0,false,-1247,[1,"dfjeZgUV5LDoK9x97K/R2D"],[4,4289449983],106],[49,45,208,148,-1248,[1,"52xowLZi9MmornK7cgw/Bh"]]],[3,"dcnokL5LNC5Yyx+bKbINYD",1,0]],[22,"Group_Icon",33554432,53,[32],[[5,-1249,[1,"36MrFfJK5OR4mN2Dw/rZmt"],[5,40,40]],[66,9,-1250,[1,"fcIvfUmrtErZQ30NGTq2eW"]]],[3,"a8cxTrNApJ+qCTLtvlWqOe",1,0],[1,-6,6,0]],[61,"Outline",33554432,[80,81],[[8,-1251,[1,"09H/diOsJCrIStz9oPtLHr"]]],[3,"c3ZTCRjSJDLLGUwfMocQYK",1,0]],[166,"Text_Swipe to Change",false,33554432,12,[[5,-1252,[1,"01LqfWpcRGHLuuIKdXPyn+"],[5,173.66,25.2]],[94,"Tap to select slime",20,20,20,false,-1253,[1,"33oiVB0dhGA4Z5ZFpVy0jJ"],[4,4287673830],115],[182,1,428,88,50.4,1,-1254,[1,"05Voaj2yJJfLPMBQOoln7/"]]],[3,"c7dXOf15tG+p1u7GjZqkT1",1,0],[1,0,-360.6,0]],[32,"Panel_Color",33554432,14,[[5,-1255,[1,"d6rOQgBfJOlJ5NekdSioJk"],[5,136,40]],[29,1,0,-1256,[1,"21Fc7h1+5OspNVOabKIYQJ"],[4,4282815977],116],[40,45,2,2,1,3,40,36,-1257,[1,"c6Lmi/W4hKuIn01HT3dDEC"]]],[3,"7fntGeQmVFyoDCjAAWfnWj",1,0],[1,0,1,0]],[32,"Text_Label",33554432,54,[[5,-1258,[1,"26Z+3+WJpO971xcQiMvYat"],[5,112,32]],[133,"Change Slime",21,21.98,20,2,false,false,-1259,[1,"00MbOWnr9GgbhyiOe7e2RR"],[4,4292667899],127],[127,41,12,12,2,102,-1260,[1,"2e5ZA+1kRMJJQ+kWQpwpB3"]]],[3,"caOhKTVMpOrY7wPEbb8N5/",1,0],[1,0,2,0]],[32,"Text_Label",33554432,55,[[5,-1261,[1,"f5jE16gIRF0acReJBqDtaH"],[5,112,32]],[133,"Change Stage",21,21.98,20,2,false,false,-1262,[1,"c3kksBUihDsqjyVl37qD0D"],[4,4292667899],132],[127,41,12,12,2,102,-1263,[1,"a56sHgqsNGo6Zyg48nqMTL"]]],[3,"a0LA3+J1tOAaDnChfvyAOP",1,0],[1,0,2,0]],[16,"World Selection",33554432,24,[[8,-1264,[1,"56YG1f5pZAyrMPga1oPsDq"]],[325,-1265,[1,"5dTXE18WtEyIopT14xoH26"],[[27,"37b85WpHzdBn41+pXJNQa6l","setBool","changeStage,false",16]]]],[3,"c7HgV3niVEgaxltEPdnZxT",1,0]],[20,"Daily Missions",33554432,24,[-1267,-1268],[[8,-1266,[1,"17HNMmwTpPEIU7GJU5+Bxa"]]],[3,"3aQ1o7NghKhY5AAPkF4KD0",1,0]],[98,"UI",33554432,120,[[[8,-1269,[1,"6ekql+xAdAbpJjzKBZ4i87"]],-1270],4,1],[3,"84k44wHPZEAKVRlxjqGR6D",1,0]],[326,[null,null,null],121,[1,"f3DLdI6DNFarw74ZsMW5jG"]],[20,"Listeners",33554432,1,[-1272,-1273],[[8,-1271,[1,"ae8dsG2tNGTbjUmO2Ov53P"]]],[3,"c5+UFyUENI/IDsv5i24kxZ",1,0]],[20,"Animation",33554432,24,[16],[[8,-1274,[1,"25BOf9xWFExol9QOi12rMW"]]],[3,"44chgLFXhCsbwbaj6WNdf0",1,0]],[44,"Text_Level",33554432,57,[[[5,-1275,[1,"00EFiO7jFFj7js01yYdA3E"],[5,30,25.2]],-1276],4,1],[3,"97qwkkwKtOu4IZtUzImEZF",1,0],[1,0.405,-0.279,0]],[98,"Text",33554432,40,[[[5,-1277,[1,"ffUYJQpa9JxI0l7HEwkxN9"],[5,95,28.4]],-1278],4,1],[3,"dbjNo8QSdLrYQxyuFFfLV/",1,0]],[110,"999",22,22,22,2,false,false,86,[1,"57lHKDSm9GpLisqU8qqMph"],[4,4280640397]],[0,["07THi0b/RF+bnhyo6JcCi5"]],[245,"VFX_Extra Particles",33554432,37,[-1279],[3,"76oq8YACVDGKGOgLubmZEG",1,0]],[32,"Divider",33554432,38,[[5,-1280,[1,"a1ANpsCqxOtLlE05Nz+hWi"],[5,280,3]],[31,0,-1281,[1,"f2UXJNSstM2K6qlyrInM0H"],[4,4289449983],78]],[3,"7bzs9ZbdhAJIcE/Ca+jdlr",1,0],[1,0,-115.38,0]],[16,"Icon_Outline",33554432,70,[[5,-1282,[1,"bfhDESrAVN/LiCBoe6ASCm"],[5,42,35]],[93,-1283,[1,"04mGNlHMREloaF0odauMo4"],[4,4285837550],80]],[3,"6csxGo9ZVFaoo69vrLOA5s",1,0]],[20,"Scripts",33554432,20,[-1285],[[8,-1284,[1,"82aO5iL81GM6BAcHXX0rw4"]]],[3,"b6aysdgHhALYI7WldxEg+m",1,0]],[20,"Colors",33554432,132,[105],[[8,-1286,[1,"08pin5qnFDH4FYx25yVxnR"]]],[3,"8adbZJLrNPop6bxUoH8oZW",1,0]],[100,1,0,20,[1,"1414ApLkVFlqpw7AwEf7K+"],[4,4285837550]],[16,"Icon_Outline",33554432,73,[[5,-1287,[1,"a9sKEM959OGb6xcU7y8Ex3"],[5,38,35]],[93,-1288,[1,"f7SSIe4edI/5g4Zloolgr3"],[4,4285837550],89]],[3,"20wWV7er9Ia6saYRU7awNv",1,0]],[20,"Scripts",33554432,21,[-1290],[[8,-1289,[1,"9aZaJM98RH9ZsPqogsP810"]]],[3,"83KM/ypjtCoqKGdOJivYxN",1,0]],[20,"Colors",33554432,136,[108],[[8,-1291,[1,"13ID0PIlJB8r0k9Am0Me6r"]]],[3,"bbmU5+g3RM1qxJnKuB3j1v",1,0]],[100,1,0,21,[1,"2fD46v4JpGQLhzRVnvvUF/"],[4,4285837550]],[16,"Icon_Outline",33554432,76,[[5,-1292,[1,"3etAIubNxInbOQyeuyEFhF"],[5,40,39]],[93,-1293,[1,"76+zT7nmpOUqenvL2kBdwf"],[4,4285837550],98]],[3,"8dd/Tzt31PQYWWLL0zFYgW",1,0]],[20,"Scripts",33554432,22,[-1295],[[8,-1294,[1,"54XXVXK9FHDLOpNT6KuR+E"]]],[3,"ecy7R51DJB1JGl6rl71PTF",1,0]],[20,"Colors",33554432,140,[111],[[8,-1296,[1,"5a8bAcu/FBcqWmWSq4lh91"]]],[3,"783SarujVO5qeotkNyApUU",1,0]],[100,1,0,22,[1,"871i5ZW01O0JI1AHn0InJq"],[4,4285837550]],[16,"Icon_Outline",33554432,79,[[5,-1297,[1,"46n26si7VN0qwEWBk0fqCV"],[5,34,39]],[93,-1298,[1,"41UTs564BFeK5k7G0ZyNs5"],[4,4285837550],107]],[3,"b1/xFpK25F7KOCs6oN94kW",1,0]],[20,"Scripts",33554432,23,[-1300],[[8,-1299,[1,"3atks1eChPe6mbSWPwDPRQ"]]],[3,"cbWemNXttEkr2KD2WIOHe3",1,0]],[20,"Colors",33554432,144,[114],[[8,-1301,[1,"16xctRLLxL8JpU3sP7LB3O"]]],[3,"cas9sDPedDV5ANgnQhd8bM",1,0]],[100,1,0,23,[1,"eciRyeJnNPW4HoySQxz20s"],[4,4285837550]],[32,"Text",33554432,14,[[5,-1302,[1,"8cALVWb1VI5rT4R7CCwVh1"],[5,100,40]],[284,"Back",30,30,1,false,false,-1303,[1,"35BafLHClPfZEl99gU5g/B"],117]],[3,"374gHnslZFEovof5PKpgkG",1,0],[1,0,4.29,0]],[90,"Icon_01",33554432,39,[[17,-1304,[1,"77DUuXgGFIKr3ARVWRwHBZ"],[5,93,76],[0,0.5,0]],[31,0,-1305,[1,"18tabFTGNAfKMKRlPrSUmz"],[4,4284520160],121]],[3,"89L4Cwsr5I7akV5QwLDIsi",1,0],[1,-80,0,0],[1,0.6,0.6,1]],[230,"Icon_02",33554432,39,[[17,-1306,[1,"50FhyAOINAE7GcU9UkTSyR"],[5,93,76],[0,0.5,0]],[31,0,-1307,[1,"daJ3HDMHFPiL1IQNyZ17JL"],[4,4284520160],122]],[3,"8cdrTYfXZOSo8yiwl+aHJV",1,0],[1,0.6,0.6,1]],[90,"Icon_03",33554432,39,[[17,-1308,[1,"ee+ghVjUBHeL8x4dKWDVYu"],[5,93,76],[0,0.5,0]],[31,0,-1309,[1,"ebphfC7NxF9oZFbz/lXLYq"],[4,4284520160],123]],[3,"f65Xfe581LKKwKLtetGYKq",1,0],[1,80,0,0],[1,0.6,0.6,1]],[16,"On Start",33554432,24,[[8,-1310,[1,"damaGmjfRMsLx/RRwLRpaY"]],[327,-1311,[1,"ffmJqlHIlG0K8THjSuvxO7"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","begin",16]]]],[3,"95O2lGw+5Ipo6zb7CY0hfW",1,0]],[20,"Listener",33554432,120,[-1313],[[8,-1312,[1,"c9YHZFjK1IPIKtPC1fbMoS"]]],[3,"3cvYRoSwdGUa/novwLxsom",1,0]],[16,"Set Current Missions",33554432,152,[[8,-1314,[1,"b3FlitTkFK4oLXYRXkFyZo"]],[328,1,-1315,[1,"84kVFNvllK75tz3i5JQXH/"],[[6,"b42e4itkiNL2Jk75XfG9uYR","setMissions",121]]]],[3,"68uN+VDNBPvLUry2zfbCzW",1,0]],[16,"Game Slimes Ready",33554432,123,[[8,-1316,[1,"20WSanuTBM1Lgnct/wD93O"]],[95,22,-1317,[1,"5e+jM0iUdCiopW02pkceMT"],[[27,"58152N3IOJILLu+bx3ThyjT","setReady","0",84]]]],[3,"40FZ9RCYFJzZoufLIpaHM1",1,0]],[16,"World Ready",33554432,123,[[8,-1318,[1,"56BqDnrYZORqK6ZhbR7qiz"]],[329,1,-1319,[1,"c4o3e7yDxDxbvHOebeYS4v"],[[27,"58152N3IOJILLu+bx3ThyjT","setReady","1",84]]]],[3,"f6kPFlVj9BBZS1MFkgUzlE",1,0]],[63,18,[1,"2ckx/8E2lK76AzNcymCCjB"]],[193,3,0,0.6,85,[1,"0fnvnuU/dLX7hqlRivaiRN"],[4,4285837550]],[110,"20",17,18,26,2,false,false,125,[1,"e6rVd2qelGqZ2WVqwu6zBB"],[4,4292667899]],[195,"1000 / 1000",17,18,20,2,false,false,1,126,[1,"94vIReIidB25hEiznF/FZ1"],[4,4280640397]],[110,"Blue Slime",26,26,30,2,false,false,41,[1,"748qW/rm5EqaIWK3OHqWOH"],[4,4287514475]],[201,true,19,[1,"32qKsC8RZN9Jv+ObqF6Ehx"]],[285,"500",36,36,2,false,false,44,[1,"9bFjc9ISBA07bbr4b331kU"],[4,4281293202]],[196,"Unlock!",30,30,1,false,false,95,[1,"96SEehaL5DB6JHdxG1BK7q"]],[63,13,[1,"4dBkhxJ+pJCKe/qq5pXx59"]],[300,1,false,1.6,false,129,[1,"10+9m8sgtEWY44nvxFnNTS"],[25],[78,2,[4,4280083187],[4,4290703642]],[25,3,30,60],[4],[4],[25,3,3,6],[4],[4],[4],[4],[9,1.2],[9,0.4],[4],[4],[[68,[9,4]],[88,0.1,[9,8]]],[64,[33]],[303,true,1,0,1,1,2.0943951023931953,[9,1],[1,0,0,30]],[69,true,[34,1,[10,[0,1],[[36,2,3.187739463601533,3.187739463601533],[36,2,-1.189542483660131,-1.189542483660131]]]],[4],[4],[4]],[89,[4],[4],[4],[9,1]],[50,[4],[4],[4]],[103,[4],[4],[4],[4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-1320],[53,26]],[299,0.5,false,false,37,[1,"29mWnYmMBFMI0PcKpR9+w4"],[[27,null],6,0],[33],[25,3,0.3,0.6],[4],[4],[25,3,3,6],[4],[4],[4],[4],[25,3,0.6,0.8],[9,1.2],[4],[4],[[68,[25,3,2,4]],[88,0.1,[25,3,6,8]]],[64,[33]],[304,true,1,0,1,0.2,3.141592653589793,[9,1]],[69,true,[34,1,[10,[0,0.9717948717948718],[[11,2,0.4703703703703704,2.7238095238095235,2.7238095238095235],[36,2,-2.8888888888888884,-2.8888888888888884]]]],[4],[4],[4]],[89,[4],[4],[4],[9,1]],[50,[4],[4],[4]],[103,[4],[4],[4],[4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-1321],[53,28]],[134,0.5,false,1.6,false,45,[1,"51jHf7RV5LsZRGH1YCaNYQ"],[[29,null],6,0],[301,2,[4,4293841938]],[25,3,10,30],[4],[4],[25,3,90,140],[4],[4],[4],[4],[25,3,0.6,0.9],[9,16],[4],[4],[[68,[9,4]],[88,0.15,[9,8]]],[64,[33]],[305,true,1,0,1,10,[9,1]],[69,true,[34,1,[10,[0,0.9461538461538461],[[36,2,3.187739463601533,3.187739463601533],[36,2,-1.4925925925925914,-1.4925925925925914]]]],[4],[4],[4]],[89,[4],[4],[4],[9,1]],[50,[4],[4],[4]],[103,[4],[4],[4],[4]],[51,[4],[4],[4]],[52,[34,1,[10,[0,1],[[15,2,1],[15,2,1]]]],[4]],[70,[9,1],[4],[33],[33],-1322],[53,30]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[32,"Model Camera",8388608,1,[[330,1073741824,448.00000000000006,2000,6,8388608,-1323,[1,"64H//+1/xNU5X2wSrm6LIe"],[4,4278190080]]],[3,"55aB7t+VZOdbU3LMEaAlDi",1,0],[1,0,0,1000]]],0,[0,-1,58,0,-2,59,0,-3,60,0,-4,88,0,-5,19,0,-6,9,0,-7,2,0,-8,3,0,-9,4,0,-10,5,0,-11,6,0,-12,7,0,-13,8,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,9,0,2,9,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,2,0,2,2,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,3,0,2,3,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,4,0,2,4,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,5,0,2,5,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,6,0,2,6,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,7,0,2,7,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,8,0,2,8,0,1,58,0,1,60,0,1,59,0,1,58,0,2,122,0,1,60,0,2,122,0,1,59,0,2,122,0,1,19,0,2,161,0,9,1,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,24,0,-2,18,0,-3,169,0,-4,82,0,-5,123,0,3,97,0,3,97,0,3,97,0,3,97,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,3,10,0,9,2,0,3,98,0,3,98,0,3,98,0,3,98,0,3,68,0,3,68,0,3,68,0,3,68,0,3,68,0,9,3,0,3,69,0,3,69,0,3,69,0,3,69,0,3,69,0,9,4,0,3,99,0,3,99,0,3,99,0,3,99,0,3,46,0,3,46,0,3,46,0,3,46,0,3,46,0,3,46,0,9,5,0,3,100,0,3,100,0,3,100,0,3,100,0,3,47,0,3,47,0,3,47,0,3,47,0,3,47,0,3,47,0,9,6,0,3,101,0,3,101,0,3,101,0,3,101,0,3,48,0,3,48,0,3,48,0,3,48,0,3,48,0,3,48,0,9,7,0,3,102,0,3,102,0,3,102,0,3,102,0,3,49,0,3,49,0,3,49,0,3,49,0,3,49,0,3,49,0,9,8,0,3,168,0,3,168,0,9,9,0,0,11,0,13,36,0,0,11,0,0,11,0,13,91,0,1,11,0,1,16,0,1,11,0,1,11,0,1,11,0,1,19,0,0,11,0,0,11,0,0,11,0,0,11,0,0,11,0,-1,91,0,0,12,0,0,12,0,0,12,0,0,12,0,-1,65,0,-2,43,0,-3,13,0,-4,38,0,-5,115,0,-6,14,0,-7,83,0,-8,37,0,-9,45,0,0,13,0,0,13,0,13,13,0,1,13,0,1,66,0,0,13,0,0,13,0,0,13,0,-6,164,0,0,13,0,-1,94,0,-2,95,0,-3,66,0,0,14,0,0,14,0,13,14,0,1,16,0,1,14,0,1,82,0,1,14,0,0,14,0,0,14,0,0,14,0,0,14,0,-1,116,0,-2,147,0,0,15,0,0,15,0,-1,35,0,-2,17,0,-3,25,0,-4,61,0,-5,88,0,-6,19,0,0,16,0,28,156,0,0,16,0,0,17,0,0,17,0,0,17,0,36,127,0,0,17,0,1,17,0,36,127,0,0,17,0,0,17,0,-1,86,0,-2,87,0,0,18,0,0,18,0,0,18,0,-4,156,0,-2,36,0,-3,42,0,3,63,0,3,63,0,3,63,0,3,63,0,3,63,0,0,19,0,-2,161,0,9,19,0,0,20,0,-2,134,0,13,20,0,1,20,0,0,20,0,1,29,0,1,72,0,1,29,0,1,71,0,1,29,0,1,72,0,1,29,0,1,71,0,0,20,0,-1,50,0,-2,132,0,0,21,0,-2,138,0,13,21,0,1,21,0,0,21,0,1,30,0,1,75,0,1,30,0,1,74,0,1,30,0,1,75,0,1,30,0,1,74,0,0,21,0,-1,51,0,-2,136,0,0,22,0,-2,142,0,13,22,0,1,22,0,0,22,0,1,31,0,1,78,0,1,31,0,1,77,0,1,31,0,1,78,0,1,31,0,1,77,0,0,22,0,-1,52,0,-2,140,0,0,23,0,-2,146,0,13,23,0,1,23,0,0,23,0,1,32,0,1,81,0,1,32,0,1,80,0,1,32,0,1,81,0,1,32,0,1,80,0,0,23,0,-1,53,0,-2,144,0,0,24,0,-1,124,0,-2,151,0,-3,120,0,-4,119,0,-5,84,0,-6,90,0,0,25,0,0,25,0,0,25,0,0,25,0,-1,58,0,-2,59,0,-3,60,0,0,26,0,0,26,0,0,26,0,0,27,0,0,27,0,0,27,0,0,28,0,0,28,0,0,28,0,0,29,0,0,29,0,0,29,0,0,30,0,0,30,0,0,30,0,0,31,0,0,31,0,0,31,0,0,32,0,0,32,0,0,32,0,0,33,0,0,33,0,0,33,0,13,54,0,1,33,0,1,82,0,0,33,0,0,33,0,-1,54,0,0,34,0,0,34,0,0,34,0,13,55,0,1,34,0,1,119,0,0,34,0,0,34,0,-1,55,0,0,35,0,0,35,0,0,35,0,-1,56,0,-2,57,0,-3,40,0,0,36,0,0,36,0,-1,64,0,-1,166,0,0,37,0,0,37,0,0,37,0,-1,129,0,0,38,0,0,38,0,0,38,0,-1,67,0,-2,130,0,0,39,0,0,39,0,0,39,0,-1,148,0,-2,149,0,-3,150,0,0,40,0,0,40,0,0,40,0,41,157,0,36,159,0,0,40,0,-1,126,0,0,41,0,-2,160,0,0,41,0,25,160,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,43,0,-1,93,0,-2,44,0,0,44,0,-2,162,0,0,44,0,25,162,0,0,44,0,-1,167,0,0,45,0,0,45,0,0,45,0,0,50,0,0,50,0,0,50,0,-1,70,0,-2,104,0,0,51,0,0,51,0,0,51,0,-1,73,0,-2,107,0,0,52,0,0,52,0,0,52,0,-1,76,0,-2,110,0,0,53,0,0,53,0,0,53,0,-1,79,0,-2,113,0,0,54,0,0,54,0,0,54,0,-1,117,0,0,55,0,0,55,0,0,55,0,-1,118,0,0,56,0,0,56,0,0,56,0,-1,85,0,0,57,0,0,57,0,36,158,0,0,57,0,-1,125,0,9,58,0,9,59,0,9,60,0,0,61,0,0,61,0,0,61,0,-1,62,0,0,62,0,0,62,0,0,62,0,0,64,0,0,64,0,0,64,0,0,64,0,0,65,0,0,65,0,0,65,0,-1,92,0,0,66,0,1,129,0,1,96,0,0,66,0,-1,96,0,0,67,0,0,67,0,0,70,0,0,70,0,-1,103,0,-2,131,0,0,71,0,15,134,0,0,71,0,0,72,0,15,134,0,0,72,0,0,73,0,0,73,0,-1,106,0,-2,135,0,0,74,0,15,138,0,0,74,0,0,75,0,15,138,0,0,75,0,0,76,0,0,76,0,-1,109,0,-2,139,0,0,77,0,15,142,0,0,77,0,0,78,0,15,142,0,0,78,0,0,79,0,0,79,0,-1,112,0,-2,143,0,0,80,0,15,146,0,0,80,0,0,81,0,15,146,0,0,81,0,0,82,0,0,82,0,0,83,0,0,83,0,0,83,0,0,84,0,0,84,0,0,85,0,0,85,0,-3,157,0,0,86,0,0,86,0,-3,127,0,0,87,0,0,87,0,0,87,0,3,89,0,3,89,0,3,89,0,3,89,0,3,128,0,1,90,0,3,128,0,6,88,0,3,128,0,9,88,0,0,90,0,0,90,0,0,91,0,0,91,0,0,92,0,0,92,0,0,92,0,0,93,0,0,93,0,0,93,0,0,94,0,0,94,0,0,94,0,0,95,0,-2,163,0,25,163,0,0,95,0,0,96,0,28,164,0,0,96,0,0,103,0,0,103,0,0,103,0,0,104,0,0,104,0,0,105,0,0,106,0,0,106,0,0,106,0,0,107,0,0,107,0,0,108,0,0,109,0,0,109,0,0,109,0,0,110,0,0,110,0,0,111,0,0,112,0,0,112,0,0,112,0,0,113,0,0,113,0,0,114,0,0,115,0,0,115,0,0,115,0,0,116,0,0,116,0,0,116,0,0,117,0,0,117,0,0,117,0,0,118,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,-1,152,0,-2,121,0,0,121,0,-2,122,0,0,123,0,-1,154,0,-2,155,0,0,124,0,0,125,0,-2,158,0,0,126,0,-2,159,0,-1,165,0,0,130,0,0,130,0,0,131,0,0,131,0,0,132,0,-1,133,0,0,133,0,0,135,0,0,135,0,0,136,0,-1,137,0,0,137,0,0,139,0,0,139,0,0,140,0,-1,141,0,0,141,0,0,143,0,0,143,0,0,144,0,-1,145,0,0,145,0,0,147,0,0,147,0,0,148,0,0,148,0,0,149,0,0,149,0,0,150,0,0,150,0,0,151,0,0,151,0,0,152,0,-1,153,0,0,153,0,0,153,0,0,154,0,0,154,0,0,155,0,0,155,0,18,165,0,18,166,0,18,167,0,0,169,0,21,1,2,5,26,3,5,26,4,5,26,5,5,27,6,5,27,7,5,27,8,5,27,9,5,26,11,5,36,12,5,42,15,5,18,16,5,124,20,5,28,21,5,28,22,5,28,23,5,28,26,5,67,27,5,67,28,5,38,29,5,104,30,5,107,31,5,110,32,5,113,33,5,42,34,5,42,39,5,83,41,5,62,71,5,105,72,5,105,74,5,108,75,5,108,77,5,111,78,5,111,80,5,114,81,5,114,105,5,133,108,5,137,111,5,141,114,5,145,1323],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,157,158,159,127,160,162,163,164,134,138,142,146,156],[4,4,4,4,4,-1,12,12,12,4,4,12,12,4,-1,29,4,4,14,27,4,4,4,4,4,-1,19,-1,19,-1,19,4,14,-1,-2,-3,-4,-5,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,4,4,4,4,4,4,14,30,31,32,4,4,4,4,4,14,30,31,32,4,4,4,4,4,14,30,31,32,4,4,4,4,4,14,30,31,32,11,4,11,4,14,27,4,4,4,-1,29,4,11,4,4,14,27,11,4,4,14,27,-1,-2,-3,-4,-5,-6,-7,-8,-9,4,11,11,11,11,11,11,20,4,4,4,4,20],[17,150,17,35,17,60,18,18,18,1,1,151,61,152,8,8,153,7,7,154,22,22,36,1,1,62,37,155,63,62,37,1,1,64,65,66,67,68,3,69,70,71,72,3,73,74,75,76,3,38,39,40,41,3,42,77,78,79,3,80,81,82,83,3,84,85,86,87,3,88,89,90,91,3,92,93,94,95,6,23,43,44,7,2,2,12,13,14,23,96,97,7,2,2,12,13,14,98,99,100,7,2,2,12,13,14,101,102,103,7,2,2,12,13,14,4,1,0,1,1,24,5,5,5,104,104,6,0,1,1,1,24,0,1,1,1,24,105,106,107,108,109,156,157,110,111,6,0,0,0,0,0,0,158,2,2,2,2,159]],[[[97,"0",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4286545791],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[28,11]],[[[58,[[59,[60,[-20,-21,-22,-23,-24,-25,-26,-27,-28],[[24,0,false,-5,-4,[[72,[46,"questComplete"]],[104,1,[46,"hasAd"]]]],[24,0,false,-7,-6,[[35,"claim"]]],[24,0,false,-9,-8,[[72,[46,"questComplete"]],[72,[46,"hasAd"]]]],[24,0,false,-11,-10,[[35,"claim"]]],[65,-13,-12],[223,0,-15,-14,[[72,[46,"questActive"]]]],[24,0,false,-17,-16,[[72,[46,"hasAd"]]]],[24,0,false,-19,-18,[[104,1,[46,"hasAd"]]]]],-3,-2,-1]]],[{},"hasAd",4,[28,1,true],"questComplete",4,[28,1,false],"claim",4,[28,2,false],"questActive",4,[28,1,false]]],[18,"QuestPanel_QuestComplete",[21,2],[19,1]],[18,"QuestPanel_QuestCompleteAd",[21,4],[19,1]],[18,"QuestPanel_Default",[21,0],[19,1]],[26,"Entry"],[18,"Hidden",[21,5],[19,1]],[26,"Exit"],[26,"Any"],[18,"QuestPanel_QuestClaim",[21,1],[19,1]],[18,"QuestPanel_QuestClaimAd",[21,3],[19,1]]],0,[0,22,7,0,23,6,0,24,4,0,7,1,0,8,3,0,7,8,0,8,1,0,7,2,0,8,3,0,7,9,0,8,2,0,7,5,0,8,4,0,7,3,0,8,5,0,7,2,0,8,1,0,7,1,0,8,2,0,-1,4,0,-2,6,0,-3,7,0,-4,3,0,-5,8,0,-6,1,0,-7,9,0,-8,2,0,-9,5,28],[0,0,0,0,0,0],[10,10,10,10,10,10],[112,113,114,115,116,117]],[[[58,[[59,[60,[-18,-19,-20,-21,-22,-23,-24,-25],[[24,0,false,-5,-4,[[35,"notReady"]]],[335,-7,-6,[[35,"ready"]]],[80,0,-9,-8],[24,0,false,-11,-10,[[72,[46,"inUse"]]]],[24,0,false,-13,-12,[[104,1,[46,"inUse"]]]],[24,0,false,-15,-14,[[35,"ready"]]],[80,0,-17,-16]],-3,-2,-1]]],[{},"ready",4,[28,2,false],"notReady",4,[28,2,false],"inUse",4,[28,1,false]]],[18,"ButtonDash_Enabled",[21,2],[19,1]],[26,"Entry"],[26,"Any"],[18,"AbilityButton_Intro",[21,0],[19,1]],[18,"AbilityButton_Exit",[21,1],[19,1]],[18,"ButtonDash_InUse",[21,3],[19,1]],[18,"AbilityButton_ReEnabled",[21,4],[19,1]],[26,"Exit"]],0,[0,22,3,0,23,8,0,24,2,0,7,5,0,8,3,0,7,4,0,8,2,0,7,1,0,8,4,0,7,6,0,8,1,0,7,1,0,8,6,0,7,7,0,8,5,0,7,1,0,8,7,0,-1,2,0,-2,8,0,-3,3,0,-4,4,0,-5,5,0,-6,1,0,-7,6,0,-8,7,25],[0,0,0,0,0],[10,10,10,10,10],[33,50,49,48,51]],[[[54,"Game Snacks"],[167,"Game Snacks",[-2,-3],[3,"acp44HAtRKRp9kN/i3h8QP",-1,0]],[141,"On Game Ready",1,[[336,-4,[1,"5bY+7U7v5Kjppgp+uFNb4L"]],[95,22,-6,[1,"92UPlZyNxGqqBl99Vpqjmn"],[[6,"61531xMjfdJtLGPUfndQAv7","ready",-5]]]],[3,"ca2bVpkExJYb2pCZ7J5l0Z",1,0]],[141,"Ads",1,[[337,-7,[1,"34GiASzURL4oQ+4x6jIh5P"]]],[3,"67mmgH9U5EgoAd/L0wACrX",1,0]]],0,[0,9,1,0,-1,2,0,-2,3,0,0,2,0,1,2,0,0,2,0,0,3,0,21,1,7],[],[],[]],[[[338,"SCNE_Game"],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-49,[38,"824amZy+RHKoqPW8uk6q6o",-48,[[7,"Slime_02",["_name"],-1],[12,["_lpos"],-2,[1,-32,0,0]],[12,["_lrot"],-3,[3,0,0,0,1]],[12,["_euler"],-4,[1,0,0,0]],[14,"1",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,1,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,1,["_textureID"],-5],[7,4,["_iconTextures","length"],-6],[13,["_iconTextures","0"],-7,31],[13,["_iconTextures","1"],-8,32],[13,["_iconTextures","2"],-9,33],[13,["_iconTextures","3"],-10,34],[7,null,["_iconTextures","4"],-11],[7,null,["_iconTextures","5"],-12],[7,null,["_iconTextures","6"],-13],[7,null,["_iconTextures","7"],-14],[7,null,["_iconTextures","8"],-15],[7,null,["_iconTextures","9"],-16],[7,null,["_iconTextures","10"],-17],[7,null,["_iconTextures","11"],-18],[7,null,["_iconTextures","12"],-19],[7,null,["_iconTextures","13"],-20],[7,null,["_iconTextures","14"],-21],[7,null,["_iconTextures","15"],-22],[7,null,["_iconTextures","16"],-23],[7,null,["_iconTextures","17"],-24],[7,null,["_iconTextures","18"],-25],[7,null,["_iconTextures","19"],-26],[7,null,["_iconTextures","20"],-27],[7,null,["_iconTextures","21"],-28],[7,null,["_iconTextures","22"],-29],[7,null,["_iconTextures","23"],-30],[7,null,["_iconTextures","24"],-31],[7,null,["_iconTextures","25"],-32],[7,null,["_iconTextures","26"],-33],[7,null,["_iconTextures","27"],-34],[7,null,["_iconTextures","28"],-35],[7,null,["_iconTextures","29"],-36],[7,null,["_iconTextures","30"],-37],[7,null,["_iconTextures","31"],-38],[7,null,["_iconTextures","32"],-39],[7,null,["_iconTextures","33"],-40],[7,null,["_iconTextures","34"],-41],[7,null,["_iconTextures","35"],-42],[7,null,["_iconTextures","36"],-43],[7,null,["_iconTextures","37"],-44],[7,null,["_iconTextures","38"],-45],[7,null,["_iconTextures","39"],-46],[7,null,["_iconTextures","40"],-47]]],30]],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-60,[38,"a2ofGOsYtC6IX8DWpup88Q",-59,[[7,"Slime_03",["_name"],-50],[12,["_lpos"],-51,[1,30,0,0]],[12,["_lrot"],-52,[3,0,0,0,1]],[12,["_euler"],-53,[1,0,0,0]],[13,["_iconTextures","0"],-54,36],[7,4,["_iconTextures","length"],-55],[13,["_iconTextures","1"],-56,37],[13,["_iconTextures","2"],-57,38],[13,["_iconTextures","3"],-58,39]]],35]],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-67,[38,"6eBZGCeihBnYFbMbgkpiRM",-66,[[14,"Slime_04",["_name"],[0,["cdSEaiObZBOIHsO1usqOZf"]]],[23,["_lpos"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,92,0,0]],[23,["_lrot"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[3,0,0,0,1]],[23,["_euler"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,0,0,0]],[14,3,["_textureID"],[0,["0bWPbJX8RH7awiNvx1sojn"]]],[13,["_iconTextures","0"],-61,41],[13,["_iconTextures","1"],-62,42],[13,["_iconTextures","2"],-63,43],[13,["_iconTextures","3"],-64,44],[7,4,["_iconTextures","length"],-65]]],40]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-79,[38,"4excq5lYZIbqGOoKRp2GIj",-78,[[7,"SlimeButton_01",["_name"],-68],[12,["_lpos"],-69,[1,-94,0,0]],[12,["_lrot"],-70,[3,0,0,0,1]],[12,["_euler"],-71,[1,0,0,0]],[14,"4",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,4,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,4,["_textureID"],-72],[7,4,["_iconTextures","length"],-73],[13,["_iconTextures","0"],-74,46],[13,["_iconTextures","1"],-75,47],[13,["_iconTextures","2"],-76,48],[13,["_iconTextures","3"],-77,49]]],45]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-91,[38,"d2bcEn49FApYkpzepqGTL7",-90,[[7,"SlimeButton_02",["_name"],-80],[12,["_lpos"],-81,[1,-32,0,0]],[12,["_lrot"],-82,[3,0,0,0,1]],[12,["_euler"],-83,[1,0,0,0]],[14,"5",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,5,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,5,["_textureID"],-84],[7,4,["_iconTextures","length"],-85],[13,["_iconTextures","0"],-86,51],[13,["_iconTextures","1"],-87,52],[13,["_iconTextures","2"],-88,53],[13,["_iconTextures","3"],-89,54]]],50]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-103,[38,"44Ig17Fz1AxYDgu8rZAHM/",-102,[[7,"SlimeButton_03",["_name"],-92],[12,["_lpos"],-93,[1,30,0,0]],[12,["_lrot"],-94,[3,0,0,0,1]],[12,["_euler"],-95,[1,0,0,0]],[14,"6",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,6,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,6,["_textureID"],-96],[7,4,["_iconTextures","length"],-97],[13,["_iconTextures","0"],-98,56],[13,["_iconTextures","1"],-99,57],[13,["_iconTextures","2"],-100,58],[13,["_iconTextures","3"],-101,59]]],55]],[39,0,{},[30,"cdSEaiObZBOIHsO1usqOZf",-115,[38,"a4t33cSwlFuph8i/gOjz1P",-114,[[7,"SlimeButton_04",["_name"],-104],[12,["_lpos"],-105,[1,92,0,0]],[12,["_lrot"],-106,[3,0,0,0,1]],[12,["_euler"],-107,[1,0,0,0]],[14,"7",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,7,["_textureID"],[0,["81VU5noKBCgp588aEIgZBx"]]],[7,7,["_textureID"],-108],[7,4,["_iconTextures","length"],-109],[13,["_iconTextures","0"],-110,61],[13,["_iconTextures","1"],-111,62],[13,["_iconTextures","2"],-112,63],[13,["_iconTextures","3"],-113,64]]],60]],[39,0,null,[30,"cdSEaiObZBOIHsO1usqOZf",-119,[38,"c4XQqIruFKhavqAzSlEINe",-118,[[14,"Slime_01",["_name"],[0,["cdSEaiObZBOIHsO1usqOZf"]]],[23,["_lpos"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,-94,0,0]],[23,["_lrot"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[3,0,0,0,1]],[23,["_euler"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[1,0,0,0]],[14,"0",["data"],[0,["bc+SEl3L9CmouJpyp/6LVT"]]],[14,true,["_active"],[0,["a9ZGpF4KJAiL0ztiE2eQ3i"]]],[14,0.7,["_alphaThreshold"],[0,["80o2WsLwFMvpogdgoXBNPI"]]],[14,4,["_iconTextures","length"],[0,["0bWPbJX8RH7awiNvx1sojn"]]],[99,["_iconTextures","0"],[0,["0bWPbJX8RH7awiNvx1sojn"]],66],[99,["_iconTextures","1"],[0,["0bWPbJX8RH7awiNvx1sojn"]],67],[99,["_iconTextures","2"],[0,["0bWPbJX8RH7awiNvx1sojn"]],68],[13,["_iconTextures","3"],-116,69],[14,false,["_enabled"],[0,["eb9r9ISWBJ2YZXxulicMaQ"]]],[7,0,["_textureID"],-117]]],65]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[39,0,null,[30,"42eXoQaSpLhpUcJXK7t987",-132,[123,"a7asuXfZxLKYqyU4YzovgD",-131,[[176,[0,["42eXoQaSpLhpUcJXK7t987"]],[[83,20,50,0,-129,[1,"6fhbjTUmRLfZaACWWHv552"]],[37,-130,[1,"d8LjvDOGNCr4lEtCfdVmxE"]]]]],[[7,"VirtualJoystick",["_name"],-120],[12,["_lpos"],-121,[1,0,-334,0]],[12,["_lrot"],-122,[3,0,0,0,1]],[12,["_euler"],-123,[1,0,0,0]],[7,0,["style"],-124],[7,false,["_active"],-125],[7,0,["_timeToReposition"],-126],[7,10,["_minMovementDistance"],-127],[7,0.01,["_minMovementScreenHeightRatio"],-128]]],18]],[39,0,{},[173,"c0Gf4wU+xGbIXyFvJqa514",-145,[124,"0ekzSHYsRHU6Se16uCTP7y",[[7,"Canvas_Start",["_name"],-141],[12,["_lpos"],-142,[1,207,448,0]],[12,["_lrot"],-143,[3,0,0,0,1]],[12,["_euler"],-144,[1,0,0,0]]]],[[2,["_states","0","onSetState","0","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],1,[0,["81VU5noKBCgp588aEIgZBx"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],2,[0,["81VU5noKBCgp588aEIgZBx"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],3,[0,["81VU5noKBCgp588aEIgZBx"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],4,[0,["81VU5noKBCgp588aEIgZBx"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],5,[0,["81VU5noKBCgp588aEIgZBx"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],6,[0,["81VU5noKBCgp588aEIgZBx"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","0","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","0","onSetState","1","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","0","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","1","onSetState","1","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_states","1","onSetState","2","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","0","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_states","2","onSetState","1","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["e0noLLsUpMBJBH/79jASAh"]]],[2,["_states","2","onSetState","2","target"],7,[0,["81VU5noKBCgp588aEIgZBx"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","0","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","1","onSetState","0","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","2","onSetState","0","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","3","onSetState","0","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","4","onSetState","0","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","5","onSetState","0","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","0","onSetState","0","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","0","onSetState","1","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","0","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["a58nFHGaRGE6RRrhbhtywz"]]],[2,["_skinStates","1","onSetState","1","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","0","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","2","onSetState","1","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","0","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","3","onSetState","1","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","0","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["d11Vf+nwlLqolLuhwlcE+U"]]],[2,["_skinStates","4","onSetState","1","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","0","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["b9VHtMfm5Gros3/7lXfdzn"]]],[2,["_skinStates","5","onSetState","1","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],8,[0,["0bWPbJX8RH7awiNvx1sojn"]],8,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],1,[0,["0bWPbJX8RH7awiNvx1sojn"]],1,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],2,[0,["0bWPbJX8RH7awiNvx1sojn"]],2,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],3,[0,["0bWPbJX8RH7awiNvx1sojn"]],3,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],4,[0,["0bWPbJX8RH7awiNvx1sojn"]],4,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],5,[0,["0bWPbJX8RH7awiNvx1sojn"]],5,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],6,[0,["0bWPbJX8RH7awiNvx1sojn"]],6,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[2,["_skinStates","0","onSetState","1","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","0","onSetState","2","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","0","onSetState","3","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","0","onSetState","4","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","1","onSetState","1","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","1","onSetState","2","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","1","onSetState","3","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["6fi6J+0rNCM6fMlqjwnkAH"]]],[2,["_skinStates","1","onSetState","4","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["ceRRHJgqBL8p7+Q8XLuSY/"]]],[2,["_skinStates","2","onSetState","1","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","2","onSetState","2","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","2","onSetState","3","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","2","onSetState","4","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","2","onSetState","5","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","3","onSetState","1","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["2doxxuKG1LZ6d9sNviZ1rQ"]]],[2,["_skinStates","3","onSetState","2","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","3","onSetState","3","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","3","onSetState","4","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","3","onSetState","5","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","4","onSetState","1","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","4","onSetState","2","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","4","onSetState","3","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","4","onSetState","4","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","4","onSetState","5","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_skinStates","5","onSetState","1","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["ca2q88Y8RM97NDDGqMllNM"]]],[2,["_skinStates","5","onSetState","2","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["e57tLFdkBBR45E9mtwp8t9"]]],[2,["_skinStates","5","onSetState","3","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["51aFXvKRRPfKh8x5o6tjpa"]]],[2,["_skinStates","5","onSetState","4","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["8evzYidutLVKEvQCBtvh6m"]]],[2,["_skinStates","5","onSetState","5","target"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["9cl3fMDB9HMKfIISB6A8JN"]]],[2,["_spriteRenderer"],7,[0,["0bWPbJX8RH7awiNvx1sojn"]],7,[0,["e0rGZmPDtEIZmUFyCpnCcM"]]],[67,["_missionEntries","0"],-133,[0,["9aYImQxz1C2qqP21T/n86m"]]],[67,["_missionEntries","1"],-134,[0,["9aYImQxz1C2qqP21T/n86m"]]],[67,["_missionEntries","2"],-135,[0,["9aYImQxz1C2qqP21T/n86m"]]],[67,["_missionEntries","0"],-136,[0,["9aYImQxz1C2qqP21T/n86m"]]],[67,["_missionEntries","1"],-137,[0,["9aYImQxz1C2qqP21T/n86m"]]],[67,["_missionEntries","2"],-138,[0,["9aYImQxz1C2qqP21T/n86m"]]],[107,["_anim"],-140,-139,[0,["4b9lnAZ2xFqoPsW5jLpiuK"]]]],29]],[39,0,{},[250,"9dti4iiGNLDaJ2TOWKutaW",[],-150,[124,"0b9ndJb91Nv5XQMDJJa7TR",[[7,"Canvas_GameOver",["_name"],-146],[12,["_lpos"],-147,[1,207,448,0]],[12,["_lrot"],-148,[3,0,0,0,1]],[12,["_euler"],-149,[1,0,0,0]]]],16]],[339,"SCNE_Game",[-168,-169,-170,-171,-172,-173,12,-174,-175,-176,-177,-178,-179,11],[249,"46f60bea-ae29-4285-b2e0-86d90bace604",[[2,["_target"],-157,[0,["6cThmK0MNJ5ablx8K2qlwF"]],-156,[0,["21tZhtdHxIa4aI3Jf+kxqZ"]]],[2,["_target"],12,[0,["73BMafO+BODYZuDQ85/pjY"]],12,[0,["0dwYuL91FNNLxKcLkRp4Ux"]]],[2,["_onEventRaised","0","target"],12,[0,["1ebI2AHE1HlZkfUJ8UnqWK"]],12,[0,["17xNGSEwlIZqrSbQ2F25Y1"]]],[67,["_onEventRaised","0","target"],12,[0,["17xNGSEwlIZqrSbQ2F25Y1"]]],[2,["_trailModule","_particleSystem"],-159,[0,["e5xTtVtZpCrKvrw0x1bMQc"]],-158,[0,["e5xTtVtZpCrKvrw0x1bMQc"]]],[2,["contentOpacity"],-161,[0,["a7asuXfZxLKYqyU4YzovgD","ebgbn3fThK4JifW7C4wLtr"]],-160,[0,["a7asuXfZxLKYqyU4YzovgD","47B7CdLgJKsoeGjd7pw7eC"]]],[2,["pivot"],-163,[0,["a7asuXfZxLKYqyU4YzovgD","ebgbn3fThK4JifW7C4wLtr"]],-162,[0,["a7asuXfZxLKYqyU4YzovgD","36eZrS80hBy4UjhY7Yjyzk"]]],[2,["tweenShow"],-165,[0,["a7asuXfZxLKYqyU4YzovgD","ebgbn3fThK4JifW7C4wLtr"]],-164,[0,["a7asuXfZxLKYqyU4YzovgD","31hEm0catFwZfOtf5zXnFq"]]],[2,["tweenHide"],-167,[0,["a7asuXfZxLKYqyU4YzovgD","ebgbn3fThK4JifW7C4wLtr"]],-166,[0,["a7asuXfZxLKYqyU4YzovgD","486diRHOBMNpDwYZcx/+uU"]]],[2,["clickEvents","0","target"],11,[0,["e1yludQFJHgJ1EPBKr/GJv"]],11,[0,["52qbE7OrxJl4ftWh2MUE+N"]]],[2,["clickEvents","1","target"],11,[0,["e1yludQFJHgJ1EPBKr/GJv"]],11,[0,["607ShHjVNKkrvYDe/ZdyJn"]]],[2,["clickEvents","2","target"],11,[0,["e1yludQFJHgJ1EPBKr/GJv"]],11,[0,["c7HgV3niVEgaxltEPdnZxT"]]],[2,["_target"],11,[0,["e1yludQFJHgJ1EPBKr/GJv"]],11,[0,["054KJj3ttOGLrFZBm6qXtN"]]],[2,["_onEventRaised","0","target"],12,[0,["b2Tkfv5QtOK7wQHFtDOLfA"]],12,[0,["17xNGSEwlIZqrSbQ2F25Y1"]]],[2,["_onEventRaised","1","target"],12,[0,["b2Tkfv5QtOK7wQHFtDOLfA"]],12,[0,["f8upUNcoJPCpopxlliuAz9"]]],[2,["_onEventRaised","2","target"],12,[0,["b2Tkfv5QtOK7wQHFtDOLfA"]],12,[0,["81X8yiOcVN7aQhw9ETj27H"]]],[2,["_onEventRaised","3","target"],12,[0,["b2Tkfv5QtOK7wQHFtDOLfA"]],12,[0,["76MW9bcoNIE6SvaE/akl5r"]]],[2,["_onEventRaised","4","target"],12,[0,["b2Tkfv5QtOK7wQHFtDOLfA"]],12,[0,["49a299KLhNjrSPX+FfcTkL"]]],[2,["_onEventRaised","5","target"],12,[0,["b2Tkfv5QtOK7wQHFtDOLfA"]],12,[0,["813kocdfBMQZbXIEeW89nC"]]],[2,["_onEventRaised","6","target"],12,[0,["b2Tkfv5QtOK7wQHFtDOLfA"]],12,[0,["a4O/AZ0xRK/bMkMLfiDK9i"]]]],[-151,12,-152,-153,-154,-155,11]],[340,[341,0.5208,[2,0.361279,0.71838,0.870561,0.520833125],[2,0.677381,0.714561,0.758035,0]],[342,[4,4283190348]],[343],[344],[345]]],[55,0,null,13,[173,"66h8u49P5OCLios+1KOjSE",-180,[175,"a36w3HoIhCGLzF6eKlkNX/",null,[[14,"P-Joystick-Canvas",["_name"],[0,["66h8u49P5OCLios+1KOjSE"]]],[23,["_lpos"],[0,["66h8u49P5OCLios+1KOjSE"]],[1,207,448,0]],[23,["_lrot"],[0,["66h8u49P5OCLios+1KOjSE"]],[3,0,0,0,1]],[23,["_euler"],[0,["66h8u49P5OCLios+1KOjSE"]],[1,0,0,0]],[14,false,["_active"],[0,["16N48avrhFG4Vn5U0lW9Lz"]]]]],[[2,["contentOpacity"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["47B7CdLgJKsoeGjd7pw7eC"]]],[2,["pivot"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["36eZrS80hBy4UjhY7Yjyzk"]]],[2,["tweenShow"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["31hEm0catFwZfOtf5zXnFq"]]],[2,["tweenHide"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["486diRHOBMNpDwYZcx/+uU"]]],[2,["joystickBG"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["50Ujxr/aNFMatRB+3sT/Nf"]]],[2,["_contentOpacity"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["47B7CdLgJKsoeGjd7pw7eC"]]],[2,["_pivot"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["36eZrS80hBy4UjhY7Yjyzk"]]],[2,["_joystickBG"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["50Ujxr/aNFMatRB+3sT/Nf"]]],[2,["_tweenShow"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["31hEm0catFwZfOtf5zXnFq"]]],[2,["_tweenHide"],10,[0,["ebgbn3fThK4JifW7C4wLtr"]],10,[0,["486diRHOBMNpDwYZcx/+uU"]]]],17]],[231,"Floor","16Zppp1VVPiKV/vSwUZY89",13,[-184,-185,-186,-187],[[116,"Plane<ModelComponent>",false,-181,[12],[117],13],[346,2,-182],[347,-183,14]],[1,10,1,10]],[55,0,{},13,[30,"75Fsxflk5LJIE6aYq2/I7H",-188,[175,"8aB7rj5tZLQKDePtdD9RTx",null,[[14,"P-Game-Canvas",["_name"],[0,["75Fsxflk5LJIE6aYq2/I7H"]]],[23,["_lpos"],[0,["75Fsxflk5LJIE6aYq2/I7H"]],[1,207,448,0]],[23,["_lrot"],[0,["75Fsxflk5LJIE6aYq2/I7H"]],[3,0,0,0,1]],[23,["_euler"],[0,["75Fsxflk5LJIE6aYq2/I7H"]],[1,0,0,0]],[14,2,["_alignMode"],[0,["b8daAJU7VPYZL0vKjPM7+N"]]],[14,1,["_alignMode"],[0,["1aY9wSNqVDBpRs3L2gCPC7"]]],[14,2,["_alignMode"],[0,["adWONl/O1BqZu3ceRRx8yR"]]],[14,2,["_alignMode"],[0,["aamgu33UhJypdr3a61Th7n"]]],[14,false,["_active"],[0,["2fKNyZaqBKFJ8YD+zsVeyv"]]],[14,true,["playOnLoad"],[0,["532FH0vSxLFZPLVQKr6qYI"]]],[14,true,["playOnLoad"],[0,["cffMTr6FdLW6jbrLY7gD2O"]]],[14,false,["_active"],[0,["39hykByQlP55wzBSX7V1Ry"]]],[14,2,["_alignMode"],[0,["29yJcljBxFEZRz3pDHuQbI"]]]]],15]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["42eXoQaSpLhpUcJXK7t987"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[0,["777+abRRVCaJ/XO2ZnoFXZ"]],[241,"Main Camera","08BAdmYi1C5Y8jFKubSSTJ",13,[[-189,-190,[348,5,-192,-191,[1,0,18.318,17.703],[1,0,52.77,43.891]]],1,1,4],[1,0,13.603,10.553],[3,-0.3826834323650898,0,0,0.9238795325112867],[1,-45,0,0]],[0,["9dti4iiGNLDaJ2TOWKutaW"]],[232,"TS-Scene-Loader",[[349,"SCNE_Game",-193]]],[233,"Scripts",[27,-194,-195]],[0,["ebgbn3fThK4JifW7C4wLtr"]],[0,["85+0ISycpGH4Xce8S7Yv4z"]],[0,["acp44HAtRKRp9kN/i3h8QP"]],[0,["c0Gf4wU+xGbIXyFvJqa514"]],[119,"New Node"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[119,"New Node"],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[0,["cdSEaiObZBOIHsO1usqOZf"]],[247,0,{},[119,"New Node"],[30,"777+abRRVCaJ/XO2ZnoFXZ",-198,[123,"5a22KD2p9N5oaaYhT79ULB",11,[[177,[0,["777+abRRVCaJ/XO2ZnoFXZ"]],[[[37,-196,[1,"e5xj+Q+3hI0rReL8NhAb3n"]],-197],4,1]]],[[7,"Holder_Handy Guide",["_name"],24],[12,["_lpos"],24,[1,0,-80,0]],[12,["_lrot"],24,[3,0,0,0,1]],[12,["_euler"],24,[1,0,0,0]],[7,true,["_active"],24]]],73]],[234,"UI Camera",33554432,"5dQBbNh3FCHLBbUtHjq7aX",13,[[331,0,1073741824,448.00000000000006,2000,6,33554432,-199,[4,4278190080]],[350,-200]],[1,207,448,1000]],[120,"left wall",15,[[116,"Cube<ModelComponent>",false,-201,[0],[117],1],[137,-202,2]],[1,-8,5,0],[1,0.1,10,16]],[120,"right wall",15,[[116,"Cube<ModelComponent>",false,-203,[3],[117],4],[137,-204,5]],[1,8,5,0],[1,0.1,10,16]],[120,"back wall",15,[[116,"Cube<ModelComponent>",false,-205,[6],[117],7],[137,-206,8]],[1,0,5,-8],[1,16,10,0.1]],[120,"front wall",15,[[116,"Cube<ModelComponent>",false,-207,[9],[117],10],[137,-208,11]],[1,0,5,8],[1,16,10,0.1]],[168,"Slime Foods","c0Es4wmc1GjKbI6LzyRGwZ",13,[-209,-210]],[168,"Game","98+U354KRDsrDRKiBO3MoJ",13,[-211,28]],[169,"Listeners",48,[-212,-213]],[55,0,null,13,[30,"85+0ISycpGH4Xce8S7Yv4z",-214,[124,"a0Kf79i1pBubScw8DUPkn/",[[7,"P-Battle-Royale",["_name"],30],[12,["_lpos"],30,[1,0,0,0]],[12,["_lrot"],30,[3,0,0,0,1]],[12,["_euler"],30,[1,0,0,0]]]],19]],[55,0,{},13,[30,"71lw8f08xOeIZ3VBta/UME",-221,[252,"09GuQtAcNL66HIGyNRjN6I",null,[[178,[0,["05hKehV2RLE4u/DbpR3YPX"]],[-219]],[178,[0,["7clwv7EipANYHfCEfJhrWY"]],[-220]]],[[14,"P-DailyMissionsManager",["_name"],[0,["71lw8f08xOeIZ3VBta/UME"]]],[23,["_lpos"],[0,["71lw8f08xOeIZ3VBta/UME"]],[1,0,0,0]],[23,["_lrot"],[0,["71lw8f08xOeIZ3VBta/UME"]],[3,0,0,0,1]],[23,["_euler"],[0,["71lw8f08xOeIZ3VBta/UME"]],[1,0,0,0]],[270,["_dailyMissionDataFactory"],[0,["d0qGwy+qhBxL2bSAGVMqHm"]],-215],[7,false,["_resetMissions"],-216],[189,["_dailyMissionRewardFactory"],-218,-217]]],27]],[55,0,null,13,[30,"acp44HAtRKRp9kN/i3h8QP",-222,[124,"83oQDmkI5Af68VzcBjwnVG",[[7,"Game Snacks",["_name"],31],[12,["_lpos"],31,[1,0,0,0]],[12,["_lrot"],31,[3,0,0,0,1]],[12,["_euler"],31,[1,0,0,0]]]],28]],[39,0,null,[30,"b9tpjlp9VBian0Vwn0pf6D",-223,[38,"b3tOVP8rxHD5nP5Hxhl5j4",11,[[14,"Panel_Daily Mission 01",["_name"],[0,["b9tpjlp9VBian0Vwn0pf6D"]]],[23,["_lpos"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,-132,0,0]],[23,["_lrot"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[3,0,0,0,1]],[23,["_euler"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]]]],70]],[119,"New Node"],[55,0,null,54,[30,"b9tpjlp9VBian0Vwn0pf6D",-224,[38,"13annH44tKPbqE+WfKZ4gl",11,[[14,"Panel_Daily Mission 03",["_name"],[0,["b9tpjlp9VBian0Vwn0pf6D"]]],[23,["_lpos"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,132,0,0]],[23,["_lrot"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[3,0,0,0,1]],[23,["_euler"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]]]],71]],[55,0,null,54,[30,"b9tpjlp9VBian0Vwn0pf6D",-225,[38,"bahBrJjSlGAYxsBY/QwS5b",11,[[14,"Panel_Daily Mission 02",["_name"],[0,["b9tpjlp9VBian0Vwn0pf6D"]]],[23,["_lpos"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]],[23,["_lrot"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[3,0,0,0,1]],[23,["_euler"],[0,["b9tpjlp9VBian0Vwn0pf6D"]],[1,0,0,0]]]],72]],[332,55,50,14,1074790415,25],[352,0.95,25,[1,0,18.318,17.703],[1,-45,0,0],57],[235,"Slimes","02af7ipwVBn7FD5019W9II",13,[[353,-226]],[1,0,0.001,0]],[246,"Spawn Area",16777216,47,[-227],[1,0,1.38,0]],[351,true,60,[1,155,1,155]],[169,"Scripts",47,[-228]],[106,"TS-SlimeFood-Spawner",62,[[354,0.3,-229,[355,50,200],61]]],[106,"Restart",49,[[271,"game-restart",-230,[[6,"dc5a4s/i7VEl7L/oMyoeK+/","loadScene",27]]]]],[106,"TS-Game-Victory-Tracker",28,[[357,[],-231]]],[106,"XpReward",28,[[358,-232]]],[106,"Started",49,[[272,0,-233,[[6,"dc5a4s/i7VEl7L/oMyoeK+/","preloadScene",27]]]]],[236,"SafeAreaMaterials","2dWEINYZRM4KYBZZPlq1sO",13,[[359,-234,[20,21,22,23,24,25,26]]]],[360],[361],[0,["d0qGwy+qhBxL2bSAGVMqHm"]],[0,["0bWPbJX8RH7awiNvx1sojn"]],[201,true,41,[1,"32qKsC8RZN9Jv+ObqF6Ehx"]]],0,[0,3,34,0,3,34,0,3,34,0,3,34,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,3,9,0,26,11,0,9,1,0,3,35,0,3,35,0,3,35,0,3,35,0,3,22,0,3,22,0,3,22,0,3,22,0,3,22,0,26,11,0,9,2,0,3,23,0,3,23,0,3,23,0,3,23,0,3,23,0,26,11,0,9,3,0,3,37,0,3,37,0,3,37,0,3,37,0,3,17,0,3,17,0,3,17,0,3,17,0,3,17,0,3,17,0,26,11,0,9,4,0,3,38,0,3,38,0,3,38,0,3,38,0,3,18,0,3,18,0,3,18,0,3,18,0,3,18,0,3,18,0,26,11,0,9,5,0,3,39,0,3,39,0,3,39,0,3,39,0,3,19,0,3,19,0,3,19,0,3,19,0,3,19,0,3,19,0,26,11,0,9,6,0,3,40,0,3,40,0,3,40,0,3,40,0,3,20,0,3,20,0,3,20,0,3,20,0,3,20,0,3,20,0,26,11,0,9,7,0,3,72,0,3,72,0,26,11,0,9,8,0,3,21,0,3,21,0,3,21,0,3,21,0,3,29,0,3,21,0,3,29,0,3,29,0,3,29,0,0,10,0,0,10,0,26,14,0,9,10,0,1,53,0,1,55,0,1,56,0,1,53,0,1,55,0,1,56,0,1,41,0,2,73,0,3,32,0,3,32,0,3,32,0,3,32,0,9,11,0,3,26,0,3,26,0,3,26,0,3,26,0,9,12,0,-1,16,0,-3,14,0,-4,50,0,-5,51,0,-6,52,0,1,16,0,2,16,0,1,16,0,2,16,0,1,14,0,2,14,0,1,14,0,2,14,0,1,14,0,2,14,0,1,14,0,2,14,0,-1,25,0,-2,42,0,-3,15,0,-4,59,0,-5,47,0,-6,16,0,-8,48,0,-9,14,0,-10,50,0,-11,68,0,-12,51,0,-13,52,0,9,14,0,0,15,0,0,15,0,0,15,0,-1,43,0,-2,44,0,-3,45,0,-4,46,0,9,16,0,-1,57,0,-2,58,0,42,58,0,0,25,0,0,27,0,-2,65,0,-3,66,0,0,41,0,-2,73,0,9,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,0,44,0,0,45,0,0,45,0,0,46,0,0,46,0,-1,60,0,-2,62,0,-1,49,0,-1,64,0,-2,67,0,9,50,0,6,69,0,3,71,0,6,70,0,3,71,0,-1,69,0,-1,70,0,9,51,0,9,52,0,9,53,0,9,55,0,9,56,0,0,59,0,-1,61,0,-1,63,0,0,63,0,0,64,0,0,65,0,0,66,0,0,67,0,0,68,0,43,13,1,5,33,2,5,33,3,5,33,4,5,36,5,5,36,6,5,36,7,5,36,8,5,33,10,5,14,11,5,13,12,5,13,27,5,28,28,5,48,53,5,54,234],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,34,35,-1,34,35,-1,34,35,-1,34,35,-1,34,35,12,12,12,12,12,-1,-2,-3,-4,-5,-6,-7,12,12,12,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,6,6,6,6,12,12,12,12],[25,26,20,25,26,20,25,26,20,25,26,20,160,161,20,162,163,164,46,165,166,167,168,169,170,171,172,173,174,175,3,73,74,75,76,3,38,39,40,41,3,42,77,78,79,3,80,81,82,83,3,84,85,86,87,3,88,89,90,91,3,92,93,94,95,3,69,70,71,72,18,18,18,61]],[[[58,[[59,[60,[-10,-11,-12,-13,-14],[[65,-5,-4],[24,0,false,-7,-6,[[35,"click"]]],[24,0,false,-9,-8,[[35,"show"]]]],-3,-2,-1]]],[{},"click",4,[28,2,false],"show",4,[28,2,false]]],[26,"Any"],[26,"Entry"],[18,"SlimeButton_Show",[21,1],[19,1]],[26,"Exit"],[18,"SlimeButton_Click",[21,0],[19,1]]],0,[0,22,1,0,23,4,0,24,2,0,7,3,0,8,2,0,7,5,0,8,1,0,7,3,0,8,1,0,-1,2,0,-2,4,0,-3,1,0,-4,5,0,-5,3,14],[0,0],[10,10],[118,119]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{},{},{}],[[[{},"mainColor",8,[4,4287598479]],{},{}],11,0,0]]],0,0,[0],[16],[120]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[10],0,[0],[33],[176]],[[[58,[[59,[60,[-10,-11,-12,-13,-14],[[65,-5,-4],[24,0,false,-7,-6,[[35,"levelUp"]]],[80,0,-9,-8]],-3,-2,-1]]],[{},"levelUp",4,[28,2,false]]],[18,"Void",[224],[19,1]],[26,"Entry"],[18,"Panel Exp_Level Up",[21,0],[19,1]],[26,"Exit"],[26,"Any"]],0,[0,22,5,0,23,4,0,24,2,0,7,1,0,8,2,0,7,3,0,8,1,0,7,1,0,8,3,0,-1,2,0,-2,4,0,-3,5,0,-4,1,0,-5,3,14],[0],[10],[121]],[[[225,"bubblegumsans-regular","bubblegumsans-regular.ttf"],-1],0,0,[],[],[]],[[[54,"P-DailyMissionsManager"],[248,"P-DailyMissionsManager",[[170,"Missions Factory",-4,[3,"05hKehV2RLE4u/DbpR3YPX",-3,0]],[170,"Rewards Factory",-6,[3,"7clwv7EipANYHfCEfJhrWY",-5,0]]],[[362,true,-2,[1,"d0qGwy+qhBxL2bSAGVMqHm"]]],[3,"71lw8f08xOeIZ3VBta/UME",-1,0]]],0,[0,9,1,0,0,1,0,9,1,0,5,1,0,9,1,0,5,1,0,21,1,6],[],[],[]],[[[54,"P-Battle-Royale"],[167,"P-Battle-Royale",[-2],[3,"85+0ISycpGH4Xce8S7Yv4z",-1,0]],[141,"Safe Area",1,[[363,210,-3,[1,"3c/QVie0NFj5YVfquZpYsT"],[356,115],[34,1,[10,[0,0.4307692307692308,0.6358974358974359,0.8384615384615385,0.9860429786696634],[[307,2,1,-1.0655737704918031,1,-1.0655737704918031,1],[11,2,0.31851851851851853,-1.3333333333333326,-1.3333333333333326],[11,2,0.15555555555555556,-0.4924242424242422,-0.4924242424242422],[11,2,0.037037037037037035,-0.41728395061728385,-0.41728395061728385],[42,2,-0.03140096618357487,1,-0.03140096618357487,1]]]]]],[3,"00BVYQ5ZlKeotx/gisR1uf",1,0]]],0,[0,9,1,0,-1,2,0,0,2,0,21,1,3],[],[],[]],[[[97,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4286545791],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[27,11]],[[[58,[[59,[60,[-16,-17,-18,-19,-20,-21,-22,-23,-24],[[65,-5,-4],[24,0,false,-7,-6,[[35,"divideNotReady"]]],[24,0,false,-9,-8,[[35,"divideReady"]]],[24,0,false,-11,-10,[[35,"divideCD"]]],[24,0,false,-13,-12,[[35,"uniteCD"]]],[24,0,false,-15,-14,[[35,"uniteReady"]]]],-3,-2,-1]]],[{},"divideReady",4,[28,2,false],"divideNotReady",4,[28,2,false],"divideCD",4,[28,2,false],"uniteReady",4,[28,2,false],"uniteCD",4,[28,2,false]]],[26,"Any"],[26,"Entry"],[26,"Exit"],[18,"1st Divide Ready",[21,0],[19,1]],[18,"Divide Not Ready",[21,1],[19,1]],[18,"Divide CD",[21,2],[19,1]],[18,"Unite Ready",[21,3],[19,1]],[18,"Unite CD",[21,4],[19,1]],[18,"Divide Ready",[21,5],[19,1]]],0,[0,22,1,0,23,3,0,24,2,0,7,4,0,8,2,0,7,5,0,8,1,0,7,9,0,8,1,0,7,6,0,8,1,0,7,8,0,8,1,0,7,7,0,8,1,0,-1,2,0,-2,3,0,-3,1,0,-4,4,0,-5,5,0,-6,6,0,-7,7,0,-8,8,0,-9,9,24],[0,0,0,0,0,0],[10,10,10,10,10,10],[33,34,53,177,54,52]],[[[54,"Holder_Handy Guide"],[48,"Holder_Handy Guide",33554432,[-7],[[17,-2,[1,"5905hwtdpOYZ5/JwcEvvLs"],[5,414,136],[0,0.5,1]],[265,41,80,100,1,-3,[1,"eav/maVbNDi4vyxZjfqPbd"]],[56,false,-4,[1,"6aPSz8yS5PgosWKGrt1b0n"],[5,6,7]],[57,-5,[1,"3aUPs3Q+VMgbkjNyjWqN9U"]],[205,-6,[1,"4b9lnAZ2xFqoPsW5jLpiuK"],8]],[3,"777+abRRVCaJ/XO2ZnoFXZ",-1,0],[1,0,368,0]],[22,"Panel_Color",33554432,1,[-11,-12,-13],[[5,-8,[1,"48swQNcl5D7ZtlsQpzrf+d"],[5,414,136]],[31,0,-9,[1,"4eL0KOWQFPwY1BwTzgt2f4"],[4,4292667899],4],[92,40,40,1,-10,[1,"e4qYWvT4JEK4s1h4l9Pf6T"]]],[3,"b72ldljSVC9b5iLHXKvF3z",1,0],[1,0,-68,0]],[140,"Panel_Title",33554432,2,[-16],[[5,-14,[1,"3feAmZoqBCt47VEHnqVqz/"],[5,320,48]],[29,1,0,-15,[1,"b9As2eVYdL8Jaz+mT8owts"],[4,4289449983],1]],[3,"c2eLpMrRdKToyI9DcaieK3",1,0],[1,0,39,0],[1,0.7,0.7,1]],[32,"Text_Handy Guide",33554432,3,[[5,-17,[1,"35KusOguJC7odO7LA8p5Az"],[5,252.39,50.4]],[151,". Slime.io handy guide .",30,30,false,-18,[1,"58iYlxgj5Ck6j2ahDm22qe"],[4,4287319001],0]],[3,"b3o9ctcHlKyJDtqmOPqaXo",1,0],[1,0,2.884,0]],[90,"Text_Tips",33554432,2,[[5,-19,[1,"70Jc2+nFZGbKVIPkk4YCmw"],[5,301.01,35.28]],[94,"Be the last surviving slime!",24,24,28,false,-20,[1,"82QeZi+GRLD5saTbj7Vde9"],[4,4286354641],2]],[3,"69SIYzBEBPnJ20CnihX0i1",1,0],[1,0,3.998,0],[1,0.7000000000000001,0.7000000000000001,1]],[90,"Text_Tips2",33554432,2,[[5,-21,[1,"22xUYnL2FGUqj88/L7ClEe"],[5,344.14,63.28]],[94,"Eat crystals to get bigger, and\nsmaller slimes to absorb them!",24,24,28,false,-22,[1,"dbyYQTQGVO8pqPRQqiYcp4"],[4,4278800039],3]],[3,"c9P2r4hqtAJJvVRpujvsS9",1,0],[1,0,-32.024,0],[1,0.7000000000000001,0.7000000000000001,1]]],0,[0,9,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,2,0,0,2,0,0,2,0,0,2,0,-1,3,0,-2,5,0,-3,6,0,0,3,0,0,3,0,-1,4,0,0,4,0,0,4,0,0,5,0,0,5,0,0,6,0,0,6,0,21,1,22],[0,0,0,0,0,0,0,0,0],[11,4,11,11,4,-1,-2,-3,20],[0,15,4,4,6,122,123,124,178]],[[[97,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4286545791],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[16,11]],[[[58,[[59,[60,[-14,-15,-16,-17,-18,-19,-20],[[80,0,-5,-4],[24,0,false,-7,-6,[[35,"punch"]]],[333,0,false,-9,-8],[65,-11,-10],[24,0,false,-13,-12,[[35,"punch"]]]],-3,-2,-1]]],[{},"punch",4,[28,2,false]]],[26,"Entry"],[26,"Any"],[18,"LvUp Rewards_Intro",[21,0],[19,1]],[18,"LvUp Rewards_Sway",[21,1],[19,1]],[18,"LvUp Rewards_Punch",[21,2],[19,1]],[18,"LvUp Rewards_Hidden",[21,3],[19,1]],[26,"Exit"]],0,[0,22,2,0,23,7,0,24,1,0,7,4,0,8,3,0,7,5,0,8,2,0,7,4,0,8,5,0,7,6,0,8,1,0,7,3,0,8,6,0,-1,1,0,-2,7,0,-3,2,0,-4,3,0,-5,4,0,-6,5,0,-7,6,20],[0,0,0,0],[10,10,10,10],[125,126,127,128]],[[[152,"../Internal/Scripts/Shaders/levelfloor",[{"hash":3448753832,"name":"../Internal/Scripts/Shaders/levelfloor|floor-vs:vert|floor-fs:frag","blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"Constant","stageFlags":16,"binding":1,"members":[{"name":"mainColor","type":16,"count":1},{"name":"outterColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"radius","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_color","format":44,"location":8,"defines":["USE_VERTEX_COLOR"]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":1,"defines":["USE_VERTEX_COLOR"]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":2,"defines":["USE_TEXTURE"]},{"name":"worldPosition","type":16,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  layout(location = 8) in lowp vec4 a_color;\n  layout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 2) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nlayout(location = 3) out vec4 worldPosition;\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  worldPosition = cc_matWorld * position;\n  CC_TRANSFER_FOG(cc_matWorld * position);\n  return cc_matProj * (cc_matView * cc_matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 2) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 outterColor;\n  vec4 colorScaleAndCutoff;\n  float radius;\n};\nlayout(location = 3) in vec4 worldPosition;\n#if USE_VERTEX_COLOR\n  layout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = colorScaleAndCutoff;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  vec4 outter = outterColor;\n  vec4 inner = mainColor;\n  #if USE_TEXTURE\n    outter.rgb = SRGBToLinear(texture(mainTexture, v_uv).rgb) * outter.rgb;\n    inner.rgb = SRGBToLinear(texture(mainTexture, v_uv).rgb) * inner.rgb;\n  #endif\n  o *= mix(inner, outter, floor(min(1.0, length(worldPosition.xz/radius))));\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nout vec4 worldPosition;\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  worldPosition = cc_matWorld * position;\n  CC_TRANSFER_FOG(cc_matWorld * position);\n  return cc_matProj * (cc_matView * cc_matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 outterColor;\n  vec4 colorScaleAndCutoff;\n  float radius;\n};\nin vec4 worldPosition;\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = colorScaleAndCutoff;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  vec4 outter = outterColor;\n  vec4 inner = mainColor;\n  #if USE_TEXTURE\n    outter.rgb = SRGBToLinear(texture(mainTexture, v_uv).rgb) * outter.rgb;\n    inner.rgb = SRGBToLinear(texture(mainTexture, v_uv).rgb) * inner.rgb;\n  #endif\n  o *= mix(inner, outter, floor(min(1.0, length(worldPosition.xz/radius))));\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\nvarying vec4 worldPosition;\nvec4 vert () {\n  vec4 position;\n      position = vec4(a_position, 1.0);\n    #if CC_USE_MORPH\n      applyMorph(position);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(position);\n    #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  worldPosition = cc_matWorld * position;\n  CC_TRANSFER_FOG(cc_matWorld * position);\n  return cc_matProj * (cc_matView * cc_matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n   uniform vec4 mainColor;\n   uniform vec4 outterColor;\n   uniform vec4 colorScaleAndCutoff;\n   uniform float radius;\nvarying vec4 worldPosition;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = colorScaleAndCutoff;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  vec4 outter = outterColor;\n  vec4 inner = mainColor;\n  #if USE_TEXTURE\n    outter.rgb = SRGBToLinear(texture2D(mainTexture, v_uv).rgb) * outter.rgb;\n    inner.rgb = SRGBToLinear(texture2D(mainTexture, v_uv).rgb) * inner.rgb;\n  #endif\n  o *= mix(inner, outter, floor(min(1.0, length(worldPosition.xz/radius))));\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocal","defines":[]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":157,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":43}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}]}],[{"name":"opaque","passes":[{"program":"../Internal/Scripts/Shaders/levelfloor|floor-vs:vert|floor-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"outterColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"radius":{"type":13,"value":[30]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}}}]},{"name":"transparent","passes":[{"program":"../Internal/Scripts/Shaders/levelfloor|floor-vs:vert|floor-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"outterColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"radius":{"type":13,"value":[30]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}}}]},{"name":"add","passes":[{"program":"../Internal/Scripts/Shaders/levelfloor|floor-vs:vert|floor-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"outterColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"radius":{"type":13,"value":[30]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}}}]},{"name":"alpha-blend","passes":[{"program":"../Internal/Scripts/Shaders/levelfloor|floor-vs:vert|floor-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"outterColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"radius":{"type":13,"value":[30]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}}}]}]]],0,0,[],[],[]],[[[58,[[59,[60,[-8,-9,-10,-11,-12],[[65,-5,-4],[24,0,false,-7,-6,[[35,"endGame"]]]],-3,-2,-1]]],[{},"endGame",4,[28,2,false]]],[26,"Entry"],[18,"CanvasPlay_Intro",[21,1],[19,1]],[26,"Exit"],[26,"Any"],[18,"CanvasPlay_Exit",[21,0],[19,1]]],0,[0,22,4,0,23,3,0,24,1,0,7,2,0,8,1,0,7,5,0,8,2,0,-1,1,0,-2,3,0,-3,4,0,-4,5,0,-5,2,12],[0,0],[10,10],[56,55]],[[[54,"Canvas_GameOver"],[48,"Canvas_GameOver",33554432,[-8,-9,-10,-11],[[5,-2,[1,"aeEeTmVfNF3owbGlE+Snic"],[5,414,896]],[129,-3,[1,"67PskXsF9JxZCv9ijp8d9A"]],[66,45,-4,[1,"b6feX4D15IKJq9q0zOeOl1"]],[364,-6,[1,"b2xQpL+lpA1ZxSFSSRvCNf"],-5],[130,-7,[1,"f2YHBgeY1E2b3fsiZ6FK6h"]]],[251,"9dti4iiGNLDaJ2TOWKutaW",[],-1,0],[1,207,448,0]],[242,"Content Holder",false,33554432,1,[-20,-21,-22,-23,-24],[[[5,-12,[1,"91K8tmG0VFw6JFJtEv7YjY"],[5,414,896]],[49,45,100,100,-13,[1,"a7fMjA+mNO/r2QfemusTjn"]],[37,-14,[1,"cengzM9ZROFq4ba2IyHnqW"]],[56,false,-15,[1,"108MMbrc1N3bX++kRlm/HD"],[45,46,47]],-16,[365,"game-restart",-17,[1,"a23sT4MThKPbQ24l/aV7ON"]],[366,-19,[1,"d1D035gT1E6bgy3VRcj3dU"],[[367,"finishedExitAnimation",[[6,"d2017D/nqBC24w++1MXcPXY","raise",-18]]]]]],4,4,4,4,1,4,4],[3,"17xNGSEwlIZqrSbQ2F25Y1",1,0]],[82,"Panel_Exp",33554432,[-32,-33,-34,-35],[[[17,-25,[1,"244ej9rO1JLotYI/jLTRmJ"],[5,220,44],[0,0.5,1]],[29,1,0,-26,[1,"03QGarSmFM3rDy35/VIOqx"],[4,4289449983],23],[73,17,64,1,-27,[1,"47xLgre8tGZb28EIXJ2Gw3"]],[56,false,-28,[1,"4f0K6AafZI5Y4UwIuYOQAS"],[24]],-29,-30,-31],4,4,4,4,1,1,1],[3,"d7LN7SYHxORoDV77uTTjoR",1,0],[1,0,346,0]],[82,"UI_Currency Panel",33554432,[-42,-43],[[[128,33,28,22,20,840,300,36,1,-36,[1,"eegb+lCehN2byKU/Txh0Dd"]],[17,-37,[1,"1eS/nOIjdCXrh8uKenkIHB"],[5,140,26],[0,0.5,1]],[29,1,0,-38,[1,"9anBXCAuZLy4a6VQ6ZU6Ol"],[4,4292667899],11],-39,[200,-40,[1,"78X/AQbdtMFKxXlJxASsKV"],[12]],[57,-41,[1,"158Cqxb5lIrrbiOP1Wu4/H"]]],4,4,4,1,4,4],[3,"d4fxQnk3lAk4pgZQUz1XCg",1,0],[1,115,-20,0]],[61,"Panel_Color",33554432,[-48,3,-49,-50],[[17,-44,[1,"87ZwJUB6VKjI67zCmSdHof"],[5,414,410],[0,0.5,0]],[31,0,-45,[1,"16f8G2rqBGDq/WcogqQX9N"],[4,4292667899],38],[92,44,40,1,-46,[1,"0b8nWDFBVDwacz74SI35cj"]],[218,-47,[1,"08nVqM23dKc5+SLHrWGxyj"]]],[3,"08ahui84VI7JOM6O7e7dku",1,0]],[142,"Sprite_Defeat",false,33554432,[[17,-51,[1,"ceANdIgy1Mzb4zLoQWD/Sr"],[5,396,120],[0,0.5,0]],[148,20,233.897,535.5,160,1,-52,[1,"9exWOkVVBJkIZ+l4O3cJ/E"]],[75,-53,[1,"039toNX1tLm5yzR5E3q3ml"],4],[37,-54,[1,"9aYVpstQpK5p13vdXKYNrJ"]],[85,true,-55,[1,"72XxH3ZgZLKa1d9WUki9Ek"],[5],6]],[3,"81X8yiOcVN7aQhw9ETj27H",1,0],[1,0,87.5,0],[1,0,0,1]],[62,"Group_Ad",false,33554432,5,[-59,-60,-61],[[17,-56,[1,"273BOzA4pPt7IY3ttSp5lr"],[5,400,100],[0,0.5,1]],[73,1,132,1,-57,[1,"8eD2YUao5IQZrCPH8F+VPo"]],[85,true,-58,[1,"4bP7/GACxNAIRmeTRmrbIj"],[33],34]],[3,"5bESq7XHRIF4Oe1Sgp4Beq",1,0],[1,0,278,0]],[32,"Button_Play",33554432,5,[[17,-62,[1,"4fgX0jrURHZokAeHGkKyBF"],[5,88,88],[0,0.5,1]],[149,1,0,-63,[1,"e4RZT/ycVOSpJjZmt4y8DT"],35],[150,3,0.9,-67,[1,"2dBA+8v/xBF5j65vaE2tCZ"],[[27,"37b85WpHzdBn41+pXJNQa6l","setTrigger","buttonBackClick",-65],[6,"ac879rTendCEbpZWFz/jexs","playSFX",-66]],[4,4292269782],-64,36],[73,1,260,1,-68,[1,"2doQdYvRlDGZVSxhNIVeym"]],[77,-69,[1,"42B0SAiQZF/bc+oLp8dhvW"],37]],[3,"aawrycqThIe5m/eiraHORZ",1,0],[1,0,150,0]],[142,"Sprite_Victory",false,33554432,[[17,-70,[1,"9armG8srxHIpfW59Q6dRaU"],[5,396,145],[0,0.5,0]],[148,20,233.897,535.5,160,1,-71,[1,"9exWOkVVBJkIZ+l4O3cJ/E"]],[75,-72,[1,"7dl/G4ULREPpudzsht8Thd"],1],[37,-73,[1,"90tlxBsMNP8rrmpclsqpO2"]],[85,true,-74,[1,"453vMuiylNJbzwEyk0p1bg"],[2],3]],[3,"f8upUNcoJPCpopxlliuAz9",1,0],[1,0,87.5,0],[1,0,0,1]],[142,"Sprite_Vanished",false,33554432,[[17,-75,[1,"52OpZcjKZM0bPDMc2sdqku"],[5,360,116],[0,0.5,0]],[148,20,233.897,535.5,160,1,-76,[1,"26MtJSgiVFZKuu+te0wdEo"]],[75,-77,[1,"e7FK5lsEhLzL1A8XQHA3mv"],7],[37,-78,[1,"fbuGEZYo9Fy5j5QI5TSYaE"]],[85,true,-79,[1,"4dRLZXfnpF1rtyPi8d4jKV"],[8],9]],[3,"70PwdaSWZEeZNru9acNVHK",1,0],[1,0,87.5,0],[1,0,0,1]],[22,"Button_Watch Add",33554432,7,[-85,-86],[[17,-80,[1,"9erNPNRtlJ/J1ctHwJAESp"],[5,160,44],[0,0.5,1]],[29,1,0,-81,[1,"a6u5tU8UpAJqn//wW3kQuD"],[4,4279794659],31],[150,3,0.9,-84,[1,"aeUF26DfFLOrNDKjl+N3Or"],[[6,"8620aiyaVVH5aUIHiS4nbuh","showAd",-83]],[4,4292269782],-82,32]],[3,"d28Qit73dNg5tcFV4SGN0S",1,0],[1,0,-39.127,0]],[20,"Group_Mid Panel",33554432,2,[9,6,10],[[5,-87,[1,"78chiv2v9NVrmHqdPPPlwH"],[5,414,896]],[180,45,100,100,1,-88,[1,"a5EOw+TAxBkIfUo+Um/mVb"]]],[3,"c8vnLR0AJOtY4d5Y9nlLLK",1,0]],[171,"Holder_LvUp Rewards",33554432,[-93],[[[17,-89,[1,"1efgJ3ArhIx4ta/F5USAgM"],[5,90,26],[0,0.5,0]],[56,false,-90,[1,"b0s5G85PlMS6Fu3v5ZWVP/"],[19,20,21,22]],-91,-92],4,4,1,1],[3,"5cgpc21f5K17C22eyFAfXg",1,0]],[20,"Group_VFX",33554432,2,[-96,-97,-98],[[5,-94,[1,"87a6P+kMJJRZCzD/GMICMo"],[5,414,896]],[49,45,100,100,-95,[1,"d7QjTtfpBDi5ukqj8Kaqav"]]],[3,"aa/U2qAVlMiKinnTSeKLFm",1,0]],[20,"Scripts",33554432,1,[-100,-101,-102],[[8,-99,[1,"5fX45amJFDdJd6pzcVv4ZJ"]]],[3,"9feomZ2IRM7YDTMLS5LRgh",1,0]],[140,"Slime_Platform",33554432,5,[-106],[[5,-103,[1,"18V1oU8zxOW5Fyu4x8pUUT"],[5,208,148]],[93,-104,[1,"19zMeYJ3VNt7xgZ4eiaYdr"],[4,4292667899],14],[73,1,-56.65199999999999,1,-105,[1,"0cakft0odHQ6IbHnXz6/rX"]]],[3,"25HH/C2FROO4u67Ija3567",1,0],[1,4.543,422.252,0],[1,0.6,0.6,1]],[22,"Slime_Platform Color",33554432,16,[-110],[[5,-107,[1,"1fxSWv7fNFNI8WM8kN5pXv"],[5,184,134]],[31,0,-108,[1,"46UGU5yAdKOLspl67Rb6kX"],[4,4289449983],13],[40,45,12,12,8,6,208,148,-109,[1,"05/MZfe6VI0qNraBkwQAXW"]]],[3,"1dEuNoKl1JlKlM1oipMuQN",1,0],[1,0,-1,0]],[22,"Group_Position",33554432,17,[-113,-114],[[5,-111,[1,"c12OrDi5NPErV2IAgDSUdt"],[5,65.5,100]],[221,1,1,2,-112,[1,"47mXWWUVBAA5D1AffPVx/U"]]],[3,"ddWdQkuRpAN695Zl3HhHqa",1,0],[1,7.205,5.78,0]],[44,"Text_Position",33554432,18,[[[17,-115,[1,"02UVCpKlxItbeBaXc08Nyj"],[5,33.5,126],[0,0.5,0]],-116,[86,-118,[1,"30DicJ2oxObrSEARrsaqNX"],-117]],4,1,4],[3,"dbGYwNHKRDkqtPtW83sOz6",1,0],[1,-16,-61.97,0]],[44,"Text_Sufix",33554432,18,[[[17,-119,[1,"c3+/ECJdtFCJSdJG6DlFYr"],[5,30,40],[0,0.5,0]],-120,[368,-122,[1,"27qbyfSiFFEITl8TruBzLX"],-121]],4,1,4],[3,"a4O/AZ0xRK/bMkMLfiDK9i",1,0],[1,17.75,-36.255,0]],[22,"Mask_Fill",33554432,3,[-126],[[5,-123,[1,"84hKbqA3BAIJ9K53HULY81"],[5,204,36]],[319,3,-124,[1,"69qGGRKxBL+6YSC8G1Ke+F"],15],[40,45,12,4,4,4,100,100,-125,[1,"cdh9/O3AZDIZm9dIn4O7Cl"]]],[3,"1aaDOAhHJNe4aY8YnwH8X6",1,0],[1,4,-22,0]],[22,"Icon_StarCoin",33554432,3,[-130],[[5,-127,[1,"00d9V7kslMe6JLdohh14RP"],[5,68,60]],[75,-128,[1,"del95b0NJBuKk/BpLv0hkc"],16],[266,10,-14.697000000000003,6.976000000000001,-129,[1,"1cej4fac5Oo6SZ/O1+uYuq"]]],[3,"30xvFtEDtDcICSlD9VXiCC",1,0],[1,-90.697,-15.024,0]],[22,"Group_XP Value",33554432,3,[-134],[[5,-131,[1,"86RT+fuu9K/aqQONpr1zqH"],[5,160,36]],[220,false,1,1,1,-132,[1,"50FN9i8iRK7oZt9/9z8OH2"]],[147,45,39.05,20.949999999999985,3.7360000000000007,4.263999999999999,2,88.75999999999999,20,-133,[1,"63sZ/4vr9O5IOGAWfjSCmc"]]],[3,"206VqmMAxAJoLdN7FREpYa",1,0],[1,9.049999999999997,-21.736000000000004,0]],[22,"Group_LvUp Rewards",33554432,3,[13],[[17,-135,[1,"a2CWaOYcNMSqrpMq0CJlLw"],[5,120,26],[0,0.5,0]],[267,16,128,-136,[1,"2a7X0rgy9AwouJQEauHtHM"]],[316,1,2,16,true,-137,[1,"3c0i5Q5zpE/4F+ubScxnz5"]]],[3,"a6S05ia5VC8KkOK46ohKw8",1,0],[1,128,15,0]],[20,"Panel_Color",33554432,13,[-140,-141],[[17,-138,[1,"f8mws/LvxIkJ5i1PJ55Nau"],[5,90,26],[0,0.5,0]],[29,1,0,-139,[1,"e178rKnRNCd4dVf1eYstr3"],[4,4279489946],18]],[3,"78nJ9s6ftJl5sutDbJC/+v",1,0]],[22,"BonusPanel_Color",33554432,7,[-145],[[17,-142,[1,"71uxttwupMwqK0zKgFIHeb"],[5,100,28],[0,0.5,1]],[31,0,-143,[1,"dbHgfJHJFAX6gvPkklm2Ar"],[4,4279489946],28],[83,4,63.88,1,-144,[1,"cf7UrSiAJP/pQ/MVgmM8tE"]]],[3,"f1pQyEUphCW6eMGG30UQzo",1,0],[1,-3.06,-8.119999999999997,0]],[122,"VFX.Star.Explode",33554432,14,[[-146,[8,-147,[1,"6f0plddqNAMZucCC3UWEZn"]],[83,4,-715.126,1,-148,[1,"e2XvNWExtCgJuj+XtgYJWb"]]],1,4,4],[3,"49a299KLhNjrSPX+FfcTkL",1,0],[1,1.667,-163.12599999999998,0],[1,20,20,1]],[122,"VFX.Star.Box",33554432,14,[[-149,[8,-150,[1,"6f2s3LJvFOkbnjvKNnLOQ+"]],[83,4,-552.446,1,-151,[1,"64aiHrmutNdJYYt1une6QU"]]],1,4,4],[3,"813kocdfBMQZbXIEeW89nC",1,0],[1,1.667,-0.4460000000000264,0],[1,20,20,1]],[122,"VFX.Defeat.Star",33554432,14,[[-152,[8,-153,[1,"88YCREEOdNHalkTQ7pm9tA"]],[83,4,-552.446,1,-154,[1,"a0QGMWgGhBJZHR++yf8M0N"]]],1,4,4],[3,"cfONmALjdIr5OlqZkLqkbP",1,0],[1,1.667,-0.4460000000000264,0],[1,20,20,1]],[20,"Events Listeners",33554432,1,[-156,-157,-158],[[8,-155,[1,"091SpFy9RFB6yqe9N7PyGH"]]],[3,"74vCx4WKNPMb1JltvPH8th",1,0]],[43,"Animation Helper",33554432,[[8,-159,[1,"ccqTxEZ11Iurolysv1UgWM"]],[76,-161,[1,"6f0vewjcdLHJ3xzk5GDLnS"],-160]],[3,"ae8SkLngNAD7yz5xRqbir/",1,0]],[16,"Overlay",33554432,2,[[5,-162,[1,"189iGsr01AGKF7rU1+GXtB"],[5,414,896]],[274,false,0,-163,[1,"57gCG35slGMrd3JeX5WeXH"],[4,505742637],0],[49,45,40,36,-164,[1,"e0VCF9jrhL+ImErtSgmLlq"]]],[3,"49QZD/a7pP+bisgDV9y2DS",1,0]],[22,"Group_Top Panel",33554432,2,[4],[[17,-165,[1,"e3jWLstSZGhrwc4KD7ZdBA"],[5,414,100],[0,0.5,1]],[92,41,100,1,-166,[1,"204k9SqCVHWKJw2oVkXK0t"]]],[3,"0dwYuL91FNNLxKcLkRp4Ux",1,0],[1,0,448,0]],[44,"Text_Current Currency",33554432,4,[[[17,-167,[1,"32MbuAiMpLKamygIyp0+de"],[5,94,28.68],[0,0.5,0.41]],[185,42,28,18,-16.921200000000002,6.259,0.399200000000004,133.24,1,-168,[1,"64dEO48v1E6bBNHrnydhuc"]],-169],4,4,1],[3,"e1Uw7weIVF94cymrLLFOfC",1,0],[1,5,-15.181999999999997,0]],[32,"UI_Coin Icon",33554432,4,[[5,-170,[1,"54dW4Zji9MfpXB76/2x3Fo"],[5,36,36]],[74,0,-171,[1,"74vKj+ISRJUIFnriyoV7A0"],10],[186,8,-10,-172,[1,"932qXP0aRMQJD7T3IPpk2E"]]],[3,"c0Z3xz8QhMTbNworoXsPb3",1,0],[1,-62,-13.642000000000053,0]],[22,"Group_Bot Panel",33554432,2,[5],[[17,-173,[1,"31AwPJIhxGJYPareTljDYM"],[5,414,100],[0,0.5,0]],[92,44,100,1,-174,[1,"a38MRDDOlAB5M0UmEndX/j"]]],[3,"77FbeG7BZJNrb7hNoDsCfx",1,0],[1,0,-448,0]],[44,"Bar Fill",33554432,21,[[[184,45,7,32,32,-175,[1,"88dl5+U1dK1Y2A575jToJN"]],[5,-176,[1,"8d/CQ4xGpDjo7ef9qHj4Zj"],[5,197,36]],-177],4,4,1],[3,"2bU46veZJC+pWo4rUAuP3o",1,0],[1,3.5,0,0]],[22,"Text_Double Rewards",33554432,26,[-180],[[17,-178,[1,"f8x2bJH8ZOGo/MhurxNtcv"],[5,54.72,25.2],[0,0.5,1]],[197,"for 2x",2,20,20,20,false,-179,[1,"5eIBID+RhNpKIwjnkORT++"],[4,4279461453],27]],[3,"c86YpTdrRAiJ0ZmVDBqEyg",1,0],[1,-6.514,0.048,0]],[32,"Icon_Coin",33554432,38,[[17,-181,[1,"77CmMe6xRABK5dSb1Ru+nV"],[5,24,24],[0,0,1]],[74,0,-182,[1,"27dXWrqCpBpbL4nU0/QDqI"],26],[187,32,-23.715000000000003,-183,[1,"2dsK7zCK9NDqi1RxxErTFm"]]],[3,"96N1Q5oIlDJo1ZXuQ5EMGE",1,0],[1,27.075000000000003,-1.438,0]],[32,"Panel_Color",33554432,11,[[5,-184,[1,"a3ZJRx4uVEZo3gPpO7CwrA"],[5,156,40]],[29,1,0,-185,[1,"d1zXyfLbZA9ogy0yz3vG7E"],[4,4282815977],29],[40,45,2,2,1,3,40,36,-186,[1,"5eLKm271xDvroCoWOO2csy"]]],[3,"90jtnt4a5GdKUH/gz4JeD3",1,0],[1,0,-21,0]],[32,"Text",33554432,11,[[5,-187,[1,"5344jq7D1FGoZkUZ66WLHY"],[5,116.9,32.76]],[286,"Watch ad!",32,32,26,false,false,-188,[1,"d9Y1gi0aNDp741ngrkXt3S"],30],[268,2,3.748000000000001,-189,[1,"c0A1ra72dHhYs7Fq51ctST"]]],[3,"53PMKyEaVKLoxK3a98hFlH",1,0],[1,0,-18.252,0]],[43,"Level Up",33554432,[[8,-190,[1,"64eiIQv6ZKirIf0i4ONjVe"]],[369,-191,[1,"f6QLJaYIRBz4DAaNRcnT1r"],7]],[3,"007PALzJFDnICrN4qnIA0L",1,0]],[43,"Defeat",33554432,[[8,-192,[1,"bb6nLlNvpFzbvqEZ0jUedj"]],[77,-193,[1,"3fvDDhrTNIKb6DYLfyOcYh"],49]],[3,"a7LovWs9BEyI1uHfj5TH2C",1,0]],[20,"Audio",33554432,1,[-195,43],[[8,-194,[1,"64Rab3lN9ETJevZZ7C/rkB"]]],[3,"a2mgqCBeBNB7dnlg2MfPVx",1,0]],[16,"Victory",33554432,44,[[8,-196,[1,"5c+tzJwnZJYIhR89gBbu1R"]],[77,-197,[1,"0bfN9VqClLyIPTB18JZ5dV"],48]],[3,"76MW9bcoNIE6SvaE/akl5r",1,0]],[20,"Player Tracker Data",33554432,15,[-199],[[8,-198,[1,"78WpAaULFESap5HzyE75Mg"]]],[3,"635rFEJgdP+pnKsrSisorC",1,0]],[16,"TS-PlayerTrackerData-Setter",33554432,46,[[8,-200,[1,"a5+mcof9RMR7cm+ejqtFNs"]],[370,-201,[1,"23BopssxdNmIleJ+PofMnF"],[[131,"6e2c3RUn6NEX4g5R/9iNyPG","setText"]],[[131,"6e2c3RUn6NEX4g5R/9iNyPG","setText"]],[[131,"6e2c3RUn6NEX4g5R/9iNyPG","setText"]],[[131,"6e2c3RUn6NEX4g5R/9iNyPG","setText"]]]],[3,"a6LsVSTlpCaqw6LLkq7kd1",1,0]],[20,"Animation",33554432,15,[31],[[8,-202,[1,"c7qY+3wL5BFq61cqVXYtD9"]]],[3,"7cndenUfdEL5DZJgfPuK6+",1,0]],[44,"Text_Current Level",33554432,22,[[[5,-203,[1,"62PYbOyj5It4TmI7ipP0ti"],[5,40,50.4]],-204],4,1],[3,"c7SZAesC9Hgopu5YbpBKig",1,0],[1,0,0.678,0]],[98,"Text",33554432,23,[[[5,-205,[1,"dblARKYRpLuYBShvPzvmx1"],[5,130,28.4]],-206],4,1],[3,"1eZM7RLYBHQ7ISxT9cxx2k",1,0]],[44,"Text_Current Currency",33554432,25,[[[17,-207,[1,"f4wbNR5aNFbK8hheUlO5uP"],[5,60,26],[0,0.5,0.41]],-208],4,1],[3,"a6vqpi581Jubg0k+hDUJxR",1,0],[1,11.927,11.654,0]],[32,"UI_Coin Icon",33554432,25,[[5,-209,[1,"f9qxaNSy1ChrlDvd/1uC6P"],[5,36,36]],[74,0,-210,[1,"0cmRAhSFZLvKKUPiznMNHH"],17]],[3,"a1KqCViidIf5o779HBlx1a",1,0],[1,-37,14,0]],[163,"Text_Swipe to Change",false,33554432,7,[[17,-211,[1,"6a7FXx/0VBJJLrR0I4joNE"],[5,319.79,25.2],[0,0.5,1]],[94,"Watch an ad to double level up rewards!",17,17,20,false,-212,[1,"39qzoYoCZCpISTM6oY4E26"],[4,4279794659],25]],[3,"41u8jhxIpLCYe+fwvyo1V8",1,0]],[20,"Rewarded Ads",33554432,15,[42],[[8,-213,[1,"06TYz3EyRAHIJdGXZExHhU"]]],[3,"b6Cq7wWVFNG6ZhlwqR2S8c",1,0]],[16,"Player Vanished",33554432,30,[[8,-214,[1,"b0t8bz2tpKg4aOMTmRKxOp"]],[294,0.1,20,-215,[1,"34dw5zscdNfYrfYkdW6aD5"],[[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",6],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",10]]]],[3,"e7IluEZblPcJmiuCn19f/W",1,0]],[16,"Defeat",33554432,30,[[8,-216,[1,"26V+UlTLZMZYZ4YlDNaUPj"]],[273,-217,[1,"efeMb0BSFDPKkNxIcBaRJn"],[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",2],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",6],[6,"ac879rTendCEbpZWFz/jexs","playSFX",43],[6,"cc.ParticleSystem","play",29],[6,"85848g+yY1PpKiragtG2vjV","setText",19],[6,"23f03FqfFxDSb54Zss+W8dO","setText",20]]]],[3,"2afVUkCQ5BcqftYZbL7gam",1,0]],[16,"Victory",33554432,30,[[8,-218,[1,"f3fo9SGldEzKPp5pZXCK0W"]],[132,3,-219,[1,"b2Tkfv5QtOK7wQHFtDOLfA"],[[6,"c83f3h67FpJDoLcaBUEDjiF","activate",2],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",9],[6,"ac879rTendCEbpZWFz/jexs","playSFX",45],[6,"cc.ParticleSystem","play",27],[6,"cc.ParticleSystem","play",28]]]],[3,"5cBwrzFulEnJKJOE8/PyvP",1,0]],[63,2,[1,"108MMbrc1N3bX++kRlm/HD"]],[110,"999",22,22,22,2,false,false,34,[1,"b2L0I05lVJ/LN2OP1lemLQ"],[4,4280640397]],[219,4,[1,"d9zv9EfTZCzJYSnWM2XA3J"],59,[[6,"cc.Animation","play",4]]],[287,"1",0,100,100,100,false,false,19,[1,"bfw0sTxldI2qMZaKhWhbVZ"],[4,4280517870]],[288,"st",0,40,2,false,false,20,[1,"970Xckm21GzLZjYVZAPGlN"],[4,4282283714]],[193,3,0,0.6,37,[1,"6chlADC0pBtala6bgPvbkn"],[4,4283471839]],[196,"1",36,36,2,false,false,49,[1,"ccR16kCsVPwZ46WUc7n7bS"]],[195,"/",28,28,20,2,false,false,1,50,[1,"14esEItjxMNqtTUKGlaWsu"],[4,4281293202]],[198,"+900",0,22,22,22,2,false,false,51,[1,"dbQ+dHVs5C87I0/unJ8OpN"],[4,4279461453]],[63,13,[1,"53KLyX/wRG3rF07wxo2cyh"]],[371,"punch",13,[1,"3blQSEvFhBn4TXZZ8sztop"],66,67],[63,3,[1,"90i1iSgDJNPIoH+hKBVQiM"]],[372,3,[1,"77WatAZ5FPmp6Dij/0fo8h"],64,60,68,69],[373,3,[1,"616NoUHH1GS4cvC/jpWM0g"],65,63],[134,2,false,0.6,false,27,[1,"11kTIf7JNERpkD2P02D9x9"],[[39,null],6,0],[78,2,[4,4292667899],[4,4279462143]],[25,3,0.8,1.4],[4],[4],[25,3,10,16],[4],[4],[4],[4],[25,3,1.6,1],[79,1,10,[10,[0.007692307692307693,1],[[36,2,2.3271604938271606,2.3271604938271606],[15,2,1]]]],[4],[4],[[68,[9,30]],[88,0.15,[9,20]]],[64,[112,1,[158,[[71,255,0.5602678571428571],[71,0,0.7008928571428572]]]]],[306,true,1,1,4,1,0.4537856055185257,[4]],[154,true,true,[34,1,[10,[0,1],[[155,2,1,1,1],[156,2,1,1]]]],[153,2,2,[10,[0,0.30256410256410254,0.6461538461538462,1],[[42,2,8.233333333333334,1,8.233333333333334,1],[11,2,0.5407407407407407,-0.4062499999999997,-0.4062499999999997],[11,2,0.6074074074074074,1.344827586206897,1.344827586206897],[42,2,-5.326388888888894,1,-5.326388888888894,1]]],[10,[0,0.32564102564102565,0.6282051282051282,1],[[42,2,8.233333333333334,1,8.233333333333334,1],[11,2,0.34814814814814815,-0.3823529411764717,-0.3823529411764717],[11,2,0.6592592592592592,1.344827586206897,1.344827586206897],[42,2,-5.326388888888894,1,-5.326388888888894,1]]]],[79,1,2,[10,[0,0.2076923076923077,0.4641025641025641,0.7974358974358975,1],[[42,2,12.277777777777777,1,12.277777777777777,1],[11,2,0.4666666666666667,-1.364197530864198,-1.364197530864198],[11,2,0.6518518518518519,1.5718954248366,1.5718954248366],[11,2,0.5,-2.355072463768116,-2.355072463768116],[42,2,-3.5767195767195745,1,-3.5767195767195745,1]]]],[4]],[114,true,[113,3],[25,3,30,50],[4],[9,1]],[50,[4],[4],[4]],[103,[4],[4],[4],[4]],[51,[4],[4],[4]],[52,[4],[4]],[157,0.01,[9,1],[79,1,6,[10,[0,1],[[15,2,1],[36,2,-3.111111111111112,-3.111111111111112]]]],[87,[4,4292667899]],[87,[4,4292667899]],-220],[53,40]],[134,2,false,0.8,false,28,[1,"a2XcWZHqhEYqTRxPVAUDg7"],[[41,null],6,0],[78,2,[4,4292667899],[4,4279462143]],[25,3,0.8,1.4],[4],[4],[25,3,3,8],[4],[4],[4],[9,0.3],[25,3,1.6,1],[9,0.6],[4],[4],[[68,[9,30]],[88,0.15,[9,20]]],[64,[112,1,[158,[[71,255,0.5602678571428571],[71,0,0.7008928571428572]]]]],[215,true,0,1,4,1,0.4537856055185257,[4],[1,16,36,1]],[154,true,true,[34,1,[10,[0,1],[[155,2,1,1,1],[156,2,1,1]]]],[153,2,2,[10,[0,0.30256410256410254,0.6461538461538462,1],[[42,2,8.233333333333334,1,8.233333333333334,1],[11,2,0.5407407407407407,-0.4062499999999997,-0.4062499999999997],[11,2,0.6074074074074074,1.344827586206897,1.344827586206897],[42,2,-5.326388888888894,1,-5.326388888888894,1]]],[10,[0,0.32564102564102565,0.6282051282051282,1],[[42,2,8.233333333333334,1,8.233333333333334,1],[11,2,0.34814814814814815,-0.3823529411764717,-0.3823529411764717],[11,2,0.6592592592592592,1.344827586206897,1.344827586206897],[42,2,-5.326388888888894,1,-5.326388888888894,1]]]],[79,1,2,[10,[0,0.2076923076923077,0.4641025641025641,0.7974358974358975,1],[[42,2,12.277777777777777,1,12.277777777777777,1],[11,2,0.4666666666666667,-1.364197530864198,-1.364197530864198],[11,2,0.6518518518518519,1.5718954248366,1.5718954248366],[11,2,0.5,-2.355072463768116,-2.355072463768116],[42,2,-3.5767195767195745,1,-3.5767195767195745,1]]]],[4]],[89,[113,3],[25,3,30,50],[4],[9,1]],[50,[4],[4],[4]],[103,[4],[4],[4],[4]],[51,[4],[4],[4]],[52,[4],[4]],[157,0.01,[9,1],[79,1,6,[10,[0,1],[[15,2,1],[36,2,-3.111111111111112,-3.111111111111112]]]],[87,[4,4292667899]],[87,[4,4292667899]],-221],[53,42]],[134,2,false,0.8,false,29,[1,"07qYFunz5O/Y6Xvfe7VadP"],[[43,null],6,0],[78,2,[4,4292667899],[4,4282586808]],[25,3,0.8,1.4],[4],[4],[25,3,5,8],[4],[4],[4],[4],[25,3,1.6,1],[9,2],[4],[4],[[68,[9,30]],[88,0.15,[9,20]]],[64,[112,1,[158,[[71,255,0.5602678571428571],[71,0,0.7008928571428572]]]]],[215,true,0,1,4,1,0.4537856055185257,[4],[1,16,36,1]],[154,true,true,[34,1,[10,[0,1],[[155,2,1,1,1],[156,2,1,1]]]],[153,2,2,[10,[0,0.30256410256410254,0.6461538461538462,1],[[42,2,8.233333333333334,1,8.233333333333334,1],[11,2,0.5407407407407407,-0.4062499999999997,-0.4062499999999997],[11,2,0.6074074074074074,1.344827586206897,1.344827586206897],[42,2,-5.326388888888894,1,-5.326388888888894,1]]],[10,[0,0.32564102564102565,0.6282051282051282,1],[[42,2,8.233333333333334,1,8.233333333333334,1],[11,2,0.34814814814814815,-0.3823529411764717,-0.3823529411764717],[11,2,0.6592592592592592,1.344827586206897,1.344827586206897],[42,2,-5.326388888888894,1,-5.326388888888894,1]]]],[79,1,2,[10,[0,0.2076923076923077,0.4641025641025641,0.7974358974358975,1],[[42,2,12.277777777777777,1,12.277777777777777,1],[11,2,0.4666666666666667,-1.364197530864198,-1.364197530864198],[11,2,0.6518518518518519,1.5718954248366,1.5718954248366],[11,2,0.5,-2.355072463768116,-2.355072463768116],[42,2,-3.5767195767195745,1,-3.5767195767195745,1]]]],[4]],[89,[113,3],[25,3,30,50],[4],[9,1]],[50,[4],[4],[4]],[103,[4],[4],[4],[4]],[51,[4],[4],[4]],[52,[4],[4]],[157,0.01,[9,1],[79,1,6,[10,[0,1],[[15,2,1],[36,2,-3.111111111111112,-3.111111111111112]]]],[87,[4,4292667899]],[87,[4,4292667899]],-222],[53,44]]],0,[0,9,1,0,0,1,0,0,1,0,0,1,0,44,70,0,0,1,0,0,1,0,-1,15,0,-2,30,0,-3,2,0,-4,44,0,0,2,0,0,2,0,0,2,0,0,2,0,-5,58,0,0,2,0,1,2,0,0,2,0,-1,32,0,-2,12,0,-3,33,0,-4,36,0,-5,14,0,0,3,0,0,3,0,0,3,0,0,3,0,-5,69,0,-6,70,0,-7,71,0,-1,21,0,-2,22,0,-3,23,0,-4,24,0,0,4,0,0,4,0,0,4,0,-4,60,0,0,4,0,0,4,0,-1,34,0,-2,35,0,0,5,0,0,5,0,0,5,0,0,5,0,-1,16,0,-3,7,0,-4,8,0,0,6,0,0,6,0,0,6,0,0,6,0,0,6,0,0,7,0,0,7,0,0,7,0,-1,53,0,-2,26,0,-3,11,0,0,8,0,0,8,0,13,8,0,1,31,0,1,8,0,0,8,0,0,8,0,0,8,0,0,9,0,0,9,0,0,9,0,0,9,0,0,9,0,0,10,0,0,10,0,0,10,0,0,10,0,0,10,0,0,11,0,0,11,0,13,11,0,1,42,0,0,11,0,-1,40,0,-2,41,0,0,12,0,0,12,0,0,13,0,0,13,0,-3,67,0,-4,68,0,-1,25,0,0,14,0,0,14,0,-1,27,0,-2,28,0,-3,29,0,0,15,0,-1,46,0,-2,48,0,-3,54,0,0,16,0,0,16,0,0,16,0,-1,17,0,0,17,0,0,17,0,0,17,0,-1,18,0,0,18,0,0,18,0,-1,19,0,-2,20,0,0,19,0,-2,61,0,25,61,0,0,19,0,0,20,0,-2,62,0,25,62,0,0,20,0,0,21,0,0,21,0,0,21,0,-1,37,0,0,22,0,0,22,0,0,22,0,-1,49,0,0,23,0,0,23,0,0,23,0,-1,50,0,0,24,0,0,24,0,0,24,0,0,25,0,0,25,0,-1,51,0,-2,52,0,0,26,0,0,26,0,0,26,0,-1,38,0,-1,72,0,0,27,0,0,27,0,-1,73,0,0,28,0,0,28,0,-1,74,0,0,29,0,0,29,0,0,30,0,-1,55,0,-2,56,0,-3,57,0,0,31,0,28,58,0,0,31,0,0,32,0,0,32,0,0,32,0,0,33,0,0,33,0,0,34,0,0,34,0,-3,59,0,0,35,0,0,35,0,0,35,0,0,36,0,0,36,0,0,37,0,0,37,0,-3,63,0,0,38,0,0,38,0,-1,39,0,0,39,0,0,39,0,0,39,0,0,40,0,0,40,0,0,40,0,0,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,-1,45,0,0,45,0,0,45,0,0,46,0,-1,47,0,0,47,0,0,47,0,0,48,0,0,49,0,-2,64,0,0,50,0,-2,65,0,0,51,0,-2,66,0,0,52,0,0,52,0,0,53,0,0,53,0,0,54,0,0,55,0,0,55,0,0,56,0,0,56,0,0,57,0,0,57,0,18,72,0,18,73,0,18,74,0,21,1,3,5,5,4,5,33,5,5,36,6,5,12,9,5,12,10,5,12,13,5,24,31,5,48,42,5,54,43,5,44,70,45,71,222],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,61,62,63,64,65,66,67,69,58],[4,4,-1,29,4,-1,29,4,-1,29,4,4,-1,4,4,4,4,4,4,-1,-2,-3,-4,4,-1,11,4,11,4,4,11,4,14,-1,29,4,14,27,4,-1,19,-1,19,-1,19,-1,-2,-3,27,27,11,11,11,4,11,11,11,20,20,20],[6,179,8,8,180,8,8,181,8,8,35,17,60,22,22,17,182,183,17,125,126,127,128,1,121,4,36,4,9,1,0,1,1,129,129,130,130,24,6,45,27,45,27,45,27,131,132,133,184,185,0,0,0,6,0,0,0,186,187,188]],[[[54,"Panel_Daily Mission"],[82,"Panel_Daily Mission",33554432,[-13,-14,-15,-16,-17,-18,-19,-20,-21],[[[17,-2,[1,"8a4wxBZXhE47SkZNetiiZE"],[5,126,136],[0,0.5,1]],[29,2,0,-3,[1,"13J2RMZUtBQJtmf+dhKvov"],[4,4292667899],18],[66,1,-4,[1,"a4TT6HnhlKyo+bOk/JllhX"]],[56,false,-5,[1,"2cOKs5cW1HPZwHE4uIXVVd"],[19,20,21,22,23,24]],-6,-7,[374,"hasAd",-12,[1,"9aYImQxz1C2qqP21T/n86m"],[375,-11,[[160,1,[[138,2,"questComplete","false"],[138,2,"questActive","true"]]],[160,2,[[138,2,"questComplete","true"],[138,2,"questActive","true"]]],[160,3,[[376,1,"claim"]]]]],[[6,"85848g+yY1PpKiragtG2vjV","setText",-10]],[[6,"3b28eOkVQtF/507hbMwzYxn","setFillPercentage",-9]],[[6,"85848g+yY1PpKiragtG2vjV","setText",-8]]]],4,4,4,4,1,1,4],[3,"b9tpjlp9VBian0Vwn0pf6D",-1,0],[1,0,448,0]],[22,"Progression Bar",33554432,1,[-29,-30],[[5,-22,[1,"f3HATR9OxBNIt1FW057jCi"],[5,100,18]],[31,0,-23,[1,"0fa7DHspVIs5IAlrXhpVOI"],[4,4279127440],5],[126,1,70.568,-24,[1,"adWqBjJVdGcIyJEgLCufKm"]],[377,-28,[1,"26iMoTB3JPV7HCbkUNE8Zp"],-27,[[6,"85848g+yY1PpKiragtG2vjV","setText",-26]],[[6,"85848g+yY1PpKiragtG2vjV","setText",-25]]]],[3,"252p7UX8hNepjZ7IQbN+mz",1,0],[1,0,-79.568,0]],[22,"Group_Detail",33554432,1,[-33,-34,-35],[[17,-31,[1,"f2PjPPbTlCbZh8bAPrINDK"],[5,100,20],[0,0.5,1]],[126,1,3.01,-32,[1,"1cO4BfrB5Op6DOopYUcEf/"]]],[3,"01h8JVZw1Eg58j8dFED+IU",1,0],[1,0,-3.01,0]],[22,"Group_Text",33554432,2,[-39,-40],[[5,-36,[1,"711d2tes9ODZdC0NFWupXM"],[5,25.67,20]],[221,1,1,3,-37,[1,"93BNfY0qNHfIOeMq3WzQqU"]],[145,2,2,-38,[1,"2b2kGN8cVBKZ3uBmw1Rt9K"],2]],[3,"49IaU09StDYb5OhFf12y5V",1,0],[1,-1.507,2,0]],[62,"Button_Claim",false,33554432,1,[-46],[[128,17,24,24,132,-33.333,140,26,1,-41,[1,"414PWexHlD9JH2EpFz1A8T"]],[5,-42,[1,"6fyhYxYAxEEL2ywGvarORN"],[5,100,26]],[29,1,0,-43,[1,"baEPqqIvhF647sI/KfocyF"],[4,4279794659],9],[108,3,0.9,-45,[1,"97P269ZwZKopQvnw/KRohr"],[[6,"69235X/kRBPI7XnaqkrAQBO","redeemRewardsClicked",1]],-44,10]],[3,"a487DHe1NCMrs9NB5SXl7D",1,0],[1,0,-145,0]],[22,"Sprite_Button Color",33554432,5,[-50],[[5,-47,[1,"96QrqrsxdHuq8Z19l2FkPP"],[5,96,22]],[29,1,0,-48,[1,"59OHPhl7dOf5i55rbeOY2a"],[4,4292667899],8],[40,45,2,2,1,3,183,94,-49,[1,"0aOK5JyO5F6Yl709nP/Yiu"]]],[3,"25ifcYBP9GjryKmLY8heR3",1,0],[1,0,1,0]],[62,"Button_Ad",false,33554432,1,[-56],[[128,20,24,24,183.354,10.037000000000006,140,26,1,-51,[1,"548fYLjVNHbY/4spUat5dJ"]],[5,-52,[1,"82lwpBYcJJY6wqGTANNDRz"],[5,100,28]],[29,1,0,-53,[1,"992IFk25hMirwpi8UmOrqL"],[4,4279794659],13],[108,3,0.9,-55,[1,"09DaW1Q8RBprrPcwgbRRfY"],[[6,"85c5d2mBTNAjKx4dLl8Y+bc","showAd",1]],-54,14]],[3,"73RsdKVxxL3bzc5kBKPOCt",1,0],[1,0,-111.963,0]],[22,"Sprite_Button Color",33554432,7,[-60],[[5,-57,[1,"a2u417+R9MsJ37O1EfWfL6"],[5,96,24]],[29,1,0,-58,[1,"270k1HgjhO76JnOKdg+hLl"],[4,4282815977],12],[40,45,2,2,1,3,183,94,-59,[1,"10vFBKwgVNcKcWoKp1O2sv"]]],[3,"190YQ+1/dDmYVf2K9lP5Wi",1,0],[1,0,1,0]],[44,"Text_QuestName",33554432,1,[[[17,-61,[1,"51R/nDOP1FwIIIJXtyRK5m"],[5,100,36.16],[0,0.5,1]],-62,[86,-64,[1,"c8VxE9lGJHdrlBGWdyhJtM"],-63]],4,1,4],[3,"b1/oxpfM1CaZJsesKTrE2Z",1,0],[1,0,-18,0]],[44,"Text_Progress",33554432,4,[[[5,-65,[1,"28Yw3aB2VEPI2u1C3Gb9E1"],[5,10.8,25.2]],-66,[86,-68,[1,"6ddl4lkPpHSr1wTksQBFxX"],-67]],4,1,4],[3,"a4AUW37ENCbZ+ibnG/o8RV",1,0],[1,-7.4350000000000005,0,0]],[44,"Text_Total",33554432,4,[[[5,-69,[1,"1an7yT5NZP0a7iRZncWFDY"],[5,11.87,25.2]],-70,[204,"/",-72,[1,"edTeRZxzxB0K2UROae0gVA"],-71]],4,1,4],[3,"39hMOPYEVHG6hK/Qc1zNiC",1,0],[1,6.899999999999999,1.988,0]],[22,"Group_Rewards",33554432,1,[-75,-76],[[5,-73,[1,"acwLFO/O5Kh4EkpAXGG8pV"],[5,100,32]],[126,1,93.915,-74,[1,"b83HoFlF1GxYyOmLaP+KfG"]]],[3,"d4mBOEtk9HHJIohGVM/URz",1,0],[1,0,-109.915,0]],[44,"Text_Value",33554432,12,[[[17,-77,[1,"b5jdy0uFRM/5PNnxDxuXdr"],[5,56,26],[0,1,0.5]],-78,[204,"x",-80,[1,"cdD2zWeSdCvaRAFPc6TU46"],-79]],4,1,4],[3,"7fdgaNS95IuJGyGxi/m2iI",1,0],[1,13.617,1.211,0]],[62,"ExtraPanel_Color",false,33554432,1,[-84],[[5,-81,[1,"f20n5xTNVEL5etHCA8FPNH"],[5,66,16]],[31,0,-82,[1,"1c0iP3oJZKorVZFasskA8R"],[4,4279489946],17],[83,4,44,1,-83,[1,"7fKP8fXVtMYowc3krpNTyr"]]],[3,"76fiPa8F5BDIGYY10Bg4D+",1,0],[1,0,-84,0]],[32,"Panel_Color",33554432,1,[[17,-85,[1,"a5o+spHEZDwbq4+yDrdYKR"],[5,118,128],[0,0.5,1]],[29,2,0,-86,[1,"51vOvnhTZNYYFAkK1cbJF3"],[4,4289449983],0],[128,45,4,4,4,4,124,128,1,-87,[1,"8eLZ/zcqRCsoS1Yo4CHQ1B"]]],[3,"d6Wq+PJxRIopR3LRSJjUqe",1,0],[1,0,-4,0]],[166,"Panel_Color2",false,33554432,1,[[17,-88,[1,"c2X78lASFOG6CgZjqshDsj"],[5,118,62],[0,0.5,0]],[29,1,0,-89,[1,"4eu++3Aj1Hi50GD80/jVWz"],[4,4292667899],4],[40,44,2,2,4,2,124,128,-90,[1,"efK+ad8YpFHrSNvK5is905"]]],[3,"beqCh+ROhD9ba2XjmluqA1",1,0],[1,0,-132,0]],[44,"Bar Fill",33554432,2,[[[17,-91,[1,"63E5dnEulHp71anrXhduO3"],[5,100,16],[0,0.5,0]],-92,[66,4,-93,[1,"53ZlPP2ptBioiGOCniyHbF"]]],4,1,4],[3,"a48V5qvwhFVaFekJXKIn1V",1,0],[1,0,-9,0]],[32,"Icon_Currency",33554432,12,[[5,-94,[1,"00hT8nuQlPdov5bWoA/xcE"],[5,26,26]],[74,0,-95,[1,"b6VBqHUORAf6TKiisuEXFA"],6],[57,-96,[1,"3boVSrEGNOAp7eOjl8bptf"]]],[3,"d9N200oCFPlbqjudfMWVND",1,0],[1,26.645,0,0]],[32,"Text_Label",33554432,6,[[5,-97,[1,"26E19HP/NM+oErpNRu2KiV"],[5,72,24]],[133,"Claim",21,21,20,2,false,false,-98,[1,"0dEyG6vW9DiKN3ih9sUqcb"],[4,4279794659],7],[127,41,12,12,-1.96,102,-99,[1,"b1uWygBJZMtpcnrpYYHdmh"]]],[3,"f5j+pab7hIS5WFGewaIAaU",1,0],[1,0,0.9600000000000009,0]],[32,"Text_Label",33554432,8,[[5,-100,[1,"5aJ66aQPpLR4J5QCqiHgdl"],[5,79.93,25.2]],[289,"Watch ad!",17,17,20,false,false,-101,[1,"afiP5BwHVBK7ZpMbvCL/A0"],[4,4292667899],11],[127,41,8.034999999999997,8.034999999999997,-1.4959999999999996,102,-102,[1,"9fazIHtSZHWKasHQ7afXrL"]]],[3,"581qlcDXFDw5vt4oI5w3K8",1,0],[1,0,0.895999999999999,0]],[22,"Text_Double Rewards",33554432,14,[-105],[[5,-103,[1,"e6FIFzFQBGRIrs2BGkX/hL"],[5,41.04,25.2]],[197,"for 2x",2,15,15,20,false,-104,[1,"13gFPJG7pJjquQnulPkgL2"],[4,4279461453],16]],[3,"57Dtc2X+BDY5+YMoiDwLTD",1,0],[1,-4.705,1.176,0]],[32,"Icon_Coin",33554432,21,[[17,-106,[1,"1a6C4lcclJOpiGib6O3tIW"],[5,15,15],[0,0,0.5]],[74,0,-107,[1,"543G4ZGOdEjquna9YNyruO"],15],[187,32,-14.715000000000002,-108,[1,"32b9Z7WcxNKZZ8H4kW56cC"]]],[3,"d0c0KPJj1GPq2/jOyWkcLN",1,0],[1,20.235,-1.438,0]],[90,"Slime_Detail01",33554432,3,[[17,-109,[1,"9cHBt6zDFG5Kqgf2P8CPBQ"],[5,96,80],[0,0.5,0]],[31,0,-110,[1,"81i1ncHS9KhI0tFuJdMBjt"],[4,4292667899],1]],[3,"8dQf5/nu5Nnb2lrSZa0IhY",1,0],[1,0,-10.063,0],[1,0.1,0.09,1]],[90,"Slime_Detail02",33554432,3,[[17,-111,[1,"cfrcfCNF1Idr7CpdbxoF0Y"],[5,96,80],[0,0.5,0]],[31,0,-112,[1,"balSKP6eFEtI0PTYJnpSKj"],[4,4292667899],2]],[3,"ceX4kLjcpPGYo6L+Da6Cqr",1,0],[1,-10,-10.063,0],[1,0.06,0.06,1]],[90,"Slime_Detail03",33554432,3,[[17,-113,[1,"30CIuhKCVMqZIUehJWbEb0"],[5,96,80],[0,0.5,0]],[31,0,-114,[1,"0esdF72khIzIppCKvAC3L2"],[4,4292667899],3]],[3,"443jR74oBFVrHA+uJwv1jN",1,0],[1,10,-10.063,0],[1,0.06,0.06,1]],[290,"Eat 3 Slimes and survive",0,17,17,16,3,false,false,9,[1,"d64lSZjSdJLqGbKvtg83wN"],[4,4279127440]],[100,3,0,17,[1,"cdkZvrawBDu7v8t99Is4lV"],[4,4288835553]],[199,"1",2,2,18,18,20,false,false,10,[1,"f8xJFos6RM54YVE8WPozcg"],[4,4292667899]],[199,"/3",0,2,13,13,20,false,false,11,[1,"2ea4B/jhNEXodI2bPSfxAI"],[4,4292667899]],[198,"x699",2,26,28,26,2,false,false,13,[1,"3byF1gV4BGY7vEKD3qmzdT"],[4,4279127440]],[63,1,[1,"dc+3dBoKFKFZozEpLwjjSZ"]],[76,1,[1,"dfSzPiL/hA9a6d25WsWk3o"],31]],0,[0,9,1,0,0,1,0,0,1,0,0,1,0,0,1,0,-5,31,0,-6,32,0,1,13,0,1,2,0,1,9,0,46,32,0,0,1,0,-1,15,0,-2,3,0,-3,16,0,-4,9,0,-5,2,0,-6,12,0,-7,5,0,-8,7,0,-9,14,0,0,2,0,0,2,0,0,2,0,1,11,0,1,10,0,47,27,0,0,2,0,-1,17,0,-2,4,0,0,3,0,0,3,0,-1,23,0,-2,24,0,-3,25,0,0,4,0,0,4,0,0,4,0,-1,10,0,-2,11,0,0,5,0,0,5,0,0,5,0,13,6,0,0,5,0,-1,6,0,0,6,0,0,6,0,0,6,0,-1,19,0,0,7,0,0,7,0,0,7,0,13,8,0,0,7,0,-1,8,0,0,8,0,0,8,0,0,8,0,-1,20,0,0,9,0,-2,26,0,25,26,0,0,9,0,0,10,0,-2,28,0,25,28,0,0,10,0,0,11,0,-2,29,0,25,29,0,0,11,0,0,12,0,0,12,0,-1,13,0,-2,18,0,0,13,0,-2,30,0,25,30,0,0,13,0,0,14,0,0,14,0,0,14,0,-1,21,0,0,15,0,0,15,0,0,15,0,0,16,0,0,16,0,0,16,0,0,17,0,-2,27,0,0,17,0,0,18,0,0,18,0,0,18,0,0,19,0,0,19,0,0,19,0,0,20,0,0,20,0,0,20,0,0,21,0,0,21,0,-1,22,0,0,22,0,0,22,0,0,22,0,0,23,0,0,23,0,0,24,0,0,24,0,0,25,0,0,25,0,21,1,114],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,27,28,29,30,31],[4,4,4,4,4,4,4,11,4,4,14,11,4,4,14,4,11,4,4,-1,-2,-3,-4,-5,-6,11,4,11,11,11,20],[2,5,5,5,6,6,35,4,9,9,9,4,9,9,9,36,4,9,2,112,114,113,116,115,117,4,6,4,4,0,189]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[10],0,[0],[33],[190]],[[[225,"nunito-bold","nunito-bold.ttf"],-1],0,0,[],[],[]],[[[58,[[59,[60,[-16,-17,-18,-19,-20,-21,-22,-23],[[65,-5,-4],[24,0,false,-7,-6,[[35,"Equipped"]]],[24,0,false,-9,-8,[[35,"Locked"]]],[24,0,false,-11,-10,[[35,"Unlocked"]]],[24,0,false,-13,-12,[[35,"CantUnlock"]]],[24,0,false,-15,-14,[[35,"click"]]]],-3,-2,-1]]],[{},"Locked",4,[28,2,false],"Unlocked",4,[28,2,false],"Equipped",4,[28,2,false],"CantUnlock",4,[28,2,false],"click",4,[28,2,false]]],[26,"Any"],[26,"Entry"],[18,"ButtonUnlock_Equiped State",[21,2],[19,1]],[26,"Exit"],[18,"ButtonUnlock_Unlock State",[21,0],[19,1]],[18,"ButtonUnlock_Equip State",[21,1],[19,1]],[18,"ButtonUnlock_NotEnough State",[21,3],[19,1]],[18,"ButtonUnlock_Click",[21,4],[19,1]]],0,[0,22,1,0,23,4,0,24,2,0,7,3,0,8,2,0,7,3,0,8,1,0,7,5,0,8,1,0,7,6,0,8,1,0,7,7,0,8,1,0,7,8,0,8,1,0,-1,2,0,-2,4,0,-3,1,0,-4,5,0,-5,6,0,-6,3,0,-7,7,0,-8,8,23],[0,0,0,0,0],[10,10,10,10,10],[67,64,65,66,68]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"outterColor",8,[4,4286940549],"mainTexture",6,0,"outterTexture",6,1]],11]]],0,0,[0,0,0],[17,40,16],[134,134,10]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"outterColor",8,[4,4286940549],"mainTexture",6,0,"outterTexture",6,1]],11]]],0,0,[0,0,0],[17,40,16],[135,135,10]],[[[58,[[59,[60,[-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39],[[24,0,false,-5,-4,[[35,"backButtonClick"]]],[80,0,-7,-6],[24,0,false,-9,-8,[[35,"playButtonClick"]]],[24,0,false,-11,-10,[[35,"changeSlimeClick"]]],[80,0,-13,-12],[24,0,false,-15,-14,[[35,"begin"]]],[24,0,false,-17,-16,[[35,"bumpStage"]]],[80,0,-19,-18],[65,-21,-20],[24,0,false,-23,-22,[[104,1,[46,"firstLoad"]]]],[334,0,false,0,-25,-24,[[72,[46,"firstLoad"]]]],[24,0,false,-27,-26,[[35,"finishedFirstLoad"]]]],-3,-2,-1]]],[{},"playButtonClick",4,[28,2,false],"changeSlimeClick",4,[28,2,false],"backButtonClick",4,[28,2,false],"begin",4,[28,2,false],"changeStage",4,[28,1,false],"bumpStage",4,[28,2,false],"firstLoad",4,[28,1,true],"finishedFirstLoad",4,[28,2,false]]],[18,"CanvasStart_Idle",[21,4],[19,1]],[18,"CanvasStar_Intro",[21,0],[19,1]],[18,"Clip Motion",[224],[19,1]],[26,"Entry"],[18,"CanvasStart_Character Select_Intro",[21,2],[19,1]],[18,"CanvasStart_Character Select_Exit",[21,3],[19,1]],[18,"CanvasStart_PreIntro",[21,5],[19,1]],[18,"CanvasStart_Change Stage_Bump",[21,6],[19,1]],[18,"CanvasStart_PreIntro-First Load",[21,7],[19,1]],[26,"Exit"],[26,"Any"],[18,"CanvasStart_Exit",[21,1],[19,1]]],0,[0,22,11,0,23,10,0,24,4,0,7,6,0,8,5,0,7,1,0,8,2,0,7,12,0,8,1,0,7,5,0,8,1,0,7,1,0,8,6,0,7,2,0,8,7,0,7,8,0,8,1,0,7,1,0,8,8,0,7,3,0,8,4,0,7,7,0,8,3,0,7,9,0,8,3,0,7,2,0,8,9,0,-1,4,0,-2,10,0,-3,11,0,-4,2,0,-5,12,0,-6,5,0,-7,6,0,-8,1,0,-9,7,0,-10,8,0,-11,3,0,-12,9,39],[0,0,0,0,0,0,0,0],[10,10,10,10,10,10,10,10],[105,106,107,109,191,108,110,111]],[[[58,[[59,[60,[-12,-13,-14,-15,-16,-17],[[24,0,false,-5,-4,[[104,1,[46,"active"]]]],[24,0,false,-7,-6,[[72,[46,"active"]]]],[65,-9,-8],[24,0,false,-11,-10,[[72,[46,"active"]]]]],-3,-2,-1]]],[{},"active",4,[28,1,false]]],[18,"HandyGuide_Intro",[21,0],[19,1]],[26,"Entry"],[18,"HandyGuide_Exit",[21,1],[19,1]],[18,"HandyGuide_OutScene",[21,2],[19,1]],[26,"Exit"],[26,"Any"]],0,[0,22,6,0,23,5,0,24,2,0,7,3,0,8,1,0,7,1,0,8,3,0,7,4,0,8,2,0,7,1,0,8,4,0,-1,2,0,-2,5,0,-3,6,0,-4,1,0,-5,3,0,-6,4,17],[0,0,0],[10,10,10],[122,123,124]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,3,3,0,0],"outterColor",8,[4,4290361855],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[192,10]],[[[97,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4286545791],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[63,11]],[[[54,"VirtualJoystick"],[237,"VirtualJoystick",[-9,-10,-11],[[5,-2,[1,"feJnc+5aFAaomEWg6TUqqa"],[5,128,128]],[378,-8,[1,"ebgbn3fThK4JifW7C4wLtr"],-7,-6,-5,-4,-3]],[3,"42eXoQaSpLhpUcJXK7t987",-1,0],[1,0,-300,0]],[243,"Content",1,[-16,-17],[[[5,-12,[1,"08p68lnrVNsZxGLhf3/4fE"],[5,128,128]],[49,45,100,100,-13,[1,"95sn+sVEtPr4PLGHKV/zRO"]],-14,[93,-15,[1,"e71ctEmpxFC4KlSYRZNz/a"],[4,939524095],2]],4,4,1,4],[3,"a7fnuoDZVD/ZRAMxw0qt7C",1,0]],[16,"SpriteBg",33554432,2,[[5,-18,[1,"f7NISe7HdAD68SLfhnddy8"],[5,128,128]],[75,-19,[1,"e71ctEmpxFC4KlSYRZNz/a"],0]],[3,"50Ujxr/aNFMatRB+3sT/Nf",1,0]],[16,"SpritePivot",33554432,2,[[5,-20,[1,"f7NISe7HdAD68SLfhnddy8"],[5,64,64]],[75,-21,[1,"e71ctEmpxFC4KlSYRZNz/a"],1]],[3,"36eZrS80hBy4UjhY7Yjyzk",1,0]],[172,"TweenShow",1,[[[8,-22,[1,"dcKJR0bGxAAognTdFobL96"]],-23,[379,0.15,true,-24,[1,"9d5x+W7JRIWoi85LydnBpZ"],2]],4,1,4],[3,"e68IptU51JQ5jMn4u2rvNA",1,0]],[172,"TweenHide",1,[[[8,-25,[1,"04mvDprWVJmKBgtj3OYK28"]],-26,[380,0.15,true,255,0,-27,[1,"cceQIzB95C+bDJX39fEKAF"],2]],4,1,4],[3,"a7uN+8rkhFIZvfXiP9rzov",1,0]],[57,2,[1,"47B7CdLgJKsoeGjd7pw7eC"]],[226,5,[1,"31hEm0catFwZfOtf5zXnFq"]],[226,6,[1,"486diRHOBMNpDwYZcx/+uU"]]],0,[0,9,1,0,0,1,0,48,9,0,49,8,0,50,3,0,51,4,0,52,7,0,0,1,0,-1,2,0,-2,5,0,-3,6,0,0,2,0,0,2,0,-3,7,0,0,2,0,-1,3,0,-2,4,0,0,3,0,0,3,0,0,4,0,0,4,0,0,5,0,-2,8,0,0,5,0,0,6,0,-2,9,0,0,6,0,21,1,27],[0,0,0],[4,4,4],[136,193,136]],[[[152,"builtin-particle",[{"hash":2766437914,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1064112832,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":3383871624,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1045353548,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z);\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[{"name":"T_JoystickBase_A","rect":{"x":0,"y":0,"width":128,"height":128},"offset":{"x":0,"y":0},"originalSize":{"width":128,"height":128},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[10],0,[0],[33],[194]],[[[227,[{}],[{}]]],0,0,[0],[16],[120]],[[[58,[[59,[60,[-12,-13,-14,-15,-16,-17],[[80,0,-5,-4],[65,-7,-6],[24,0,false,-9,-8,[[104,1,[46,"enabled"]]]],[24,0,false,-11,-10,[[72,[46,"enabled"]]]]],-3,-2,-1]]],[{},"enabled",4,[28,1,true]]],[18,"InfoPanel_Intro",[21,0],[19,1]],[26,"Entry"],[18,"InfoPanel_Sway",[21,1],[19,1]],[18,"InfoPanel_Exit",[21,2],[19,1]],[26,"Exit"],[26,"Any"]],0,[0,22,6,0,23,5,0,24,2,0,7,3,0,8,1,0,7,1,0,8,2,0,7,4,0,8,3,0,7,1,0,8,4,0,-1,2,0,-2,5,0,-3,6,0,-4,1,0,-5,3,0,-6,4,17],[0,0,0],[10,10,10],[30,31,32]],[[[54,"SlimeButton_01"],[82,"SlimeButton_01",33554432,[-45,-46,-47],[[[5,-2,[1,"4aZ7hoxtxHQbPDZMN81M0m"],[5,60,60]],-3,[109,3,0.82,-6,[1,"43j4Z2VihIabdkdMmS/tQi"],[[6,"cbdbcNUMMpM2Zn1GdDAXSDN","click",-5]],[4,4292269782],-4,13,14,15,16],[56,false,-7,[1,"71tcim6b9NX7ajNtVOoy4Y"],[17,18]],[381,2,-43,[1,"0bWPbJX8RH7awiNvx1sojn"],[[105,1,[[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-9],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-10],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-11],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-12],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-13]]],[105,2,[[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-14],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-15],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-16],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-17],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-18]]],[105,3,[[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-19],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-20],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-21],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-22],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-23],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-24]]],[105,4,[[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-25],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-26],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-27],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-28],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-29],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-30]]],[105,5,[[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-31],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-32],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-33],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-34],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-35],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-36]]],[105,6,[[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-37],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-38],[6,"c83f3h67FpJDoLcaBUEDjiF","activate",-39],[6,"c83f3h67FpJDoLcaBUEDjiF","deactivate",-40],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-41],[6,"9ed1aO88vFKYaSxKYGFNCSE","setColor",-42]]]],-8,[19,20,21,22]],[205,-44,[1,"aaWd9dJEdPlbRzkzGpSjYV"],23]],4,1,4,4,4,4],[3,"cdSEaiObZBOIHsO1usqOZf",-1,0],[1,30,0,0]],[244,"Icon_Owned-InUse",false,33554432,[[[5,-48,[1,"9485EdszdJx4a/GmU7eD9i"],[5,13,13]],-49,[37,-50,[1,"378MAYjSRNB7u9uTS3MtpS"]]],4,1,4],[3,"e57tLFdkBBR45E9mtwp8t9",1,0],[1,-8.291,7.998,0]],[238,"Icon_Lock",false,33554432,[[5,-51,[1,"f0iw7nxY1AsL8styfR63Fl"],[5,11,13]],[31,0,-52,[1,"4esbNkTMlF2JD/yVLgJMnR"],[4,4279449696],0],[37,-53,[1,"1fAAjHIwFF95DY8ESGMFS+"]]],[3,"51aFXvKRRPfKh8x5o6tjpa",1,0],[1,-8.411,8.09,0]],[43,"Selected",33554432,[[8,-54,[1,"0b7GJ/lU1PC73TKXKMcg2s"]],[41,-56,[1,"75yrR24FtCy4QqA9TJRbKX"],[4,4289449983],-55]],[3,"8evzYidutLVKEvQCBtvh6m",1,0]],[43,"Selected",33554432,[[8,-57,[1,"ffLMw0TOFBV4xyKnY1QBfb"]],[41,-59,[1,"46P6h55glBKJVMloDd4eC9"],[4,4289449983],-58]],[3,"9cl3fMDB9HMKfIISB6A8JN",1,0]],[171,"Icon_Slime",33554432,[-62,-63,-64],[[[5,-60,[1,"9ey4VCeOpGVr2CCZtn/Vj/"],[5,48,48]],-61],4,1],[3,"80+rvvYexBp4SDXUb4FciJ",1,0]],[61,"Colors",33554432,[-66,-67,-68,-69],[[8,-65,[1,"48o5LTQP1A8IB6pQWrTRGB"]]],[3,"3f0URQEwRA9LmrtkTK6rwS",1,0]],[20,"Button Outline",33554432,7,[-73,-74,-75],[[8,-70,[1,"52pI/Lu3hMOZjydZP+4P7x"]],[41,-72,[1,"6a7zNOVJxEr7sMhxNaPB5x"],[4,4294948456],-71]],[3,"b1aRiVldBO4br+YfjShM+G",1,0]],[16,"Selected",33554432,8,[[8,-76,[1,"57y5EX8qNErbObdr1zLTwt"]],[41,-78,[1,"3bLcichQBCJ6uk5aMYhaJ7"],[4,4294958592],-77]],[3,"d11Vf+nwlLqolLuhwlcE+U",1,0]],[143,"Panel_Color",33554432,1,[6],[[[5,-79,[1,"dd6ErI5ltGKrS4XJce6foD"],[5,52,52]],-80,[40,45,4,4,4,4,128,128,-81,[1,"86uhiLqalCEJG7uTKEGIIs"]]],4,1,4],[3,"55vFaqmAdG47Yt1ZKoTkhP",1,0]],[275,0,false,[1,"e2xb3lcJlPPoMy7O30kqHw"],[4,4289449983]],[22,"Group_Icon",33554432,1,[2,3],[[5,-82,[1,"708ZrVuRxDdq3F6o8P1BV2"],[5,40,40]],[66,9,-83,[1,"33M7CVi05GiJ40qAWGyJIE"]]],[3,"a49T9vaEVLbL7ZL/CzLCwl",1,0],[1,-10,10,0]],[100,1,0,1,[1,"13LJkYCoJNbIR0MFXzBKcJ"],[4,4285837550]],[16,"Not Selected",33554432,8,[[8,-84,[1,"e3A7rV/ShElqC3mAhhj5/D"]],[41,-85,[1,"5dppEkvNlEc71xx1XJE6EV"],[4,4285837550],13]],[3,"b9VHtMfm5Gros3/7lXfdzn",1,0]],[20,"Button Color",33554432,7,[4,-89],[[8,-86,[1,"a9nXrbqIxI/JuFV3ZSLlCZ"]],[41,-88,[1,"349gah9SRK7azXNWe1vLlo"],[4,4289449983],-87]],[3,"2853NnhmlFYp5zr6KFkoko",1,0]],[16,"Locked",33554432,15,[[8,-90,[1,"f5Q2Gkvm9O85M71Sww9dzB"]],[41,-92,[1,"fcBAK25MRMcra5D/j6dsbn"],[4,4283399860],-91]],[3,"6fi6J+0rNCM6fMlqjwnkAH",1,0]],[20,"Button Mask",33554432,7,[5,-95],[[8,-93,[1,"4bfBNTIn9GBYIB8EhgQm/x"]],[41,-94,[1,"01/3XgV7JGx7+eOHHSZTjU"],[4,4289449983],11]],[3,"45wcOA5LlO5YrINnnpp4Xl",1,0]],[16,"Locked",33554432,17,[[8,-96,[1,"9b8WnA5N9KRqDZ4MFrVisj"]],[41,-97,[1,"71IkxajJ5E8Z+XbAVSnVbo"],[4,4283399860],11]],[3,"ceRRHJgqBL8p7+Q8XLuSY/",1,0]],[43,"Equipped",33554432,[[8,-98,[1,"ccIVpXqahPK6oblvsagcVw"]],[41,-100,[1,"aah9hYgKxBtqcFCwHIOO+E"],[4,4294952267],-99]],[3,"ca2q88Y8RM97NDDGqMllNM",1,0]],[43,"Unlocked",33554432,[[8,-101,[1,"eblBJnKgRP/IPs5wTK59AL"]],[41,-103,[1,"64ZFcLc85D269A4OoOY6sf"],[4,4288206220],-102]],[3,"2doxxuKG1LZ6d9sNviZ1rQ",1,0]],[98,"Icon_Mask",33554432,6,[[[5,-104,[1,"cdaJYJr4pMe4EDrFpTF05G"],[5,48,48]],11,[49,45,208,148,-105,[1,"0eFnG5lPBKio9thfOWyWdA"]]],4,1,4],[3,"b0xn7jnbdFHqpPqoUImevA",1,0]],[276,0,false,10,[1,"17JOR9lblN37yC8p/z1nqk"],[4,4289449983]],[20,"Scripts",33554432,1,[7,-107],[[8,-106,[1,"e7N71Sg8JIUYJsk017QvXn"]]],[3,"7306GPq3dPC4GSSK41o2k9",1,0]],[16,"Locked",33554432,8,[[8,-108,[1,"63xGpu14dHrLAtgKpBWCL8"]],[41,-109,[1,"f7OzWuyspONZhvbcDq2Qnu"],[4,4280309396],13]],[3,"a58nFHGaRGE6RRrhbhtywz",1,0]],[20,"Icon_Owned-InUse",33554432,7,[19,20],[[8,-110,[1,"b8YAADtu9OdZry9pEX7HWh"]]],[3,"96bxyggEpNl7hdf58r3NPR",1,0]],[98,"Sprite_Degrade",33554432,6,[[[5,-111,[1,"37Iq7cE2xP26+aigQlBXGn"],[5,46,46]],-112],4,1],[3,"a9ZGpF4KJAiL0ztiE2eQ3i",1,0]],[98,"Icon_Outline",33554432,6,[[[5,-113,[1,"71NQSqpXpL9LAG7PXgRBlI"],[5,42,35]],-114],4,1],[3,"bdUP25N7NCy4LSJpy8rPOQ",1,0]],[277,0,2,[1,"5a+Zfm6L9EOoZVObt4qQmn"]],[16,"Update Texture Sprites",33554432,23,[[8,-115,[1,"efS3XYpSFI2KsYYRtevHav"]],[382,-118,[1,"44mloE1zRF8qMP1qLhFrkw"],[[139,"drop",1,2,3],[139,"frog",4,5,6],[139,"whip",7,8,9],[139,"bunny",10,11,12]],-117,11,-116]],[3,"661cHVEURBArtqAXPeq1Ri",1,0]],[194,0,false,26,[1,"e0rGZmPDtEIZmUFyCpnCcM"]],[278,27,[1,"f4Y/cGp2NJQ4+c9Bk8uDUR"],[4,4285837550]],[194,0,false,6,[1,"eb9r9ISWBJ2YZXxulicMaQ"]]],0,[0,9,1,0,0,1,0,-2,13,0,13,1,0,1,1,0,0,1,0,0,1,0,53,30,0,1,9,0,1,2,0,1,3,0,1,16,0,1,18,0,1,24,0,1,2,0,1,3,0,1,16,0,1,18,0,1,9,0,1,20,0,1,2,0,1,3,0,1,4,0,1,5,0,1,14,0,1,20,0,1,2,0,1,3,0,1,4,0,1,5,0,1,9,0,1,19,0,1,2,0,1,3,0,1,4,0,1,5,0,1,14,0,1,19,0,1,2,0,1,3,0,1,4,0,1,5,0,0,1,0,0,1,0,-1,10,0,-2,12,0,-3,23,0,0,2,0,-2,28,0,0,2,0,0,3,0,0,3,0,0,3,0,0,4,0,15,22,0,0,4,0,0,5,0,15,11,0,0,5,0,0,6,0,-2,32,0,-1,26,0,-2,21,0,-3,27,0,0,7,0,-1,8,0,-2,15,0,-3,17,0,-4,25,0,0,8,0,15,13,0,0,8,0,-1,9,0,-2,14,0,-3,24,0,0,9,0,15,13,0,0,9,0,0,10,0,-2,22,0,0,10,0,0,12,0,0,12,0,0,14,0,0,14,0,0,15,0,15,22,0,0,15,0,-2,16,0,0,16,0,15,22,0,0,16,0,0,17,0,0,17,0,-2,18,0,0,18,0,0,18,0,0,19,0,15,28,0,0,19,0,0,20,0,15,28,0,0,20,0,0,21,0,0,21,0,0,23,0,-2,29,0,0,24,0,0,24,0,0,25,0,0,26,0,-2,30,0,0,27,0,-2,31,0,0,29,0,54,31,0,55,32,0,0,29,0,21,1,2,5,12,3,5,12,4,5,15,5,5,17,6,5,10,7,5,23,11,0,21,19,5,25,20,5,25,118],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,11,31,32,22,28,13],[4,37,38,39,37,38,39,37,38,39,37,38,39,14,30,31,32,-1,-2,-1,-2,-3,-4,20,4,4,4,4,4,4,4],[195,44,23,43,97,196,96,100,98,99,103,101,102,2,12,13,14,119,118,41,38,39,40,197,42,23,43,44,2,7,2]],[[[81,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"outterColor",8,[4,4286940549],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[198,10]],[[[97,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4286545791],"mainTexture",6,0]],11]]],0,0,[0,0],[17,16],[37,11]],[[[58,[[59,[60,[-10,-11,-12,-13,-14,-15],[[65,-5,-4],[80,0,-7,-6],[223,0,-9,-8,[[35,"buttonBackClick"]]]],-3,-2,-1]]],[{},"buttonBackClick",4,[28,2,false]]],[26,"Entry"],[18,"CanvasReward_Intro",[21,0],[19,1]],[18,"CanvasGameOver_Idle",[21,1],[19,1]],[26,"Exit"],[26,"Any"],[18,"CanvasGameOver_Exit",[21,2],[19,1]]],0,[0,22,5,0,23,4,0,24,1,0,7,2,0,8,1,0,7,3,0,8,2,0,7,6,0,8,3,0,-1,1,0,-2,4,0,-3,5,0,-4,2,0,-5,3,0,-6,6,15],[0,0,0],[10,10,10],[131,132,133]]]]
